<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Amazing Coder</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Amazing Coder"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Amazing Coder"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="A programmer who loves coding and life."><meta property="og:type" content="blog"><meta property="og:title" content="Amazing Coder"><meta property="og:url" content="http://amazingcoderpro.github.io/"><meta property="og:site_name" content="Amazing Coder"><meta property="og:description" content="A programmer who loves coding and life."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://amazingcoderpro.github.io/img/og_image.png"><meta property="article:author" content="小武哥"><meta property="article:tag" content="代码 国学 篮球 音乐 Python Cpp 协作 项目管理"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://amazingcoderpro.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://amazingcoderpro.github.io"},"headline":"Amazing Coder","image":["http://amazingcoderpro.github.io/img/og_image.png"],"author":{"@type":"Person","name":"小武哥"},"publisher":{"@type":"Organization","name":"Amazing Coder","logo":{"@type":"ImageObject","url":"http://amazingcoderpro.github.io/img/logo.svg"}},"description":"A programmer who loves coding and life."}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Amazing Coder" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/amazingcoderpro/"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-08-15T12:14:36.000Z" title="2024/8/15 20:14:36">2024-08-15</time>发表</span><span class="level-item"><time dateTime="2024-08-15T12:14:36.000Z" title="2024/8/15 20:14:36">2024-08-15</time>更新</span><span class="level-item">几秒读完 (大约1个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/08/15/hideabcabcef-md/">_hideabcabcef.md</a></p><div class="content">这里是摘要。也可以用在文章中需要截断的地方增加<!--more-->,首页就会显示这条指令以上的内容，隐藏接下来的内容</div><a class="article-more button is-small is-size-7" href="/2024/08/15/hideabcabcef-md/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-08-15T12:13:54.000Z" title="2024/8/15 20:13:54">2024-08-15</time>发表</span><span class="level-item"><time dateTime="2024-08-15T12:13:54.000Z" title="2024/8/15 20:13:54">2024-08-15</time>更新</span><span class="level-item">几秒读完 (大约4个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/08/15/abcabcef-md/">abcabcef.md</a></p><div class="content">这里是摘要。也可以用在文章中需要截断的地方增加<!--more-->,首页就会显示这条指令以上的内容，隐藏接下来的内容</div><a class="article-more button is-small is-size-7" href="/2024/08/15/abcabcef-md/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-08-15T09:50:31.529Z" title="2024/8/15 17:50:31">2024-08-15</time>发表</span><span class="level-item"><time dateTime="2024-08-15T09:50:43.445Z" title="2024/8/15 17:50:43">2024-08-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/100-CodingSkills/">100_CodingSkills</a><span> / </span><a class="link-muted" href="/categories/100-CodingSkills/107-Network/">107_Network</a></span><span class="level-item">10 分钟读完 (大约1486个字)</span></div></div><div class="content"><h2 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h2><h3 id="1-如果一个内网中有多台机器同时访问外部服务是做了snat之后，回包怎么确定要回到哪台呢？"><a href="#1-如果一个内网中有多台机器同时访问外部服务是做了snat之后，回包怎么确定要回到哪台呢？" class="headerlink" title="1. 如果一个内网中有多台机器同时访问外部服务是做了snat之后，回包怎么确定要回到哪台呢？"></a>1. 如果一个内网中有多台机器同时访问外部服务是做了snat之后，回包怎么确定要回到哪台呢？</h3><ul>
<li>在snat的时候不仅对ip做了转换，同时对于端口号也做了转换，并在网关上保存了ip+port到源ip的映射关系，虽然回包的目的ip都一样，但是通过回包的目的端口就可以区分要回给哪个内网地址。 </li>
<li>那如果对于没有端口号的网络协议呢，比如icmp, 用type+code的方式来区分，其他类似网络协议也是同理，通过一些特殊标记来区分</li>
</ul>
<h3 id="2-Tcp-udp最大的区别"><a href="#2-Tcp-udp最大的区别" class="headerlink" title="2. Tcp, udp最大的区别"></a>2. Tcp, udp最大的区别</h3><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Iuvjwrm_O5g">https://www.youtube.com/watch?v=Iuvjwrm_O5g</a></p>
<ul>
<li><p>tcp是面向链接的，upd不是。 类别打电话和写信，在不考虑速度的情况下，他们的区别就类似tcp和udp的区别。tcp用于需要可靠链的，稳定可靠的。</p>
</li>
<li><p>tcp如何保证链接过程的有效性的呢：三次握手，传输确认， 四次挥手。</p>
</li>
<li><p>三次握手的必要性：如果换成二次握手，没有最后的ack, 那假如客户端向服务端发送一个syn1包， 然后由于网络原因这个syn包没有到达服务端， 然后客户端会重新发送一个syn2包，然后服务端收到了这个syn2包，并回复了syn+ack建起了链接 , 这时如果原来的那个syn1也到达了服务端，服务端认为是客户端又发起了一个链接请求， 会回复syn+ack , 然后建立起了一个新的链接。并等待接受数据。而在客户端认为只有一个链接，两边的状态不一致。如果在三次握手的情况下， 服务端收不到最后的ack，自然不会认为链接建立成功。所以三次握手本质上就是为了解决网络信道不可靠的问题，为了能够在不可靠的信道上建立起可靠的链接。经过三次握手后， 客户端和服务端都进入了数据传输状态。</p>
</li>
<li><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h56o45kg2fj20wo0t8tb2.jpg" alt="image-20220814223240813" style="zoom:50%;" />
</li>
<li><p>分包之后的丢包或者乱序的问题怎么解决：通过序列号和长度。 ack可以一发一答，也可以累积多包后一次性应答。缺失了那段就要求重传哪一段。另外tcp是全双工的， 这个机制不区分客户端和服务端，都采用这个机制。</p>
<img src="/Users/charles/data/01_CSIG/03_工作总结/01_朝花夕拾/e6c9d24ely1h56ogt9lv1j21800u0jw1.jpg" alt="image-20220814224608503" style="zoom:50%;" />
</li>
<li><p>四次挥手：处于链接状态的客户端和服务端都可以发起关闭链接的请求。</p>
<ul>
<li>Fin-wait-2状态，服务端还可以继续发送未完成的数据包，客户端也可以接受数据。待服务端发送完数据之后，发送一个fin包，</li>
<li>主动断开方进入time_wait状态后，等待超时后关闭链接。而服务端收到最后一个ack之后立刻断开链接。主动方等待超时时间是为保障对端收到了最后一个ack, 如果不等待，那么一旦ack在网络中丢失，那么对端就一直处于last-ack状态。如果等待，服务端一直收不到ack则会重发fin包， 这样客户端就可以再次响应fin，回复ack，并刷新超时时间。和三次握手一样，也是为了在不可靠的网络中进行可靠的连接断开确认。</li>
</ul>
<img src="/Users/charles/data/01_CSIG/03_工作总结/01_朝花夕拾/e6c9d24ely1h56olmh236j21kd0u0q8o.jpg" alt="image-20220814225047711" style="zoom:50%;" />


</li>
<li><p>Udp: 非连接，无状态，简单封装后直接发出， 性能损耗少，资源占用少，稳定性若，速度快，不能保证不丢包。 udp用于速度快，不care丢包， 还有隧道网络，如vpn,vxlan.</p>
</li>
</ul>
<h3 id="tun网卡，只有ip没有Mac"><a href="#tun网卡，只有ip没有Mac" class="headerlink" title="tun网卡，只有ip没有Mac"></a>tun网卡，只有ip没有Mac</h3><h3 id="3-SDN介绍"><a href="#3-SDN介绍" class="headerlink" title="3. SDN介绍"></a>3. SDN介绍</h3><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=0_LYsGKStJI">乾颐堂大话云计算架构第二季 SDN </a></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h58vg7z764j20w10joacc.jpg" alt="image-20220816201854753"></p>
<p>下一步：基于意图的网络   诉求–》控制器–》设备  更平滑，不关心下面的实现，兼容更多的设备型号</p>
<h4 id="传统数据中心架构"><a href="#传统数据中心架构" class="headerlink" title="传统数据中心架构"></a>传统数据中心架构</h4><p>top of rack switches–&gt;aggregation layer switches<br>end of row switches<br>南北向流量n-s: 客户在北， 数据中心在南</p>
<h4 id="虚拟化数据中心架构"><a href="#虚拟化数据中心架构" class="headerlink" title="虚拟化数据中心架构"></a>虚拟化数据中心架构</h4><p>东西流量：web-&gt;app server-&gt;db, 服务器之间的流量<br>spine and leaf架构 扁平化。利于东西访问</p>
<h4 id="SDN为什么要吧数据平面和控制平面分开"><a href="#SDN为什么要吧数据平面和控制平面分开" class="headerlink" title="SDN为什么要吧数据平面和控制平面分开"></a>SDN为什么要吧数据平面和控制平面分开</h4><p>传统网络独立配置，独立控制，容易出错</p>
<p>集中控制， 网络可编程, 自定义</p>
<p>openflow 开源南向控制协议</p>
<h4 id="发展路线"><a href="#发展路线" class="headerlink" title="发展路线"></a>发展路线</h4><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h58s9attf6j20yq0g5q5k.jpg" alt="image-20220816182747661"></p>
<h4 id="overlay-underlay"><a href="#overlay-underlay" class="headerlink" title="overlay underlay"></a>overlay underlay</h4><p>Overlay: vxlan、 gre </p>
<p>Underlay: ospf, bgp, is-is,  路由可达即可</p>
<h4 id="sdn与nfv"><a href="#sdn与nfv" class="headerlink" title="sdn与nfv"></a>sdn与nfv</h4><p>Nfv: net function virtualization, not network virtualization.  把网络功能移植到标准的虚拟服务器上</p>
<p>网络虚拟化： vlan, vxlan, vrf</p>
<p>网络功能虚拟化：把某些网络功能移植到标准的虚拟服务器上， 路由器，防火墙，负载均衡等。 降低成本+现在的硬件计算能力也够</p>
<p>Sdn nfv区别：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h58wd3elt4j20z50e0dip.jpg" alt="image-20220816205033627"></p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h58wcyi8vyj20x20jndit.jpg" alt="image-20220816205000884"></p>
<p>Sdn 和nfv本质上是不同层面的东西。 sdn是用来控制与数据分离， nfv是用通用服务器来虚拟化特定的网络功能，比如防火墙等。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h58wi78athj20pe0luac7.jpg" alt="image-20220816205522778"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-08-15T09:50:31.529Z" title="2024/8/15 17:50:31">2024-08-15</time>发表</span><span class="level-item"><time dateTime="2024-08-15T09:50:43.445Z" title="2024/8/15 17:50:43">2024-08-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/100-CodingSkills/">100_CodingSkills</a><span> / </span><a class="link-muted" href="/categories/100-CodingSkills/108-Coding/">108_Coding</a></span><span class="level-item">8 分钟读完 (大约1186个字)</span></div></div><div class="content"><hr>
<p>00_CodingInterview<br>aliases:<br>tags: #cs#interview #coding<br>date: 2023-10-08 15:29</p>
<hr>
<p>编程题本身不考察算法掌握程度，但是考察基本的逻辑思维，把算法转换为代码的能力，以及基本的错误处理。现场面试用纸笔，白板，电脑都可以，远程面试可以用在线代码平台，比如<a target="_blank" rel="noopener" href="http://collabedit.com/">collabedit</a>，<a target="_blank" rel="noopener" href="https://codeshare.io/">codeshare.io</a>，<a target="_blank" rel="noopener" href="https://codeinterview.io/">codeinterview.io</a><br>复杂的算法不太容易验证，二十行内能解决的不太复杂的算法题为宜，速度越快越好，代码不能有明显的语法错误和低级错误</p>
<h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h2><h3 id="关于快速排序"><a href="#关于快速排序" class="headerlink" title="关于快速排序"></a>关于快速排序</h3><ul>
<li>cpp sort函数内部是什么</li>
</ul>
<p>sort函数内部使用快速排序算法实现，它的时间复杂度为O(nlogn)，是一种非常高效的排序算法。</p>
<ul>
<li><p>快排的原理</p>
<ul>
<li>选择一个基准元素。</li>
<li>将小于等于基准元素的元素移动到数组左边，大于基准元素的元素移动到数组右边，这个过程称为划分。</li>
<li>递归地对划分后的左右两个子序列进行排序。</li>
</ul>
</li>
<li><p>在实际实现中，sort函数还有一些优化，例如：</p>
<ul>
<li>当排序的元素个数小于一定阈值时，使用插入排序算法。</li>
<li>当出现大量重复元素时，使用三向划分快速排序算法。</li>
</ul>
</li>
<li><p>为什么选快排<br>  默认它的分布是比较随机的那种分布，然后快排在比较随机的分布上，表现的比较好，速度比较快</p>
</li>
<li></li>
<li></li>
<li><p>栈的简单实现 push pop功能</p>
</li>
<li><p>栈、队列区别，用数组实现栈</p>
</li>
<li><p>二叉树深度、广度遍历</p>
</li>
</ul>
<h2 id="2-上机"><a href="#2-上机" class="headerlink" title="2. 上机"></a>2. 上机</h2><h3 id="2-1-算法与数据结构"><a href="#2-1-算法与数据结构" class="headerlink" title="2.1 算法与数据结构"></a>2.1 算法与数据结构</h3><ul>
<li><p>c++反转单链表。</p>
</li>
<li><p>非递归实现二叉树</p>
</li>
<li><p>写一个实现字符串拷贝的函数。给定字符串拷贝函数strcpy的原型：<br>char *strcpy(char *dest,const char *src); 要求：（1）不调用任何库函数。（2）说明函数为什么返回char *.<br> <code> char *strcpy(char *dest,char *src) &#123;  if( (dest == NULL) || (src == NULL) )  &#123;  return NULL;  &#125;  char *ret_string = dest;  while( *dest ++ = *src++)!=’\0′);  return ret_string;  &#125; </code></p>
</li>
<li><p>链表逆序</p>
</li>
<li><p>二叉树求宽度&#x2F;深度</p>
</li>
<li><p>字符串处理：Split, Trim，逆序</p>
</li>
<li><p>编码：UTF8编解码，Varint编解码，十六进制编解码</p>
</li>
<li><p>数组去重，保持顺序 [1, 2, 3, 1, 2] -&gt; [1, 2, 3]</p>
</li>
<li><p>数组去重，保持顺序，后面的出现后，前面的去掉，[1, 2, 3, 2, 1] -&gt; [3, 2, 1]</p>
</li>
<li><p>位图中查找第一个设置&#x2F;未设置的位的偏移量</p>
</li>
<li><p>手写 LRU</p>
</li>
</ul>
<h3 id="2-2-接口设计"><a href="#2-2-接口设计" class="headerlink" title="2.2  接口设计"></a>2.2  接口设计</h3><h4 id="比如String类的接口设计（构造函数，拷贝，赋值，拼接等）"><a href="#比如String类的接口设计（构造函数，拷贝，赋值，拼接等）" class="headerlink" title="比如String类的接口设计（构造函数，拷贝，赋值，拼接等）"></a>比如String类的接口设计（构造函数，拷贝，赋值，拼接等）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">String</span>();</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* str);</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">String</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span>* str);</span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(<span class="type">const</span> String&amp; other);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接运算符</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span>* str);</span><br><span class="line">    String&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> String&amp; other);</span><br><span class="line">    <span class="keyword">friend</span> String <span class="keyword">operator</span>+(<span class="type">const</span> String&amp; lhs, <span class="type">const</span> String&amp; rhs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问字符</span></span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取长度</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为C风格字符串</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_data;</span><br><span class="line">    <span class="type">size_t</span> m_length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line">String::<span class="built_in">String</span>() : <span class="built_in">m_data</span>(<span class="literal">nullptr</span>), <span class="built_in">m_length</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">String::<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* str) &#123;</span><br><span class="line">    m_length = <span class="built_in">strlen</span>(str);</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[m_length + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">String::<span class="built_in">String</span>(<span class="type">const</span> String&amp; other) &#123;</span><br><span class="line">    m_length = other.m_length;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[m_length + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">String::~<span class="built_in">String</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值运算符</span></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span>* str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (m_data != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    &#125;</span><br><span class="line">    m_length = <span class="built_in">strlen</span>(str);</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[m_length + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, str);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="type">const</span> String&amp; other) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_data != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        &#125;</span><br><span class="line">        m_length = other.m_length;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span>[m_length + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接运算符</span></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span>* str) &#123;</span><br><span class="line">    <span class="type">size_t</span> old_length = m_length;</span><br><span class="line">    m_length += <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="type">char</span>* tmp = <span class="keyword">new</span> <span class="type">char</span>[m_length + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmp, m_data);</span><br><span class="line">    <span class="built_in">strcat</span>(tmp, str);</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    m_data = tmp;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>+=(<span class="type">const</span> String&amp; other) &#123;</span><br><span class="line">    <span class="type">size_t</span> old_length = m_length;</span><br><span class="line">    m_length += other.m_length;</span><br><span class="line">    <span class="type">char</span>* tmp = <span class="keyword">new</span> <span class="type">char</span>[m_length + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmp, m_data);</span><br><span class="line">    <span class="built_in">strcat</span>(tmp, other.m_data);</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    m_data = tmp;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String <span class="keyword">operator</span>+(<span class="type">const</span> String&amp; lhs, <span class="type">const</span> String&amp; rhs) &#123;</span><br><span class="line">    <span class="function">String <span class="title">result</span><span class="params">(lhs)</span></span>;</span><br><span class="line">    result += rhs;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问字符</span></span><br><span class="line"><span class="type">char</span>&amp; String::<span class="keyword">operator</span>[](<span class="type">size_t</span> index) &#123;</span><br><span class="line">    <span class="keyword">return</span> m_data[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>&amp; String::<span class="keyword">operator</span>[](<span class="type">size_t</span> index) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m_data[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取长度</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">String::length</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为C风格字符串</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">String::c_str</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;String.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">str1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str1: &quot;</span> &lt;&lt; str1.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    String str2 = str1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str2: &quot;</span> &lt;&lt; str2.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    str2 += <span class="string">&quot;, world!&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str2 after concatenation: &quot;</span> &lt;&lt; str2.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    String str3 = str1 + str2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str3 after concatenation: &quot;</span> &lt;&lt; str3.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>用数组实现循环队列</li>
<li>可以考察一些函数的实现，比如String类+&#x3D;的实现，主要关注正确性和内存泄漏和越界</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-08-15T09:50:31.528Z" title="2024/8/15 17:50:31">2024-08-15</time>发表</span><span class="level-item"><time dateTime="2024-08-15T09:50:43.445Z" title="2024/8/15 17:50:43">2024-08-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/100-CodingSkills/">100_CodingSkills</a><span> / </span><a class="link-muted" href="/categories/100-CodingSkills/107-Network/">107_Network</a></span><span class="level-item">2 分钟读完 (大约356个字)</span></div></div><div class="content"><h3 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h3><h3 id="数据包封装"><a href="#数据包封装" class="headerlink" title="数据包封装"></a>数据包封装</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gybyn0vik8j30rb0gcgn2.jpg" alt="image-20220113130326966"></p>
<h3 id="Linux网络体系"><a href="#Linux网络体系" class="headerlink" title="Linux网络体系"></a>Linux网络体系</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gybyr6kcrtj30td0etdh8.jpg" alt="image-20220113130736982"></p>
<h3 id="TCP处理过程"><a href="#TCP处理过程" class="headerlink" title="TCP处理过程"></a>TCP处理过程</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gybys941qlj30vz0hijtl.jpg" alt="image-20220113130838316"></p>
<h2 id="Socket层"><a href="#Socket层" class="headerlink" title="Socket层"></a>Socket层</h2><p>为了解决数据传输而抽象出来的机制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">man socket</span><br><span class="line">mpstat 1</span><br><span class="line">perf top </span><br><span class="line">cat /proc/sys/net/ipv4/tcp_max_tw_buckets  tcp timewait最大数，（主要是占用fd, 新建连接时回收比较慢，因为要找到那个等待时间最长的time_wait， 然后重新平衡二叉树）</span><br><span class="line">echo 4096 &gt; !$</span><br><span class="line"></span><br><span class="line">设置so_linger=no : close时直接发reset, 而不是四层挥手\</span><br><span class="line">netstat -antp</span><br><span class="line">free</span><br><span class="line">slabtop -- 内核消耗的内存</span><br><span class="line"></span><br><span class="line">cat /proc/sys/net/core/wmem_default</span><br><span class="line">cat /proc/sys/net/core/rmem_max</span><br><span class="line">so_reusetport -- 多个进程可以监听一个端口</span><br><span class="line"></span><br><span class="line">三次握手，四层挥手保证面相链接</span><br><span class="line">停止等待，保证可靠（事事有回应，等ack）---但是网络利用率很低</span><br><span class="line">滑动窗口</span><br><span class="line">拥塞控制 cubki, reno, bbr</span><br><span class="line"></span><br><span class="line">tc qd add dev ens33 root netem delay 1000ms 构建一个高延时</span><br><span class="line">TCP_CORK no push , 增加吞吐，</span><br><span class="line">TCP_NODELAY  push 标记小包也发</span><br><span class="line"></span><br><span class="line">IP_TTL</span><br><span class="line">IP_MTU</span><br><span class="line">IP_TOS</span><br><span class="line"></span><br><span class="line">cat /proc/net/nf_conntrack  防火墙跟踪</span><br><span class="line"></span><br><span class="line">网卡多队列</span><br><span class="line">多个队列分别映射给多个cpu, 提高性能</span><br><span class="line">cat /proc/interrupts | less</span><br></pre></td></tr></table></figure>



<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyh0264o2aj317n0u0q6o.jpg" alt="image-20220117214032640"></p>
<p>server:iperf -s -u -p 9999<br>client: iperf -c 103.145.43.51 -u -p 9999 -b 5000000</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-08-15T09:50:31.528Z" title="2024/8/15 17:50:31">2024-08-15</time>发表</span><span class="level-item"><time dateTime="2024-08-15T09:50:43.445Z" title="2024/8/15 17:50:43">2024-08-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/100-CodingSkills/">100_CodingSkills</a><span> / </span><a class="link-muted" href="/categories/100-CodingSkills/107-Network/">107_Network</a></span><span class="level-item">3 分钟读完 (大约423个字)</span></div></div><div class="content"><h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><h3 id="ipcalc"><a href="#ipcalc" class="headerlink" title="ipcalc"></a>ipcalc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipcalc 192.168.1.0/24</span><br></pre></td></tr></table></figure>

<h3 id="ip-addr"><a href="#ip-addr" class="headerlink" title="ip addr"></a>ip addr</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip addr add 192.168.120.125/24 dev ens3 --添加一个网络的地址,可以指定一个网络接口名字，在示例中它的名字是 ens3。这不需要去添加一个网络前缀，在本案例中，它是 /24，但是显式地添加它并没有什么坏处。你可以使用 ip 命令去检查你的配置</span><br><span class="line">ip addr</span><br></pre></td></tr></table></figure>



<h3 id="route"><a href="#route" class="headerlink" title="route"></a>route</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.ip_forward -- 查看路由转发是否开启,路由器必须配置去转发数据包。数据包转发默认是禁用的</span><br><span class="line">echo 1 &gt; /proc/sys/net/ipv4/ip_forward -- 开启</span><br><span class="line">sysctl -p 让变化生效</span><br><span class="line">ip route show 查看路由</span><br><span class="line">ip route add 192.168.120.0/24 via 192.168.110.126 dev ens3 -- 增加静态路由， 主机 1 可以通过路由器接口 192.168.110.126 去访问 192.168.110.0/24 网络。看一下它们是如何工作的？主机 1 和路由器需要连接到相同的地址空间，然后路由器转发到其它的网络。</span><br><span class="line">ip route del 192.168.120.0/24 删除路由</span><br></pre></td></tr></table></figure>

<h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.你可以使用 lsof 命令来查看某一端口是否开放。查看端口可以这样来使用，我就以80端口为例：</span><br><span class="line">lsof -i:80</span><br><span class="line">如果有显示说明已经开放了，如果没有显示说明没有开放</span><br><span class="line">2.netstat -aptn执行看看，是否监听在0.0.0.0:3306</span><br><span class="line">3.</span><br><span class="line">netstat -nupl (UDP类型的端口)</span><br><span class="line">netstat -ntpl (TCP类型的端口)</span><br><span class="line">4.查看端口的状态</span><br><span class="line">/etc/init.d/iptables status</span><br></pre></td></tr></table></figure>



<h3 id="Netstat-ant"><a href="#Netstat-ant" class="headerlink" title="Netstat -ant"></a>Netstat -ant</h3><p>socket Recv-Q 是否积压，积压值较大且长时间没有清空</p>
<p>调大 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_rmem，如果问题不能解决说明发送端发送流量确实较大，超过了接收端的处理速度，需要分流</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-08-15T09:50:31.527Z" title="2024/8/15 17:50:31">2024-08-15</time>发表</span><span class="level-item"><time dateTime="2024-08-15T09:50:43.445Z" title="2024/8/15 17:50:43">2024-08-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/100-CodingSkills/">100_CodingSkills</a><span> / </span><a class="link-muted" href="/categories/100-CodingSkills/107-Network/">107_Network</a></span><span class="level-item">3 小时读完 (大约28025个字)</span></div></div><div class="content"><hr>
<p>00_NetworkInterview<br>aliases:<br>tags: #cs#interview #network<br>date: 2023-10-08 15:29</p>
<hr>
<h1 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h1><h2 id="1-Basic-Concept"><a href="#1-Basic-Concept" class="headerlink" title="1. Basic Concept"></a>1. Basic Concept</h2><h3 id="TCP连接中间会有什么操作"><a href="#TCP连接中间会有什么操作" class="headerlink" title="TCP连接中间会有什么操作"></a>TCP连接中间会有什么操作</h3><p>在TCP连接中，客户端和服务器之间会进行以下操作：</p>
<ul>
<li><p>握手阶段：客户端向服务器发送SYN包（同步包），请求建立连接。服务器收到SYN包后，向客户端发送SYN+ACK包（同步确认包），表示可以建立连接。客户端收到SYN+ACK包后，再向服务器发送ACK包（确认包），表示连接建立成功。</p>
</li>
<li><p>数据传输阶段：连接建立成功后，客户端和服务器之间可以进行数据的传输。客户端向服务器发送数据包，服务器接收数据包并进行处理，然后向客户端发送响应包。客户端收到响应包后，可以再次向服务器发送数据包，以此类推。</p>
</li>
<li><p>断开连接阶段：当客户端或服务器不再需要连接时，可以发送FIN包（结束包）来请求断开连接。对方收到FIN包后，也发送FIN包进行响应，表示同意断开连接。当两端都收到对方的FIN包后，连接才真正关闭。</p>
</li>
</ul>
<p>需要注意的是，在TCP连接中可能会出现丢包、拥塞等情况，需要进行相应的处理，例如重传丢失的数据包、调整发送窗口大小等</p>
<h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><ul>
<li>TCP 三次握手中，客户端收到的第二次握手中 ack 确认号不是自己期望的，会发生什么？是直接丢弃 or 回 RST 报文？</li>
<li>什么情况下会收到不正确的 ack（第二次握手中的 ack） 呢？<br>不卖关子，直接说这个问题，是<strong>回 RST 报文</strong>。过程如下图：</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeRVaGLU0HSwicWshvgthyXukQSF6kevWWckbxxO3pOCgfYqSVl8H7icM0zFzWD6gjg5n0mI1ETeZew/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>三次握手避免历史连接</p>
<p>当客户端连续发送多次建立连接的 SYN 报文，然后在网络拥堵的情况，就会发生客户端收到不正确的 ack 的情况。具体过程如下：</p>
<ul>
<li><p>客户端先发送了 SYN（seq &#x3D; 90） 报文，但是被网络阻塞了，服务端并没有收到，接着客户端又重新发送了 SYN（seq &#x3D; 100） 报文，注意不是重传 SYN，重传的 SYN 的序列号是一样的。</p>
</li>
<li><p>「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端，那么此时服务端就会回一个 SYN + ACK 报文给客户端，此报文的确认号是 91（90+1）。</p>
</li>
<li><p>客户端收到后，发行自己期望收到的确认号应该是 100+1，而不是 90 + 1，于是就会回 RST 报文。</p>
</li>
<li><p>服务端收到 RST 报文后，就会中止连接。</p>
</li>
<li><p>后续最新的 SYN 抵达了服务端后，客户端与服务端就可以正常的完成三次握手了。</p>
</li>
</ul>
<p>上述中的「旧 SYN 报文」称为历史连接，TCP 使用三次握手建立连接的<strong>最主要原因就是防止「历史连接」初始化了连接</strong>。</p>
<p>我们也可以从 RFC 793 知道 TCP 连接使用三次握手的首要原因：</p>
<p><em>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</em></p>
<p>简单来说，三次握手的首要原因是为了防止旧的重复连接初始化造成混乱。RFC 给出的三次握手防止历史连接的案例图如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeRVaGLU0HSwicWshvgthyXulbVmhSyuhoYJicsSqqzlLicN8vibzkAZB3WoAw0cCYE990DtCZckUXdwQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>RFC 793</p>
<p>如果是两次握手连接，就无法阻止历史连接，那<strong>为什么 TCP 两次握手为什么无法阻止历史连接呢？</strong></p>
<p>我先直接说结论，主要是因为<strong>在两次握手的情况下，「被动发起方」没有中间状态给「主动发起方」来阻止历史连接，导致「被动发起方」可能建立一个历史连接，造成资源浪费</strong>。</p>
<p>你想想，两次握手的情况下，「被动发起方」在收到 SYN 报文后，就进入 ESTABLISHED 状态，意味着这时可以给对方发送数据给，但是「主动发」起方此时还没有进入 ESTABLISHED 状态，假设这次是历史连接，主动发起方判断到此次连接为历史连接，那么就会回 RST 报文来断开连接，而「被动发起方」在第一次握手的时候就进入 ESTABLISHED 状态，所以它可以发送数据的，但是它并不知道这个是历史连接，它只有在收到 RST 报文后，才会断开连接。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeRVaGLU0HSwicWshvgthyXuHS7B2sADweWDX3rVH109Hqdw5fbYbJMetYTT3xEicicBrYiaSm7KYnPfg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>两次握手无法阻止历史连接</p>
<p>可以看到，上面这种场景下，「被动发起方」在向「主动发起方」发送数据前，并没有阻止掉历史连接，导致「被动发起方」建立了一个历史连接，又白白发送了数据，妥妥地浪费了「被动发起方」的资源。</p>
<p>因此，<strong>要解决这种现象，最好就是在「被动发起方」发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手</strong>。</p>
<p>我说回 RST 就回 RST 吗？当然不是了，肯定得用源码证明我说的这个结论。</p>
<p>听到要源码分析，可能有的同学就怂了。</p>
<p>其实要分析我们今天这个问题，只要懂 if else 就行了，我也会用中文来表述代码的逻辑，所以单纯看我的文字也是可以的。</p>
<p>这次我们重点分析的是，在 SYN_SENT 状态下，收到不正确的确认号的 syn+ack 报文是如何处理的。</p>
<p>处于 SYN_SENT 状态下的客户端，在收到服务端的  syn+ack 报文后，最终会调用  tcp_rcv_state_process，在这里会根据 TCP 状态做对应的处理，这里我们只关注 SYN_SENT 状态。</p>
<p><code>// net/ipv4/tcp_ipv4.c   int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb)   &#123;    ...         int queued = 0;          ...         switch (sk-&gt;sk_state) &#123;    case TCP_CLOSE:     ...    case TCP_LISTEN:     ...    case TCP_SYN_SENT:       ....     queued = tcp_rcv_synsent_state_process(sk, skb, th);     if (queued &gt;= 0)      return queued;       ...    &#125;   </code></p>
<p>可以看到，接下来，会继续调用 tcp_rcv_synsent_state_process 函数。</p>
<p><code>static int tcp_rcv_synsent_state_process(struct sock *sk, struct sk_buff *skb,         const struct tcphdr *th)   &#123;    ....       if (th-&gt;ack) &#123;     /* rfc793:      * &quot;If the state is SYN-SENT then      *    first check the ACK bit      *      If the ACK bit is set      *   If SEG.ACK =&lt; ISS, or SEG.ACK &gt; SND.NXT, send      *        a reset (unless the RST bit is set, if so drop      *        the segment and return)&quot;      */       // ack 的确认号不是预期的     if (!after(TCP_SKB_CB(skb)-&gt;ack_seq, tp-&gt;snd_una) ||         after(TCP_SKB_CB(skb)-&gt;ack_seq, tp-&gt;snd_nxt))         //回 RST 报文      goto reset_and_undo;        ...   &#125;      </code></p>
<p>从上面的函数，就可以得知了，客户端在 SYN_SENT 状态下，收到不正确的确认号的 syn+ack 报文会回 RST 报文。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><blockquote>
<p>TCP 三次握手中，客户端收到的第二次握手中 ack 确认号不是自己期望的，会发生什么？是直接丢弃 or 回 RST 报文？</p>
</blockquote>
<p>回 RST 报文。</p>
<blockquote>
<p>什么情况下会收到不正确的 ack（第二次握手中的 ack） 呢？</p>
</blockquote>
<p>当客户端发起多次 SYN 报文，然后网络拥堵的情况下，「旧的 SYN 报文」比「新的 SYN 报文」早抵达服务端，此时服务端就会按照收到的「旧的 SYN 报文」回复 syn+ack 报文，而此报文的确认号并不是客户端期望收到的，于是客户端就会回 RST 报文。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>虽然我们在学习 TCP 挥手时，学到的是需要四次来完成 TCP 挥手，但是<strong>在一些情况下， TCP 四次挥手是可以变成 TCP 三次挥手的</strong>。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtq0WaxOzTFbA8SQ5Am8ibRL1JMdq5GibqVeXYWOXB3gtdHAMwic01mMAOSw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>而且在用 wireshark 工具抓包的时候，我们也会常看到 TCP 挥手过程是三次，而不是四次，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqh59jUuDV016elb1Z9Hn0GwfCuDdZbqm1cAn3Pf8FI7RSyficSXgT8Qg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>先来回答为什么 RFC 文档里定义 TCP 挥手过程是要四次？</p>
<p>再来回答什么情况下，什么情况会出现三次挥手？</p>
<h4 id="为什么-TCP-挥手需要四次？"><a href="#为什么-TCP-挥手需要四次？" class="headerlink" title="为什么 TCP 挥手需要四次？"></a>为什么 TCP 挥手需要四次？</h4><p>TCP 四次挥手的过程如下：<br>![[Pasted image 20230518120138.png]]</p>
<p>具体过程：</p>
<ul>
<li><p>客户端主动调用关闭连接的函数，于是就会发送 FIN 报文，这个  FIN 报文代表客户端不会再发送数据了，进入 FIN_WAIT_1 状态；</p>
</li>
<li><p>服务端收到了 FIN 报文，然后马上回复一个 ACK 确认报文，此时服务端进入 CLOSE_WAIT 状态。在收到 FIN 报文的时候，TCP 协议栈会为 FIN 包插入一个文件结束符 EOF 到接收缓冲区中，服务端应用程序可以通过 read 调用来感知这个 FIN 包，这个 EOF 会被<strong>放在已排队等候的其他已接收的数据之后</strong>，所以必须要得继续 read 接收缓冲区已接收的数据；</p>
</li>
<li><p>接着，当服务端在 read 数据的时候，最后自然就会读到 EOF，接着 <strong>read() 就会返回 0，这时服务端应用程序如果有数据要发送的话，就发完数据后才调用关闭连接的函数，如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数</strong>，这时服务端就会发一个 FIN 包，这个  FIN 报文代表服务端不会再发送数据了，之后处于 LAST_ACK 状态；</p>
</li>
<li><p>客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进入 TIME_WAIT 状态；</p>
</li>
<li><p>服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态；</p>
</li>
<li><p>客户端经过 2MSL 时间之后，也进入 CLOSE 状态；</p>
</li>
</ul>
<p>你可以看到，每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。</p>
<h4 id="为什么-TCP-挥手需要四次呢？"><a href="#为什么-TCP-挥手需要四次呢？" class="headerlink" title="为什么 TCP 挥手需要四次呢？"></a>为什么 TCP 挥手需要四次呢？</h4><p>服务器收到客户端的 FIN 报文时，内核会马上回一个 ACK 应答报文，<strong>但是服务端应用程序可能还有数据要发送，所以并不能马上发送 FIN 报文，而是将发送 FIN 报文的控制权交给服务端应用程序</strong>：</p>
<ul>
<li><p>如果服务端应用程序有数据要发送的话，就发完数据后，才调用关闭连接的函数；</p>
</li>
<li><p>如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数，</p>
</li>
</ul>
<p>从上面过程可知，<strong>是否要发送第三次挥手的控制权不在内核，而是在被动关闭方（上图的服务端）的应用程序，因为应用程序可能还有数据要发送，由应用程序决定什么时候调用关闭连接的函数，当调用了关闭连接的函数，内核就会发送 FIN 报文了，</strong>所以服务端的 ACK 和 FIN 一般都会分开发送。</p>
<blockquote>
<p>FIN 报文一定得调用关闭连接的函数，才会发送吗？</p>
</blockquote>
<p>不一定。</p>
<p>如果进程退出了，不管是不是正常退出，还是异常退出（如进程崩溃），内核都会发送 FIN 报文，与对方完成四次挥手。</p>
<h4 id="粗暴关闭-vs-优雅关闭"><a href="#粗暴关闭-vs-优雅关闭" class="headerlink" title="粗暴关闭 vs 优雅关闭"></a>粗暴关闭 vs 优雅关闭</h4><p>前面介绍 TCP 四次挥手的时候，并没有详细介绍关闭连接的函数，其实关闭的连接的函数有两种函数：</p>
<ul>
<li><p>close 函数，同时 socket 关闭发送方向和读取方向，也就是 socket 不再有发送和接收数据的能力。如果有多进程&#x2F;多线程共享同一个 socket，如果有一个进程调用了 close 关闭只是让 socket 引用计数 -1，并不会导致 socket 不可用，同时也不会发出 FIN 报文，其他进程还是可以正常读写该 socket，直到引用计数变为 0，才会发出 FIN 报文。</p>
</li>
<li><p>shutdown 函数，可以指定 socket 只关闭发送方向而不关闭读取方向，也就是 socket 不再有发送数据的能力，但是还是具有接收数据的能力。如果有多进程&#x2F;多线程共享同一个 socket，shutdown 则不管引用计数，直接使得该 socket 不可用，然后发出 FIN 报文，如果有别的进程企图使用该 socket，将会受到影响。</p>
</li>
</ul>
<p>如果客户端是用 close 函数来关闭连接，那么在 TCP 四次挥手过程中，如果收到了服务端发送的数据，由于客户端已经不再具有发送和接收数据的能力，所以客户端的内核会回 RST 报文给服务端，然后内核会释放连接，这时就不会经历完成的 TCP 四次挥手，所以我们常说，调用 close 是粗暴的关闭。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqTKiaCezviad9jEJ6laX7YTvmNr0CNBAeFq1ibFtDo8daKnLoiaZf86QXdg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>当服务端收到 RST 后，内核就会释放连接，当服务端应用程序再次发起读操作或者写操作时，就能感知到连接已经被释放了：</p>
<ul>
<li><p>如果是读操作，则会返回 RST 的报错，也就是我们常见的Connection reset by peer。</p>
</li>
<li><p>如果是写操作，那么程序会产生 SIGPIPE 信号，应用层代码可以捕获并处理信号，如果不处理，则默认情况下进程会终止，异常退出。</p>
</li>
</ul>
<p>相对的，shutdown 函数因为可以指定只关闭发送方向而不关闭读取方向，所以即使在 TCP 四次挥手过程中，如果收到了服务端发送的数据，客户端也是可以正常读取到该数据的，然后就会经历完整的 TCP 四次挥手，所以我们常说，调用 shutdown 是优雅的关闭。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqjibEsjHAFttJCMw712anZwKVHb6YNvqNjib3Vy9pHQOmeibVYjDNfEnAw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>但是注意，shutdown 函数也可以指定「只关闭读取方向，而不关闭发送方向」，但是这时候内核是不会发送 FIN 报文的，因为发送 FIN 报文是意味着我方将不再发送任何数据，而 <strong>shutdown 如果指定「不关闭发送方向」，就意味着 socket 还有发送数据的能力，所以内核就不会发送 FIN</strong>。</p>
<h4 id="什么情况会出现三次挥手？"><a href="#什么情况会出现三次挥手？" class="headerlink" title="什么情况会出现三次挥手？"></a>什么情况会出现三次挥手？</h4><p>当被动关闭方（上图的服务端）在 TCP 挥手过程中，「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtq0WaxOzTFbA8SQ5Am8ibRL1JMdq5GibqVeXYWOXB3gtdHAMwic01mMAOSw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>然后因为 TCP 延迟确认机制是默认开启的，所以导致我们抓包时，看见三次挥手的次数比四次挥手还多。</p>
<blockquote>
<p>什么是  TCP 延迟确认机制？</p>
</blockquote>
<p>当发送没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文。</p>
<p>为了解决 ACK 传输效率低问题，所以就衍生出了 <strong>TCP 延迟确认</strong>。</p>
<p>TCP 延迟确认的策略：</p>
<ul>
<li><p>当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方</p>
</li>
<li><p>当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</p>
</li>
<li><p>如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK</p>
</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqoexLQeRzR1uwXIKrH3jJ9b0NNcrbxEKo7uvPp3eZLiafZkVfiaiaibVulg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>延迟等待的时间是在 Linux 内核中定义的，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqvkkq2d3h7qiaibwa8q3NghgrSVU48FFROd8ydmATAMAaMQpHiapicKTytw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>关键就需要 HZ 这个数值大小，HZ 是跟系统的时钟频率有关，每个操作系统都不一样，在我的 Linux 系统中 HZ 大小是 1000，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqJzGZ8BicbA81zRB4HzbGnFrxdC9tfsZSK1uj82ZPS52d74JTRMqG4Jg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>知道了 HZ 的大小，那么就可以算出：</p>
<ul>
<li><p>最大延迟确认时间是 200 ms （1000&#x2F;5）</p>
</li>
<li><p>最短延迟确认时间是 40 ms （1000&#x2F;25）</p>
</li>
</ul>
<blockquote>
<p>怎么关闭 TCP 延迟确认机制？</p>
</blockquote>
<p>如果要关闭 TCP 延迟确认机制，可以在 Socket 设置里启用 TCP_QUICKACK，启用 TCP_QUICKACK，就相当于关闭 TCP 延迟确认机制。</p>
<p>&#x2F;&#x2F; 1 表示开启 TCP_QUICKACK，即关闭 TCP 延迟确认机制<br>int value &#x3D; 1;<br>setsockopt(socketfd, IPPROTO_TCP, TCP_QUICKACK, (char*)&amp; value, sizeof(int));  </p>
<h4 id="实验验证"><a href="#实验验证" class="headerlink" title="实验验证"></a>实验验证</h4><h5 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h5><p>接下来，来给大家做个实验，验证这个结论：</p>
<blockquote>
<p>当被动关闭方（上图的服务端）在 TCP 挥手过程中，「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p>
</blockquote>
<p>服务端的代码如下，做的事情很简单，就读取数据，然后当 read 返回 0 的时候，就马上调用 close 关闭连接。因为 TCP 延迟确认机制是默认开启的，所以不需要特殊设置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;netdb.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;netinet/in.h&gt;  </span><br><span class="line">#include &lt;sys/socket.h&gt;  </span><br><span class="line">#include &lt;netinet/tcp.h&gt;  </span><br><span class="line">  </span><br><span class="line">#define MAXLINE 1024  </span><br><span class="line">  </span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line">    // 1. 创建一个监听 socket  </span><br><span class="line">    int listenfd = socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">    if(listenfd &lt; 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">        fprintf(stderr, &quot;socket error : %s\n&quot;, strerror(errno));  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 2. 初始化服务器地址和端口  </span><br><span class="line">    struct sockaddr_in server_addr;  </span><br><span class="line">    bzero(&amp;server_addr, sizeof(struct sockaddr_in));  </span><br><span class="line">    server_addr.sin_family = AF_INET;  </span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">    server_addr.sin_port = htons(8888);  </span><br><span class="line">  </span><br><span class="line">    // 3. 绑定地址+端口  </span><br><span class="line">    if(bind(listenfd, (struct sockaddr *)(&amp;server_addr), sizeof(struct sockaddr)) &lt; 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">        fprintf(stderr,&quot;bind error:%s\n&quot;, strerror(errno));  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;begin listen....\n&quot;);  </span><br><span class="line">  </span><br><span class="line">    // 4. 开始监听  </span><br><span class="line">    if(listen(listenfd, 128))  </span><br><span class="line">    &#123;  </span><br><span class="line">        fprintf(stderr, &quot;listen error:%s\n\a&quot;, strerror(errno));  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    // 5. 获取已连接的socket  </span><br><span class="line">    struct sockaddr_in client_addr;  </span><br><span class="line">    socklen_t client_addrlen = sizeof(client_addr);  </span><br><span class="line">    int clientfd = accept(listenfd, (struct sockaddr *)&amp;client_addr, &amp;client_addrlen);  </span><br><span class="line">    if(clientfd &lt; 0) &#123;  </span><br><span class="line">        fprintf(stderr, &quot;accept error:%s\n\a&quot;, strerror(errno));  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;accept success\n&quot;);  </span><br><span class="line">  </span><br><span class="line">    char message[MAXLINE] = &#123;0&#125;;  </span><br><span class="line">      </span><br><span class="line">    while(1) &#123;  </span><br><span class="line">        //6. 读取客户端发送的数据  </span><br><span class="line">        int n = read(clientfd, message, MAXLINE);  </span><br><span class="line">        if(n &lt; 0) &#123; // 读取错误  </span><br><span class="line">            fprintf(stderr, &quot;read error:%s\n\a&quot;, strerror(errno));  </span><br><span class="line">            break;  </span><br><span class="line">        &#125; else if(n == 0) &#123;  // 返回 0 ，代表读到 FIN 报文  </span><br><span class="line">            fprintf(stderr, &quot;client closed \n&quot;);  </span><br><span class="line">            close(clientfd); // 没有数据要发送，立马关闭连接  </span><br><span class="line">            break;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        message[n] = 0;   </span><br><span class="line">        printf(&quot;received %d bytes: %s\n&quot;, n, message);  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    close(listenfd);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<p>客户端代码如下，做的事情也很简单，与服务端连接成功后，就发送数据给服务端，然后睡眠一秒后，就调用 close 关闭连接，所以客户端是主动关闭方：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;netdb.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;netinet/in.h&gt;  </span><br><span class="line">#include &lt;sys/socket.h&gt;  </span><br><span class="line">  </span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line">    // 1. 创建一个监听 socket  </span><br><span class="line">    int connectfd = socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">    if(connectfd &lt; 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">        fprintf(stderr, &quot;socket error : %s\n&quot;, strerror(errno));  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 2. 初始化服务器地址和端口  </span><br><span class="line">    struct sockaddr_in server_addr;  </span><br><span class="line">    bzero(&amp;server_addr, sizeof(struct sockaddr_in));  </span><br><span class="line">    server_addr.sin_family = AF_INET;  </span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);  </span><br><span class="line">    server_addr.sin_port = htons(8888);  </span><br><span class="line">      </span><br><span class="line">    // 3. 连接服务器  </span><br><span class="line">    if(connect(connectfd, (struct sockaddr *)(&amp;server_addr), sizeof(server_addr)) &lt; 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">        fprintf(stderr,&quot;connect error:%s\n&quot;, strerror(errno));  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;connect success\n&quot;);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    char sendline[64] = &quot;hello, i am xiaolin&quot;;  </span><br><span class="line">  </span><br><span class="line">    //4. 发送数据  </span><br><span class="line">    int ret = send(connectfd, sendline, strlen(sendline), 0);  </span><br><span class="line">    if(ret != strlen(sendline)) &#123;  </span><br><span class="line">        fprintf(stderr,&quot;send data error:%s\n&quot;, strerror(errno));  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;already send %d bytes\n&quot;, ret);  </span><br><span class="line">  </span><br><span class="line">    sleep(1);  </span><br><span class="line">  </span><br><span class="line">    //5. 关闭连接  </span><br><span class="line">    close(connectfd);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>编译服务端和客户端的代码：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqXBTTjgQPl0KLGKMq7hAz9mod0RRYpjI9AXksu0CB1qmJDJN2aSMwPg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>先启用服务端：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqia1WLRBYhBiaU7XbDCHsGKWpIibs5WdibLJy6w0G9Oec7dqkw6cMpLKnoQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>然后用 tcpdump 工具开始抓包，命令如下：</p>
<p>tcpdump -i lo tcp and port 8888 -s0 -w &#x2F;home&#x2F;tcp_close.pcap  </p>
<p>然后启用客户端，可以看到，与服务端连接成功后，发完数据就退出了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqmnM7Byiagyo5RWxWm3LR58Zb4QdxDUQIJVa7S9GGfanHvlfTUzOBwKg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>此时，服务端的输出：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqSeF6vb50YiatBrEowxgAjYmgfy8liaL0TognAsrse1Dwm0u3GT7CENMw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>接下来，我们来看看抓包的结果。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtq48mB8VKryOjzdqyjjwy32kiakVBpvJPb1EdznqXfU2BicibY5mibccpbrA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>可以看到，TCP 挥手次数是 3 次。</p>
<p>所以，下面这个结论是没问题的。</p>
<blockquote>
<p>结论：当被动关闭方（上图的服务端）在 TCP 挥手过程中，「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制（默认会开启）」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p>
</blockquote>
<h5 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h5><p>我们再做一次实验，来看看<strong>关闭 TCP 延迟确认机制，会出现四次挥手吗？</strong></p>
<p>客户端代码保持不变，服务端代码需要增加一点东西。</p>
<p>在上面服务端代码中，增加了打开了 TCP_QUICKACK （快速应答）机制的代码，如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqS3Fia1ibn7iaKlicjzuPNeXibEPwKlzv9uJSsZ63RkzEOiadlLtMtic4loFXg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>编译好服务端代码后，就开始运行服务端和客户端的代码，同时用 tcpdump 进行抓包。</p>
<p>抓包的结果如下，可以看到是四次挥手。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqOQ7DhUPhZMcpfqkTHHh1XMUmic3od3mHibTwKTFgHhthltE0BxNdicAug/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>所以，当被动关闭方（上图的服务端）在 TCP 挥手过程中，「<strong>没有数据要发送」，同时「关闭了 TCP 延迟确认机制」，那么就会是四次挥手。</strong></p>
<blockquote>
<p>设置 TCP_QUICKACK 的代码，为什么要放在 read 返回 0 之后？</p>
</blockquote>
<p>我也是多次实验才发现，在 bind 之前设置 TCP_QUICKACK 是不生效的，只有在 read 返回 0 的时候，设置 TCP_QUICKACK 才会出现四次挥手。</p>
<p>网上查了下资料说，设置 TCP_QUICKACK 并不是永久的，所以每次读取数据的时候，如果想要立刻回 ACK，那就得在每次读取数据之后，重新设置 TCP_QUICKACK。</p>
<p>而我这里的实验，目的是为了当收到客户端的 FIN 报文（第一次挥手）后，立马回 ACK 报文，所以就在 read 返回 0 的时候，设置 TCP_QUICKACK。</p>
<p>当然，实际应用中，没人会在我这个位置设置 TCP_QUICKACK，因为操作系统都通过 TCP 延迟确认机制帮我们把四次挥手优化成了三次挥手了，这本来就是一件好事呀。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>当被动关闭方在 TCP 挥手过程中，如果「没有数据要发送」，同时「没有开启 TCP_QUICKACK（默认情况就是没有开启，没有开启 TCP_QUICKACK，等于就是在使用 TCP 延迟确认机制）」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</p>
<p><strong>所以，出现三次挥手现象，是因为 TCP 延迟确认机制导致的。</strong></p>
<h3 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h3><h3 id="TCP如何保证可靠性"><a href="#TCP如何保证可靠性" class="headerlink" title="TCP如何保证可靠性"></a>TCP如何保证可靠性</h3><h3 id="TCP-拆包沾包原因"><a href="#TCP-拆包沾包原因" class="headerlink" title="TCP 拆包沾包原因"></a>TCP 拆包沾包原因</h3><p>TCP 拆包和沾包现象是由于 TCP 协议的特性以及网络传输过程中的各种因素所导致的。<br>TCP 协议是基于字节流的传输层协议，没有固定的分包边界。发送方将数据分成多个小的数据包进行传输，接收方再将这些数据包组合成完整的数据。在这个过程中，可能会出现拆包和沾包现象。<br>网络传输中的延迟和拥塞会影响数据包发送的速度和到达接收方的顺序。这可能导致数据包的拆分和组合不规律，从而出现拆包和沾包现象。<br>接收方的缓冲区大小限制。当接收方的缓冲区不足以容纳一个完整的数据包时，可能会将数据包拆分成多个部分，导致拆包现象。<br>为了解决 TCP 拆包和沾包的问题，可以采用以下方法：<br>在应用层实现数据包的边界识别，例如通过添加包头，包头中包含数据包长度等信息，使得接收方能够准确地将数据包进行拼接。<br>使用固定长度的数据包或者特殊的分隔符，以便于接收方识别数据包的边界。<br>使用更高级的传输层协议，如 WebSocket，它在 TCP 基础上增加了数据帧的概念，可以更好地解决拆包和沾包问题。</p>
<h3 id="TCP粘包问题怎么解决"><a href="#TCP粘包问题怎么解决" class="headerlink" title="TCP粘包问题怎么解决"></a>TCP粘包问题怎么解决</h3><ul>
<li><p>答：特殊标记</p>
</li>
<li><p>追问：打断，如果使用特殊标记解决会遇到什么问题</p>
</li>
<li><p>答：正文转义字符</p>
</li>
</ul>
<p><strong>补充：</strong></p>
<p>1、固定长度的消息</p>
<p>这种是最简单方法，即每个用户消息都是固定长度的，比如规定一个消息的长度是 64 个字节，当接收方接满 64 个字节，就认为这个内容是一个完整且有效的消息。</p>
<p>但是这种方式灵活性不高，实际中很少用。</p>
<p>2、特殊字符作为边界</p>
<p>我们可以在两个用户消息之间插入一个特殊的字符串，这样接收方在接收数据时，读到了这个特殊字符，就把认为已经读完一个完整的消息。</p>
<p>HTTP 是一个非常好的例子。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeAuWVqVBTyJ8LzTIjpaUQ9QzbZBW2SaM2whfW9cXicKVPEw0Md73ibUf4BF1nOSqRW3dvpUA0e2oOQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>图片</p>
<p>HTTP 通过设置回车符、换行符作为 HTTP 报文协议的边界。</p>
<p>有一点要注意，这个作为边界点的特殊字符，如果刚好消息内容里有这个特殊字符，我们要对这个字符转义，避免被接收方当作消息的边界点而解析到无效的数据。</p>
<p>3、自定义消息结构</p>
<p>我们可以自定义一个消息结构，由包头和数据组成，其中包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大。</p>
<p>比如这个消息结构体，首先 4 个字节大小的变量来表示数据长度，真正的数据则在后面。</p>
<p><code>struct &#123;        u_int32_t message_length;        char message_data[];    &#125; message;   </code></p>
<p>当接收方接收到包头的大小（比如 4 个字节）后，就解析包头的内容，于是就可以知道数据的长度，然后接下来就继续读取数据，直到读满数据的长度，就可以组装成一个完整到用户消息来处理了。</p>
<h3 id="输入网址后发生了什么？"><a href="#输入网址后发生了什么？" class="headerlink" title="输入网址后发生了什么？"></a>输入网址后发生了什么？</h3><p>应用层 DNS 解析，传输层 TCP 连接，网络层 IP，数据链路 MAC，真实物理层，接收到之后再一层层扒皮。</p>
<h3 id="http报文长度判断"><a href="#http报文长度判断" class="headerlink" title="http报文长度判断"></a>http报文长度判断</h3><h3 id="udp为啥不可靠性。"><a href="#udp为啥不可靠性。" class="headerlink" title="udp为啥不可靠性。"></a>udp为啥不可靠性。</h3><h3 id="服务端挂了，客户端的-TCP-连接会发生什么？"><a href="#服务端挂了，客户端的-TCP-连接会发生什么？" class="headerlink" title="服务端挂了，客户端的 TCP 连接会发生什么？"></a>服务端挂了，客户端的 TCP 连接会发生什么？</h3><p>如果「服务端挂掉」指的是「<strong>服务端进程崩溃</strong>」，那么这个读者猜的想法是对的，服务端的进程在发生崩溃的时候，内核会发送 FIN 报文，与客户端进行四次挥手。</p>
<p>但是，如果「服务端挂掉」指的是「<strong>服务端主机宕机</strong>」，那么是不会发生四次挥手的，具体后续会发生什么？还要看客户端会不会发送数据？</p>
<ul>
<li><p>如果客户端会发送数据，由于服务端已经不存在，客户端的数据报文会超时重传，当重传次数达到一定阈值后，会断开 TCP 连接；</p>
</li>
<li><p>如果客户端一直不会发送数据，再看客户端有没有开启 TCP keepalive 机制？</p>
</li>
<li><p>如果有开启，客户端在一段时间后，检测到服务端的 TCP 连接已经不存在，则会断开自身的 TCP 连接；</p>
</li>
<li><p>如果没有开启，客户端的 TCP 连接会一直存在，并不会断开。</p>
</li>
</ul>
<h3 id="详细介绍一下TCP的四次挥手机制，为什么要有TIME-WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE-WAIT状态如何解决"><a href="#详细介绍一下TCP的四次挥手机制，为什么要有TIME-WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE-WAIT状态如何解决" class="headerlink" title="详细介绍一下TCP的四次挥手机制，为什么要有TIME_WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE_WAIT状态如何解决"></a>详细介绍一下TCP的四次挥手机制，为什么要有TIME_WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE_WAIT状态如何解决</h3><p>当客户端要服务器断开连接时，客户端 TCP 会向服务器发送一个特殊的报文段，该报文段的 FIN 标志位会被置1，接着服务器会向客户端发送一个确认报文段。然后服务器也会客户端发送一个 FIN 标志位为1的终止报文段，随后客户端回送一个确认报文段，服务器立即断开连接。客户端等待一段时间后也断开连接。</p>
<p>其实四次挥手的过程是很容易理解的，由于 TCP 协议是全双工的，也就是说客户端和服务端都可以发起断开连接。两边各发起一次断开连接的申请，加上各自的两次确认，看起来就像执行了四次挥手。</p>
<p>为什么要有 TIME_WAIT 状态？因为客户端最后向服务器发送的确认 ACK 是有可能丢失的，当出现超时，服务端会再次发送 FIN 报文段，如果客户端已经关闭了就收不到了。还有一点是避免新旧连接混杂。</p>
<p>大量 CLOSE_WAIT 表示程序出现了问题，对方的 socket 已经关闭连接，而我方忙于读或写没有及时关闭连接，需要检查代码，特别是释放资源的代码，或者是处理请求的线程配置</p>
<p>\3. TIME_WAIT状态<br>    经过前面的铺垫，终于要讲到与本文主题相关的内容了。 ^_^<br>    从TCP状态迁移图可知，只有首先调用close()发起主动关闭的一方才会进入TIME_WAIT状态，而且是必须进入（图中左下角所示的3条状态迁移线最终均要进入该状态才能回到初始的CLOSED状态）。<br>    从图中还可看到，进入TIME_WAIT状态的TCP连接需要经过2MSL才能回到初始状态，其中，MSL是指Max<br>Segment Lifetime，即数据包在网络中的最大生存时间。每种TCP协议的实现方法均要指定一个合适的MSL值，如RFC1122给出的建议值为2分钟，又如Berkeley体系的TCP实现通常选择30秒作为MSL值。这意味着TIME_WAIT的典型持续时间为1-4分钟。<br>    TIME_WAIT状态存在的原因主要有两点：<br>    1）为实现TCP这种全双工（full-duplex）连接的可靠释放<br>    参考本文前面给出的TCP释放连接4次挥手示意图，假设发起active close的一方（图中为client）发送的ACK（4次交互的最后一个包）在网络中丢失，那么由于TCP的重传机制，执行passiveclose的一方（图中为server）需要重发其FIN，在该FIN到达client（client是active close发起方）之前，client必须维护这条连接的状态（尽管它已调用过close），具体而言，就是这条TCP连接对应的（local_ip, local_port）资源不能被立即释放或重新分配。直到romete peer重发的FIN达到，client也重发ACK后，该TCP连接才能恢复初始的CLOSED状态。如果activeclose方不进入TIME_WAIT以维护其连接状态，则当passive close方重发的FIN达到时，active close方的TCP传输层会以RST包响应对方，这会被对方认为有错误发生（而事实上，这是正常的关闭连接过程，并非异常）。<br>    2）为使旧的数据包在网络因过期而消失<br>    为说明这个问题，我们先假设TCP协议中不存在TIME_WAIT状态的限制，再假设当前有一条TCP连接：(local_ip, local_port, remote_ip,remote_port)，因某些原因，我们先关闭，接着很快以相同的四元组建立一条新连接。本文前面介绍过，TCP连接由四元组唯一标识，因此，在我们假设的情况中，TCP协议栈是无法区分前后两条TCP连接的不同的，在它看来，这根本就是同一条连接，中间先释放再建立的过程对其来说是“感知”不到的。这样就可能发生这样的情况：前一条TCP连接由local peer发送的数据到达remote peer后，会被该remot peer的TCP传输层当做当前TCP连接的正常数据接收并向上传递至应用层（而事实上，在我们假设的场景下，这些旧数据到达remote peer前，旧连接已断开且一条由相同四元组构成的新TCP连接已建立，因此，这些旧数据是不应该被向上传递至应用层的），从而引起数据错乱进而导致各种无法预知的诡异现象。作为一种可靠的传输协议，TCP必须在协议层面考虑并避免这种情况的发生，这正是TIME_WAIT状态存在的第2个原因。<br>    具体而言，local peer主动调用close后，此时的TCP连接进入TIME_WAIT状态，处于该状态下的TCP连接不能立即以同样的四元组建立新连接，即发起active close的那方占用的local port在TIME_WAIT期间不能再被重新分配。由于TIME_WAIT状态持续时间为2MSL，这样保证了旧TCP连接双工链路中的旧数据包均因过期（超过MSL）而消失，此后，就可以用相同的四元组建立一条新连接而不会发生前后两次连接数据错乱的情况。</p>
<p>另一比较深入的说法</p>
<p>TIME_WAIT状态的存在有两个理由：（1）让4次握手关闭流程更加可靠；4次握手的最后一个ACK是是由主动关闭方发送出去的，若这个ACK丢失，被动关闭方会再次发一个FIN过来。若主动关闭方能够保持一个2MSL的TIME_WAIT状态，则有更大的机会让丢失的ACK被再次发送出去。（2）防止lost duplicate对后续新建正常链接的传输造成破坏。lost duplicate在实际的网络中非常常见，经常是由于路由器产生故障，路径无法收敛，导致一个packet在路由器A，B，C之间做类似死循环的跳转。IP头部有个TTL，限制了一个包在网络中的最大跳数，因此这个包有两种命运，要么最后TTL变为0，在网络中消失；要么TTL在变为0之前路由器路径收敛，它凭借剩余的TTL跳数终于到达目的地。但非常可惜的是TCP通过超时重传机制在早些时候发送了一个跟它一模一样的包，并先于它达到了目的地，因此它的命运也就注定被TCP协议栈抛弃。另外一个概念叫做incarnation connection，指跟上次的socket pair一摸一样的新连接，叫做incarnation of previous connection。lost duplicate加上incarnation connection，则会对我们的传输造成致命的错误。大家都知道TCP是流式的，所有包到达的顺序是不一致的，依靠序列号由TCP协议栈做顺序的拼接；假设一个incarnation connection这时收到的seq&#x3D;1000, 来了一个lost duplicate为seq&#x3D;1000, len&#x3D;1000, 则tcp认为这个lost duplicate合法，并存放入了receive buffer，导致传输出现错误。通过一个2MSL TIME_WAIT状态，确保所有的lost duplicate都会消失掉，避免对新连接造成错误。</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>从上面的图可以看到滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。</p>
<p>可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。</p>
<p>接着就讲讲什么是流量控制窗口，什么是拥塞控制窗口。</p>
<p>先讲流量控制：</p>
<p>TCP 是全双工的，客户端和服务器均可作为发送方或接收方，我们现在假设一个发送方向接收方发送数据的场景来讲解流量控制。首先我们的接收方有一块接收缓存，当数据来到时会先把数据放到缓存中，上层应用等缓存中有数据时就会到缓存中取数据。假如发送方没有限制地不断地向接收方发送数据，接收方的应用程序又没有及时把接收缓存中的数据读走，就会出现缓存溢出，数据丢失的现象，为了解决这个问题，我们引入流量控制窗口。</p>
<p>假设应用程序最后读走的数据序号是 lastByteRead，接收缓存中接收到的最后一个数据序号是 lastByteRcv，接收缓存的大小为 RcvSize，那么必须要满足 lastByteRcv - lastByteRead &lt;&#x3D; RcvSize 才能保证接收缓存不会溢出，所以我们定义流量窗口为接收缓存剩余的空间，也就是Rcv &#x3D; RcvSize - (lastByteRcv - lastByteRead)。只要接收方在响应 ACK 的时候把这个窗口的值带给发送方，发送方就能知道接收方的接收缓存还有多大的空间，进而设置滑动窗口的大小。</p>
<p>接着讲解拥塞控制：</p>
<p>拥塞控制是指发送方先设置一个小的窗口值作为发送速率，当成功发包并接收到ACK时，便以指数速率增大发送窗口的大小，直到遇到丢包（超时&#x2F;三个冗余ACK），才停止并调整窗口的大小。这么做能最大限度地利用带宽，又不至于让网络环境变得太过拥挤。</p>
<p>最终滑动窗口的值将设置为流量控制窗口和拥塞控制窗口中的较小值。</p>
<p>Q: 编写 TCP&#x2F;SOCK_STREAM 服务程序时，SO_REUSEADDR到底什么意思？</p>
<p>A: 这个套接字选项通知内核，如果端口忙，但TCP状态位于 TIME_WAIT ，可以重用端口。如果端口忙，而TCP状态位于其他状态，重用端口时依旧得到一个错误信息， 指明”地址已经使用中”。如果你的服务程序停止后想立即重启，而新套接字依旧 使用同一端口，此时 SO_REUSEADDR 选项非常有用。必须意识到，此时任何非期 望数据到达，都可能导致服务程序反应混乱，不过这只是一种可能，事实上很不可能。</p>
<p>　CLOSE_WAIT： 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。</p>
<h3 id="UDP客户端可以CONNECT不，那CONNECT和不CONNECT有啥区别"><a href="#UDP客户端可以CONNECT不，那CONNECT和不CONNECT有啥区别" class="headerlink" title="UDP客户端可以CONNECT不，那CONNECT和不CONNECT有啥区别"></a>UDP客户端可以CONNECT不，那CONNECT和不CONNECT有啥区别</h3><p>在UDP协议中，没有真正的连接（connection）的概念，因此UDP客户端不能像TCP客户端那样通过<code>connect()</code>函数来建立连接。</p>
<p>使用<code>connect()</code>函数的主要目的是为了简化代码和提高安全性。当TCP客户端调用<code>connect()</code>函数时，操作系统会自动为其分配一个socket文件描述符，并将该socket与远程服务器的IP地址和端口号绑定起来。这样，在之后的数据通信中，客户端只需要向该socket发送数据即可，而不必每次都指定远程服务器的IP地址和端口号。另外，<code>connect()</code>函数还可以对发送的数据进行一些验证和过滤，以提高数据传输的安全性。</p>
<p>在UDP协议中，由于不存在真正的连接，因此也就不需要使用<code>connect()</code>函数来建立连接。UDP客户端每次发送数据时，都需要指定远程服务器的IP地址和端口号，这样才能确保数据能够正确地被发送到目标地址。因此，在UDP协议中，没有<code>connect()</code>函数的概念。</p>
<p>总之，UDP客户端没有连接（connection）的概念，因此不能像TCP客户端那样使用<code>connect()</code>函数来建立连接。每次发送数据时，UDP客户端需要显式地指定远程服务器的IP地址和端口号。如果需要简化代码和提高安全性，可以使用其他技术手段，例如使用加密算法和数字证书来保证数据传输的安全性。</p>
<h3 id="5-讲一下HTTP与HTTPS的区别"><a href="#5-讲一下HTTP与HTTPS的区别" class="headerlink" title="5. 讲一下HTTP与HTTPS的区别"></a>5. 讲一下HTTP与HTTPS的区别</h3><p>HTTP和HTTPS的主要区别在于HTTP协议传递的是明文数据，而HTTPS传递的是加密过的数据，也就是说HTTPS更具有安全性。也正由HTTPS需要保证安全性，所以它的性能要比HTTP差一点。</p>
<p>单说安全性肯定是不够的，我打算扩展讲一下HTTPS是怎么解决安全性问题的，通过这些HTTP没有机制，反映出HTTPS与HTTP的区别。下面尝试把HTTPS加密的过程推导出来。推导过程不涉及复杂的实现细节：</p>
<h4 id="如何安全地进行数据传输？"><a href="#如何安全地进行数据传输？" class="headerlink" title="如何安全地进行数据传输？"></a>如何安全地进行数据传输？</h4><p>假设现在A和B要进行安全的通信，那么究竟怎样才算是安全的通信？很自然地会想到：A和B之间传递数据，这些数据只有A和B才看得懂，中间人就算截取了信息但也看不懂，这才算得上安全。</p>
<h4 id="安全通信的处理手段："><a href="#安全通信的处理手段：" class="headerlink" title="安全通信的处理手段："></a>安全通信的处理手段：</h4><p>为了能让A和B才能看懂，就必须要对数据进行加密，而且首先想到的就是对称加密。对称加密的意思是A和B各持有一个相同的密钥，它们传递信息时会用密钥给信息加密，在消息到达端给消息解密，完成安全通信。</p>
<p>在对称加密中又会涉及到加密算法的选择问题。现实世界中，通常是多个客户端面向一个服务器的情况，不可能让每个客户端和服务器之间都采用相同的加密算法，如果是这样那和没加密差不多。所以注定每个客户端和服务器之间都会采用不同的加密方式。</p>
<h4 id="如何让每个客户端与服务器之间都采用不同的加密方式？"><a href="#如何让每个客户端与服务器之间都采用不同的加密方式？" class="headerlink" title="如何让每个客户端与服务器之间都采用不同的加密方式？"></a>如何让每个客户端与服务器之间都采用不同的加密方式？</h4><p>要想对不同的机器使用不同的加密方式，最直接想到的就是使用随机数。也就说客户端和服务器之间每次都基于一个随机数产生加密算法。（具体实现时为了保证随机，用到还不止一个随机数）</p>
<p>这个产生加密算法的过程称之为协商，现在问题是协商的过程是透明的，也就是说中间人可以截获协商的过程，从而知道我们的加密方式。为了解决这个问题，我们需要对协商的过程进行加密。</p>
<h4 id="如何对协商的过程进行加密？"><a href="#如何对协商的过程进行加密？" class="headerlink" title="如何对协商的过程进行加密？"></a>如何对协商的过程进行加密？</h4><p>之所以能来到这一步，是因为我们一开始就选择使用了对称加密，也就说一开始的对称加密导致了现在的问题，所以这时我们不能再使用对称加密了，否则会陷入死循环。</p>
<p>在密码学领域，还有一种加密过程叫非对称加密，它的逻辑是这样的：通信双方一方持有私钥，一方持有公钥，经过私钥加密的信息，都能通过公钥进行解密。但是经过公钥加密的数据，只有私钥可以解密。</p>
<p>按照非对称加密的规则，我们让服务器持有私钥，让客户端持有公钥。这样就能保证客户端给服务器发送消息的时候是安全的（相反，服务器给客户端发送消息就是不安全的），我们可以把协商时重要的逻辑安排在客户端给服务器发送信息的过程中，从而保证了协商过程的安全性。</p>
<h4 id="客户端如何获得公钥？"><a href="#客户端如何获得公钥？" class="headerlink" title="客户端如何获得公钥？"></a>客户端如何获得公钥？</h4><p>现在用非对称加密算法解决了协商的安全问题，但是非对称加密的前提是客户端需要获得公钥，这又是一个问题了，客户端与服务器打交道之前是互不知道双方身份的，怎么才能让客户端获得公钥呢？</p>
<p>也就只有两种办法：</p>
<ol>
<li>客户端向服务器要公钥</li>
<li>客户端向一个远程的公共服务器获取公钥</li>
</ol>
<p>方法2显然是不行的，尚且不说多了一个访问节点，如何找到公共服务器的地址也是一个待解决的问题，所以还是使用方法1。</p>
<p>但是方法1存在一个问题：如果中间人把服务器发送给客户端的公钥调包了怎么办？也就是说客户端无法知道发送公钥的是否是正真的服务器。</p>
<h4 id="引入第三方机构解决问题"><a href="#引入第三方机构解决问题" class="headerlink" title="引入第三方机构解决问题"></a>引入第三方机构解决问题</h4><p>客户端无法辨识服务端和中间人的问题称为“身份验证”问题，也就是说我们需要为服务器向客户端发送公钥的过程进行加密。</p>
<p>这下完了，之前我们因遇到对称加密的瓶颈选择了非对称加密，现在使用非对称加密也遇到了瓶颈。显然这两种加密方式都是不可用的了，否则会再次陷入死循环。</p>
<p>接下来我们只好通过第三方机构的介入，解决这个问题。首先我们自己保存有第三方权威机构的公钥，然后第三方机构使用私钥对服务器将要发送给客户端的公钥进行加密，客户端接收到这个经加密的公钥后（数字证书），就能通过自己保存的第三方机构公钥进行解密。</p>
<blockquote>
<p>到这里为止，我们解释了HTTPS中使用到的对称加密，非对称加密，CA，数字证书的概念，但是还差一个叫数字签名的概念没有解释。</p>
</blockquote>
<p>在现实生活中，CA不单止会给我们正常公司发放证书，还会给中间人的坏公司发放证书，如果中间人把发放的证书调包了怎么办？这时我们仍能用CA的私钥进行解密，但是证书已经被调包了。</p>
<p>那么客户端怎样验证证书的真伪呢？答案是证书本身会告诉客户端如何辨认真伪。比方说证书上面有一个证书编号，还有一个如何计算证书编号的方法，客户端可以根据计算证书编号的方法计算出自己要获得的证书的编号，然后把这个编号和证书上的编号进行比对，如果一样证明没有被调包。</p>
<p>这里的证书编号指的就是数字签名，证书指的就是数字证书。</p>
<p>总结一下HTTPS：HTTPS想要保证客户端与服务器之间的通信安全，就得使用对称加密算法进行加密。协商对称加密算法的过程通过非对称加密算法来保证。在非对称加密算法中，客户端获得公钥的过程需要第三方机构（CA）通过颁发数字证书保证安全性。</p>
<p>总得来说通过这一系列机制协商出了一个对称加密算法后，客户端与服务器之间就能通过该算法进行安全的通信了</p>
<ul>
<li><p>TCP消息和UDP的主要区别</p>
</li>
<li><p>Epoll比起select&#x2F;poll，主要优化点在哪里？</p>
</li>
<li><p>Post和Get有什么区别？</p>
</li>
<li><p>接收时，如何确定一个HTTP消息已经读取完毕</p>
</li>
<li><p>从一个命令行下载一个网页，会涉及哪些网络协议？（DNS，TCP，HTTP，如果有ARP和SSL更好）</p>
</li>
<li><p>HTTP&#x2F;2主要优化点</p>
</li>
<li><p>\1. C++中具体是怎么实现多态的？构造函数可以是虚函数吗？构造函数可以调用虚函数吗？<br>编译器发现一个类中有虚函数，便会立即为此类生成虚函数表 vtable。虚函数表的各表项为指向对应虚函数的指针。<br>构造函数不可以是虚函数，也不能调用虚函数，因为此时虚函数表还未生成。</p>
<p>\2. 操作系统中进程、线程的区别，进程间通信通信的方式？<br>进程： 进程是资源（CPU、内存等）分配的基本单位，具有一定功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。<br>线程：线程是进程的一个实体，是独立运行和独立调度的基本单位（CPU上真正运行的是线程）。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。<br>进程通信的方式：管道，有名管道，信号量，消息队列，信号,共享内存,套接字.</p>
<p>\3. python中的多线程能充分利用多核CPU吗？如果要充分利用的话应该怎么做？<br>python的多线程不能充分利用多CPU，因为python解释器有一个全局锁；<br>要想利用多CPU只能使用多进程模型，或者使用C++</p>
<p>\4. http属于OSI分层协议中的哪一层？TCP&#x2F;UDP是属于哪一层？TCP的三次握手的过程是怎样的？为什么要有三次握手？<br>http属于应用层，TCP&#x2F;UDP属于传输层；</p>
<p>假设 A 为客户端，B 为服务器端。</p>
<p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p>
<p>A 向 B 发送连接请求报文，SYN&#x3D;1，ACK&#x3D;0，选择一个初始的序号 x。</p>
<p>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN&#x3D;1，ACK&#x3D;1，确认号为 x+1，同时也选择一个初始的序号 y。</p>
<p>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</p>
<p>B 收到 A 的确认后，连接建立。</p>
<p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p>
<p>\5. TCP怎么实现可靠传输的？</p>
<p>TCP滑动窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。<br>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。<br>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p>
</li>
</ul>
<h3 id="不同地区的用户的请求怎么打到附近的地区呢？"><a href="#不同地区的用户的请求怎么打到附近的地区呢？" class="headerlink" title="不同地区的用户的请求怎么打到附近的地区呢？"></a>不同地区的用户的请求怎么打到附近的地区呢？</h3><p>答：讲了CDN</p>
<p><strong>补充：</strong></p>
<p>CDN 将内容资源分发到位于多个地理位置机房中的服务器上，这样我们在访问内容资源的时候，不用访问源服务器。而是直接访问离我们最近的 CDN 节点 ，这样一来就省去了长途跋涉的时间成本，从而实现了网络加速。</p>
<p>找到离用户最近的 CDN 节点是由 CDN 的<strong>全局负载均衡器（<em>Global Sever Load Balance，GSLB</em>）</strong>负责的。</p>
<p>那 GSLB 是在什么时候起作用的呢？在回答这个问题前，我们先来看看在没有 CDN 的情况下，访问域名时发生的事情。</p>
<p>在没有 CDN 的情况下，当我们访问域名时，DNS 服务器最终会返回源服务器的地址。</p>
<p>比如，当我们在浏览器输入 <a target="_blank" rel="noopener" href="http://www.xiaolin.com/">www.xiaolin.com</a> 域名后，在本地 host 文件找不到域名时，客户端就会访问本地 DNS 服务器。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfg8KBLwPAE6ktepRPahjT7TyX6BwTp8IcDsOAkGvvWiaUcg2dQZc3ExHZyHr2ngzib5HfeMqvHN35g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>图片</p>
<p>这时候:</p>
<ul>
<li><p>如果本地 DNS 服务器有缓存该网站的地址，则直接返回网站的地址；</p>
</li>
<li><p>如果没有就通过递归查询的方式，先请求根 DNS，根 DNS 返回顶级 DNS（.com）的地址；再请求 .com 顶级 DNS 得到 xiaolin.com 的域名服务器地址，再从 xiaolin.com 的域名服务器中查询到 <a target="_blank" rel="noopener" href="http://www.xiaolin.com/">www.xiaolin.com</a> 对应的 IP 地址，然后返回这个 IP 地址，同时本地 DNS 缓存该 IP 地址，这样下一次的解析同一个域名就不需要做 DNS 的迭代查询了。</p>
</li>
</ul>
<p><strong>但加入 CDN 后就不一样了</strong>。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfg8KBLwPAE6ktepRPahjT7Ve7FiaAianuWiaZic1anXPYAST8dccKtcwJ5uzia8ZqicxiciaWfGOlgyDpVWg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>图片</p>
<p>会在 xiaolin.com 这个 DNS 服务器上，设置一个 CNAME 别名，指向另外一个域名 <a target="_blank" rel="noopener" href="http://www.xiaolin.cdn.com,返回给本地/">www.xiaolin.cdn.com，返回给本地</a> DNS 服务器。</p>
<p>接着继续解析该域名，这个时候访问的就是 xiaolin.cdn.com 这台 CDN 专用的 DNS 服务器，在这个服务器上，又会设置一个 CNAME，指向另外一个域名，这次指向的就是 CDN 的 GSLB。</p>
<p>接着，本地 DNS 服务器去请求 CDN 的 GSLB 的域名，GSLB 就会为用户选择一台合适的 CDN 节点提供服务，选择的依据主要有以下几点：</p>
<ul>
<li><p>看用户的 IP 地址，查表得知地理位置，找相对最近的 CDN 节点；</p>
</li>
<li><p>看用户所在的运营商网络，找相同网络的 CDN 节点；</p>
</li>
<li><p>看用户请求 URL，判断哪一台服务器上有用户所请求的资源；</p>
</li>
<li><p>查询 CDN 节点的负载情况，找负载较轻的节点；</p>
</li>
</ul>
<p>GSLB 会基于以上的条件进行综合分析后，找出一台最合适的 CDN 节点，并返回该 CDN 节点的 IP 地址给本地 DNS 服务器，然后本地 DNS 服务器缓存该 IP 地址，并将 IP 返回给客户端，客户端去访问这个 CDN 节点，下载资源。</p>
<h3 id="TCP的close-wait在哪端，如果我们场景中出现了大量的close-wait，你觉得要怎么排查"><a href="#TCP的close-wait在哪端，如果我们场景中出现了大量的close-wait，你觉得要怎么排查" class="headerlink" title="TCP的close_wait在哪端，如果我们场景中出现了大量的close_wait，你觉得要怎么排查"></a>TCP的close_wait在哪端，如果我们场景中出现了大量的close_wait，你觉得要怎么排查</h3><p>答：被动方，代码逻辑有问题，没close</p>
<p><strong>补充：</strong></p>
<p>CLOSE_WAIT 状态是「被动关闭方」才会有的状态，而且如果「被动关闭方」没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态。</p>
<p>所以，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接</strong>。</p>
<p>那什么情况会导致服务端的程序没有调用 close 函数关闭连接？这时候通常需要排查代码。</p>
<p>我们先来分析一个普通的 TCP 服务端的流程：</p>
<ol>
<li><p>创建服务端 socket，bind 绑定端口、listen 监听端口</p>
</li>
<li><p>将服务端 socket 注册到 epoll</p>
</li>
<li><p>epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket</p>
</li>
<li><p>将已连接的 socket 注册到 epoll</p>
</li>
<li><p>epoll_wait 等待事件发生</p>
</li>
<li><p>对方连接关闭时，我方调用 close</p>
</li>
</ol>
<p>可能导致服务端没有调用 close 函数的原因，如下。</p>
<p><strong>第一个原因</strong>：第 2 步没有做，没有将服务端 socket 注册到 epoll，这样有新连接到来时，服务端没办法感知这个事件，也就无法获取到已连接的 socket，那服务端自然就没机会对 socket 调用 close 函数了。</p>
<p>不过这种原因发生的概率比较小，这种属于明显的代码逻辑 bug，在前期 read view 阶段就能发现的了。</p>
<p><strong>第二个原因</strong>：第 3 步没有做，有新连接到来时没有调用 accpet 获取该连接的 socket，导致当有大量的客户端主动断开了连接，而服务端没机会对这些 socket 调用 close 函数，从而导致服务端出现大量 CLOSE_WAIT 状态的连接。</p>
<p>发生这种情况可能是因为服务端在执行 accpet 函数之前，代码卡在某一个逻辑或者提前抛出了异常。</p>
<p><strong>第三个原因</strong>：第 4 步没有做，通过 accpet 获取已连接的 socket 后，没有将其注册到 epoll，导致后续收到 FIN 报文的时候，服务端没办法感知这个事件，那服务端就没机会调用 close 函数了。</p>
<p>发生这种情况可能是因为服务端在将已连接的 socket 注册到 epoll 之前，代码卡在某一个逻辑或者提前抛出了异常。之前看到过别人解决 close_wait 问题的实践文章，感兴趣的可以看看：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU3Njk0MTc3Ng==&mid=2247486020&idx=1&sn=f7cf41aec28e2e10a46228a64b1c0a5c&scene=21#wechat_redirect">一次 Netty 代码不健壮导致的大量 CLOSE_WAIT 连接原因分析</a></p>
<p><strong>第四个原因</strong>：第 6 步没有做，当发现客户端关闭连接后，服务端没有执行 close 函数，可能是因为代码漏处理，或者是在执行 close 函数之前，代码卡在某一个逻辑，比如发生死锁等等。</p>
<p>可以发现，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，通常都是代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用 close</strong>。</p>
<h3 id="服务端出现大量-TIME-WAIT-状态的原因有哪些？"><a href="#服务端出现大量-TIME-WAIT-状态的原因有哪些？" class="headerlink" title="服务端出现大量 TIME_WAIT 状态的原因有哪些？"></a>服务端出现大量 TIME_WAIT 状态的原因有哪些？</h3><p>我们先来看一下 TCP 四次挥手的流程吧，看看 TIME_WAIT 状态发生在哪一个阶段。</p>
<p>下面这个图，是由「客户端」作为「主动关闭方」的 TCP 四次挥手的流程。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdWrrgBYLP5VsrraBM1qVuzgibl5CZs9FKwxdu2j2In9NPx4W5wC2e91AjbyLlwL7jvEY5NNjuRr5Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>TCP 四次挥手的流程</p>
<p>从上面我们可以知道，<strong>TIME_WAIT 状态是「主动关闭连接方」才会出现的状态</strong>。而且 TIME_WAIT 状态会持续 2MSL 时间才会进入到 close 状态。在 Linux 上 2MSL 的时长是 60 秒，也就是说<strong>停留在 TIME_WAIT 的时间为固定的 60 秒</strong>。</p>
<p>为什么需要 TIME_WAIT 状态？（老八股文了，帮大家复习一波）主要有两个原因：</p>
<ul>
<li><p><strong>保证「被动关闭连接」的一方，能被正确的关闭</strong>。TCP 协议在关闭连接的四次挥手中，在主动关闭方发送的最后一个 ACK 报文，有可能丢失，这时被动方会重新发 FIN 报文, 如果这时主动方处于 CLOSE 状态 ，就会响应 RST 报文而不是 ACK 报文。所以主动方要处于 TIME_WAIT 状态，而不能是 CLOSE。</p>
</li>
<li><p><strong>防止历史连接中的数据，被后面相同四元组的连接错误的接收</strong>。TCP 报文可能由于路由器异常而 “迷路”，在迷途期间，TCP 发送端可能因确认超时而重发这个报文，迷途的报文在路由器修复后也会被送到最终目的地，这个原来的迷途报文就称为 lost duplicate。在关闭一个 TCP 连接后，马上又重新建立起一个相同的 IP 地址和端口之间的 TCP 连接，后一个连接被称为前一个连接的化身，那么有可能出现这种情况，前一个连接的迷途重复报文在前一个连接终止后出现，从而被误解成从属于新的化身。为了避免这个情 况， TIME_WAIT 状态需要持续 2MSL，因为这样就可以保证当成功建立一个 TCP 连接的时候，来自连接先前化身的重复报文已经在网络中消逝。</p>
</li>
</ul>
<p>很多人误解以为只有客户端才会有 TIME_WAIT 状态，这是不对的。TCP 是全双工协议，哪一方都可以先关闭连接，所以哪一方都可能会有 TIME_WAIT 状态。</p>
<p>总之记住，<strong>谁先关闭连接的，它就是主动关闭方，那么 TIME_WAIT 就会出现在主动关闭方</strong>。</p>
<h4 id="什么场景下服务端会主动断开连接呢？"><a href="#什么场景下服务端会主动断开连接呢？" class="headerlink" title="什么场景下服务端会主动断开连接呢？"></a>什么场景下服务端会主动断开连接呢？</h4><p>如果服务端出现大量的 TIME_WAIT 状态的 TCP 连接，就是<strong>说明服务端主动断开了很多 TCP 连接</strong>。</p>
<p>问题来了，<strong>什么场景下服务端会主动断开连接呢？</strong></p>
<ul>
<li><p>第一个场景：HTTP 没有使用长连接</p>
</li>
<li><p>第二个场景：HTTP 长连接超时</p>
</li>
<li><p>第三个场景：HTTP 长连接的请求数量达到上限</p>
</li>
</ul>
<p>接下来，分别介绍下。</p>
<h5 id="第一个场景：HTTP-没有使用长连接"><a href="#第一个场景：HTTP-没有使用长连接" class="headerlink" title="第一个场景：HTTP 没有使用长连接"></a>第一个场景：HTTP 没有使用长连接</h5><p>我们先来看看 HTTP 长连接（Keep-Alive）机制是怎么开启的。</p>
<p>在 HTTP&#x2F;1.0 中默认是关闭的，如果浏览器要开启 Keep-Alive，它必须在请求的 header 中添加：</p>
<p><code>Connection: Keep-Alive   </code></p>
<p>然后当服务器收到请求，作出回应的时候，它也被添加到响应中 header 里：</p>
<p><code>Connection: Keep-Alive   </code></p>
<p>这样做，TCP 连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个 TCP 连接。这一直继续到客户端或服务器端提出断开连接。</p>
<p><strong>从 HTTP&#x2F;1.1 开始， 就默认是开启了 Keep-Alive</strong>，现在大多数浏览器都默认是使用 HTTP&#x2F;1.1，所以 Keep-Alive 都是默认打开的。一旦客户端和服务端达成协议，那么长连接就建立好了。</p>
<p>如果要关闭 HTTP Keep-Alive，需要在 HTTP 请求或者响应的 header 里添加 <code>Connection:close</code> 信息，也就是说，<strong>只要客户端和服务端任意一方的 HTTP header 中有 <code>Connection:close</code> 信息，那么就无法使用 HTTP 长连接的机制</strong>。</p>
<p>关闭 HTTP 长连接机制后，每次请求都要经历这样的过程：建立 TCP -&gt; 请求资源 -&gt; 响应资源 -&gt; 释放连接，那么此方式就是 <strong>HTTP 短连接</strong>，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdWrrgBYLP5VsrraBM1qVuz6Mbyn1OB5sHE3A6HarVbjvNt8Wuoz4bIktXZ4uAQicFlHtVnEibfviaAg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>HTTP 短连接</p>
<p>在前面我们知道，只要任意一方的 HTTP header 中有 <code>Connection:close</code> 信息，就无法使用 HTTP 长连接机制，这样在完成一次 HTTP 请求&#x2F;处理后，就会关闭连接。</p>
<p>问题来了，<strong>这时候是客户端还是服务端主动关闭连接呢？</strong></p>
<p>在 RFC 文档中，并没有明确由谁来关闭连接，<strong>请求和响应的双方都可以主动关闭 TCP 连接。</strong></p>
<p>不过，<strong>根据大多数 Web 服务的实现，不管哪一方禁用了 HTTP Keep-Alive，都是由服务端主动关闭连接</strong>，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p>
<blockquote>
<p>客户端禁用了 HTTP Keep-Alive，服务端开启 HTTP Keep-Alive，谁是主动关闭方？</p>
</blockquote>
<p>当客户端禁用了 HTTP Keep-Alive，这时候 HTTP 请求的 header 就会有 <code>Connection:close</code> 信息，这时服务端在发完 HTTP 响应后，就会主动关闭连接。</p>
<p>为什么要这么设计呢？HTTP 是请求-响应模型，发起方一直是客户端，HTTP Keep-Alive 的初衷是<strong>为客户端后续的请求重用连接</strong>，如果我们<strong>在某次 HTTP 请求-响应模型中，请求的 header 定义了 <code>connection：close</code> 信息，那不再重用这个连接的时机就只有在服务端了</strong>，所以我们在 HTTP 请求-响应这个周期的「末端」关闭连接是合理的。</p>
<blockquote>
<p>客户端开启了 HTTP Keep-Alive，服务端禁用了 HTTP Keep-Alive，谁是主动关闭方？</p>
</blockquote>
<p>当客户端开启了 HTTP Keep-Alive，而服务端禁用了 HTTP Keep-Alive，这时服务端在发完 HTTP 响应后，服务端也会主动关闭连接。</p>
<p>为什么要这么设计呢？在服务端主动关闭连接的情况下，只要调用一次 close() 就可以释放连接，剩下的工作由内核 TCP 栈直接进行了处理，整个过程只有一次 syscall；如果是要求 客户端关闭，则服务端在写完最后一个 response 之后需要把这个 socket 放入 readable 队列，调用 select &#x2F; epoll 去等待事件；然后调用一次 read() 才能知道连接已经被关闭，这其中是两次 syscall，多一次用户态程序被激活执行，而且 socket 保持时间也会更长。</p>
<p>因此，<strong>当服务端出现大量的 TIME_WAIT 状态连接的时候，可以排查下是否客户端和服务端都开启了 HTTP Keep-Alive</strong>，因为任意一方没有开启  HTTP Keep-Alive，都会导致服务端在处理完一个 HTTP 请求后，就主动关闭连接，此时服务端上就会出现大量的 TIME_WAIT 状态的连接。</p>
<p>针对这个场景下，解决的方式也很简单，让客户端和服务端都开启 HTTP Keep-Alive 机制。</p>
<h5 id="第二个场景：HTTP-长连接超时"><a href="#第二个场景：HTTP-长连接超时" class="headerlink" title="第二个场景：HTTP 长连接超时"></a>第二个场景：HTTP 长连接超时</h5><p>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p>
<p>HTTP 长连接可以在同一个 TCP 连接上接收和发送多个 HTTP 请求&#x2F;应答，避免了连接建立和释放的开销。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdWrrgBYLP5VsrraBM1qVuzJOMM2YOyn0hibsGmKnTveXVtdAueyHib140mgZgFCN1kX8LRF4VXexpA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>可能有的同学会问，如果使用了 HTTP 长连接，如果客户端完成一个 HTTP 请求后，就不再发起新的请求，此时这个 TCP 连接一直占用着不是挺浪费资源的吗？</p>
<p>对没错，所以为了避免资源浪费的情况，web 服务软件一般都会提供一个参数，用来指定 HTTP 长连接的超时时间，比如 nginx 提供的 keepalive_timeout 参数。</p>
<p>假设设置了 HTTP 长连接的超时时间是 60 秒，nginx 就会启动一个「定时器」，<strong>如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，定时器的时间一到，nginx 就会触发回调函数来关闭该连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接</strong>。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdWrrgBYLP5VsrraBM1qVuz5pHQCUACibMOoaNEuB6JqQHEST9cpyZutary8DxnB1joDHybV0ibWBOw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>HTTP 长连接超时</p>
<p>当服务端出现大量 TIME_WAIT 状态的连接时，如果现象是有大量的客户端建立完 TCP 连接后，很长一段时间没有发送数据，那么大概率就是因为 HTTP 长连接超时，导致服务端主动关闭连接，产生大量处于 TIME_WAIT 状态的连接。</p>
<p>可以往网络问题的方向排查，比如是否是因为网络问题，导致客户端发送的数据一直没有被服务端接收到，以至于 HTTP 长连接超时。</p>
<h5 id="第三个场景：HTTP-长连接的请求数量达到上限"><a href="#第三个场景：HTTP-长连接的请求数量达到上限" class="headerlink" title="第三个场景：HTTP 长连接的请求数量达到上限"></a>第三个场景：HTTP 长连接的请求数量达到上限</h5><p>Web 服务端通常会有个参数，来定义一条 HTTP 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接。</p>
<p>比如 nginx 的 keepalive_requests 这个参数，这个参数是指一个 HTTP 长连接建立之后，nginx 就会为这个连接设置一个计数器，记录这个 HTTP 长连接上已经接收并处理的客户端请求的数量。<strong>如果达到这个参数设置的最大值时，则 nginx 会主动关闭这个长连接</strong>，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p>
<p>keepalive_requests 参数的默认值是 100 ，意味着每个 HTTP 长连接最多只能跑 100  次请求，这个参数往往被大多数人忽略，因为当 QPS (每秒请求数) 不是很高时，默认值 100 凑合够用。</p>
<p>但是，<strong>对于一些 QPS 比较高的场景，比如超过 10000 QPS，甚至达到 30000 , 50000 甚至更高，如果 keepalive_requests 参数值是 100，这时候就 nginx 就会很频繁地关闭连接，那么此时服务端上就会出大量的 TIME_WAIT 状态</strong>。</p>
<p>针对这个场景下，解决的方式也很简单，调大 nginx 的 keepalive_requests 参数就行。</p>
<h4 id="TIME-WAIT-状态过多有什么危害？"><a href="#TIME-WAIT-状态过多有什么危害？" class="headerlink" title="TIME_WAIT 状态过多有什么危害？"></a>TIME_WAIT 状态过多有什么危害？</h4><p>过多的 TIME-WAIT 状态主要的危害有两种：</p>
<ul>
<li><p>第一是占用系统资源，比如文件描述符、内存资源、CPU 资源等；</p>
</li>
<li><p>第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为 <code>32768～61000</code>，也可以通过 <code>net.ipv4.ip_local_port_range</code>参数指定范围。</p>
</li>
</ul>
<p>客户端和服务端 TIME_WAIT 过多，造成的影响是不同的。</p>
<p><strong>如果客户端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT」都一样的服务端发起连接了，但是被使用的端口，还是可以继续对另外一个服务端发起连接的。具体可以看我这篇文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247517946&idx=1&sn=a3d88d7ac73792c5031ccf8422066f7c&scene=21#wechat_redirect">客户端的端口可以重复使用吗？</a></p>
<p>因此，客户端（发起连接方）都是和「目的 IP+ 目的 PORT 」都一样的服务端建立连接的话，当客户端的 TIME_WAIT 状态连接过多的话，就会受端口资源限制，如果占满了所有端口资源，那么就无法再跟「目的 IP+ 目的 PORT」都一样的服务端建立连接了。</p>
<p>不过，即使是在这种场景下，只要连接的是不同的服务端，端口是可以重复使用的，所以客户端还是可以向其他服务端发起连接的，这是因为内核在定位一个连接的时候，是通过四元组（源IP、源端口、目的IP、目的端口）信息来定位的，并不会因为客户端的端口一样，而导致连接冲突。</p>
<p><strong>如果服务端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接，但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源等。</p>
<h4 id="如何优化-TIME-WAIT-状态？"><a href="#如何优化-TIME-WAIT-状态？" class="headerlink" title="如何优化 TIME_WAIT 状态？"></a>如何优化 TIME_WAIT 状态？</h4><p>这里给出优化 TIME-WAIT 的几个方式，都是有利有弊：</p>
<ul>
<li><p>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；</p>
</li>
<li><p>net.ipv4.tcp_max_tw_buckets</p>
</li>
<li><p>程序中使用 SO_LINGER ，应用强制使用 RST 关闭。</p>
</li>
</ul>
<p><em>方式一：net.ipv4.tcp_tw_reuse 和 tcp_timestamps</em></p>
<p>开启 tcp_tw_reuse，则可以<strong>复用处于 TIME_WAIT 的 socket 为新的连接所用</strong>。</p>
<p>有一点需要注意的是，<strong>tcp_tw_reuse 功能只能用客户端（连接发起方），因为开启了该功能，在调用 connect() 函数时，内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复用。</strong></p>
<p><code>net.ipv4.tcp_tw_reuse = 1   </code></p>
<p>使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持，即</p>
<p><code>net.ipv4.tcp_timestamps=1（默认即为 1）   </code></p>
<p>这个时间戳的字段是在 TCP 头部的「选项」里，它由一共 8 个字节表示时间戳，其中第一个 4 字节字段用来保存发送该数据包的时间，第二个 4 字节字段用来保存最近一次接收对方发送到达数据的时间。</p>
<p>由于引入了时间戳，可以使得重复的数据包会因为时间戳过期被自然丢弃，因此 TIME_WAIT 状态才可以被复用。</p>
<p><em>方式二：net.ipv4.tcp_max_tw_buckets</em></p>
<p>这个值默认为 18000，<strong>当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接状态重置</strong>，这个方法比较暴力。</p>
<p><code>net.ipv4.tcp_max_tw_buckets = 18000   </code></p>
<p><em>方式三：程序中使用 SO_LINGER</em></p>
<p>我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。</p>
<p><code>struct linger so_linger;   so_linger.l_onoff = 1;   so_linger.l_linger = 0;   setsockopt(s, SOL_SOCKET, SO_LINGER, &amp;so_linger,sizeof(so_linger));   </code></p>
<p>如果<code>l_onoff</code>为非 0， 且<code>l_linger</code>值为 0，那么调用<code>close</code>后，会立该发送一个<code>RST</code>标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了<code>TIME_WAIT</code>状态，直接关闭。</p>
<p>但这为跨越<code>TIME_WAIT</code>状态提供了一个可能，不过是一个非常危险的行为，不值得提倡。</p>
<p>前面介绍的方法都是试图越过 <code>TIME_WAIT</code>状态的，这样其实不太好。虽然 TIME_WAIT 状态持续的时间是有一点长，显得很不友好，但是它被设计来就是用来避免发生乱七八糟的事情。</p>
<p>《UNIX网络编程》一书中却说道：<strong>TIME_WAIT 是我们的朋友，它是有助于我们的，不要试图避免这个状态，而是应该弄清楚它</strong>。</p>
<p><strong>如果服务端要避免过多的 TIME_WAIT 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT</strong>。</p>
<h3 id="服务端出现大量-CLOSE-WAIT-状态的原因有哪些？"><a href="#服务端出现大量-CLOSE-WAIT-状态的原因有哪些？" class="headerlink" title="服务端出现大量 CLOSE_WAIT 状态的原因有哪些？"></a>服务端出现大量 CLOSE_WAIT 状态的原因有哪些？</h3><p>还是拿这张图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdWrrgBYLP5VsrraBM1qVuzgibl5CZs9FKwxdu2j2In9NPx4W5wC2e91AjbyLlwL7jvEY5NNjuRr5Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>TCP 四次挥手的流程</p>
<p>从上面这张图我们可以得知，CLOSE_WAIT 状态是「被动关闭方」才会有的状态，而且如果「被动关闭方」没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态。</p>
<p>所以，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接</strong>。</p>
<p>那什么情况会导致服务端的程序没有调用 close 函数关闭连接？这时候通常需要排查代码。</p>
<p>我们先来分析一个普通的 TCP 服务端的流程：</p>
<ol>
<li><p>创建服务端 socket，bind 绑定端口、listen 监听端口</p>
</li>
<li><p>将服务端 socket 注册到 epoll</p>
</li>
<li><p>epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket</p>
</li>
<li><p>将已连接的 socket 注册到 epoll</p>
</li>
<li><p>epoll_wait 等待事件发生</p>
</li>
<li><p>对方连接关闭时，我方调用 close</p>
</li>
</ol>
<p>可能导致服务端没有调用 close 函数的原因，如下。</p>
<p><strong>第一个原因</strong>：第 2 步没有做，没有将服务端 socket 注册到 epoll，这样有新连接到来时，服务端没办法感知这个事件，也就无法获取到已连接的 socket，那服务端自然就没机会对 socket 调用 close 函数了。</p>
<p>不过这种原因发生的概率比较小，这种属于明显的代码逻辑 bug，在前期 read view 阶段就能发现的了。</p>
<p><strong>第二个原因</strong>：第 3 步没有做，有新连接到来时没有调用 accpet 获取该连接的 socket，导致当有大量的客户端主动断开了连接，而服务端没机会对这些 socket 调用 close 函数，从而导致服务端出现大量 CLOSE_WAIT 状态的连接。</p>
<p>发生这种情况可能是因为服务端在执行 accpet  函数之前，代码卡在某一个逻辑或者提前抛出了异常。</p>
<p><strong>第三个原因</strong>：第 4 步没有做，通过 accpet 获取已连接的 socket 后，没有将其注册到 epoll，导致后续收到 FIN 报文的时候，服务端没办法感知这个事件，那服务端就没机会调用 close 函数了。</p>
<p>发生这种情况可能是因为服务端在将已连接的 socket 注册到 epoll 之前，代码卡在某一个逻辑或者提前抛出了异常。之前看到过别人解决 close_wait 问题的实践文章，感兴趣的可以看看：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU3Njk0MTc3Ng==&mid=2247486020&idx=1&sn=f7cf41aec28e2e10a46228a64b1c0a5c&scene=21#wechat_redirect">一次 Netty 代码不健壮导致的大量 CLOSE_WAIT 连接原因分析</a></p>
<p><strong>第四个原因</strong>：第 6 步没有做，当发现客户端关闭连接后，服务端没有执行 close 函数，可能是因为代码漏处理，或者是在执行 close 函数之前，代码卡在某一个逻辑，比如发生死锁等等。</p>
<p>可以发现，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，通常都是代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用 close</strong>。<br>面试问题</p>
<p>1）TCP&#x2F;IP协议<br>    1）三次握手&#x2F;四次挥手过程<br>    2）TIME_WAIT状态<br>        1）主动关闭&#x2F;被动关闭<br>        2）需要的原因<br>        3）缓解措施<br>        4）有没有方式不出现TIME_WAIT状态<br>    3）RST出现的场景<br>    4）滑动窗口<br>2）网络编程<br>    1）EPOLL&#x2F;SELECT的区别<br>    2）边沿触发&#x2F;水平触发<br>    3）事件触发的场景<br>        1）读事件 有哪些场景<br>        2）写事件 有哪些场景<br>    4）READ调用返回值场景<br>        1）0<br>        2）-1<br>        3）&gt;0<br>    5）UDP客户端可以CONNECT不，那CONNECT和不CONNECT有啥区别<br>3）后台编程<br>    1）FORK的用途，FORK区分父子进程方式<br>    2）进程间通信方式<br>    3）僵尸进程<br>    4）内存模型，有哪些段构成<br>    5）进程&#x2F;线程&#x2F;协程的区别<br>4）常见中间件<br>    1）MYSQL<br>        1）为啥不建议SELECT *<br>        2）覆盖索引<br>        3）分页优化<br>    2）ZOOKEEPER<br>        1）有哪些WATCH以及对应唤醒事件<br>    3）KAFKA<br>        1）分区分服<br>        2）生产者<br>        3）消费者<br>5）语言<br>    1）JAVA语言<br>        1）内存管理<br>6）设计模式<br>    1）单例模式<br>7）项目中的难点、挑战点</p>
<p>22989-腾讯云网络后台开发工程师(CSIG全资子公司)（西安）</p>
<p>建议用online ddl（网上可以查）修改，就是逗号后面的参数<br>另外，添加字段要加上after，根据表结构看看fromWanIp适合在哪个字段后<br>ALTER TABLE cEip ALTER COLUMN ispId SET DEFAULT -1, ALGORITHM&#x3D;INPLACE, LOCK&#x3D;NONE;</p>
<h3 id="HTTP-长连接和-TCP-长连接有什么区别？"><a href="#HTTP-长连接和-TCP-长连接有什么区别？" class="headerlink" title="HTTP 长连接和 TCP 长连接有什么区别？"></a>HTTP 长连接和 TCP 长连接有什么区别？</h3><p>其实就是HTTP 的 Keep-Alive 和 TCP 的 Keepalive 有什么区别？<br>事实上，<strong>这两个完全是两样不同东西</strong>，实现的层面也不同：</p>
<ul>
<li><p>HTTP 的 Keep-Alive，是由<strong>应用层（用户态）</strong> 实现的，称为 HTTP 长连接；</p>
</li>
<li><p>TCP 的 Keepalive，是由 <strong>TCP 层（内核态）</strong> 实现的，称为 TCP 保活机制；</p>
</li>
</ul>
<p>接下来，分别说说它们。</p>
<h4 id="HTTP-的-Keep-Alive"><a href="#HTTP-的-Keep-Alive" class="headerlink" title="HTTP 的 Keep-Alive"></a>HTTP 的 Keep-Alive</h4><p>HTTP 协议采用的是「请求-应答」的模式，也就是客户端发起了请求，服务端才会返回响应，一来一回这样子。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcicwmSuxnPJ1qyiaohMl86ibZhnSbPF3JPicyAmYmy8jQZb5zFKD8tGSDQGkCsrbPD7jJLicqRVet6vrA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>请求-应答</p>
<p>由于 HTTP 是基于 TCP 传输协议实现的，客户端与服务端要进行 HTTP 通信前，需要先建立 TCP 连接，然后客户端发送 HTTP  请求，服务端收到后就返回响应，至此「请求-应答」的模式就完成了，随后就会释放 TCP 连接。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcicwmSuxnPJ1qyiaohMl86ibZcOoBjt1XmlEoAWTf4V6musIJQE5nxsRRe5gjciaDLPJUZbhZowzibMibQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>一个 HTTP 请求</p>
<p>如果每次请求都要经历这样的过程：建立 TCP -&gt; 请求资源 -&gt; 响应资源 -&gt; 释放连接，那么此方式就是 <strong>HTTP 短连接</strong>，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcicwmSuxnPJ1qyiaohMl86ibZ3ulicF0AUhTNPjyHE5Dur1sI8cda110PRsPmYEenOIBHpZnayHUFkow/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>HTTP 短连接</p>
<p>这样实在太累人了，一次连接只能请求一次资源。</p>
<p>能不能在第一个 HTTP 请求完后，先不断开 TCP 连接，让后续的 HTTP 请求继续使用此连接？</p>
<p>当然可以，HTTP 的 Keep-Alive 就是实现了这个功能，可以使用同一个 TCP 连接来发送和接收多个 HTTP 请求&#x2F;应答，避免了连接建立和释放的开销，这个方法称为 <strong>HTTP 长连接</strong>。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcicwmSuxnPJ1qyiaohMl86ibZAJAJPbK9xMB5j9nTzs87SwRibAU52mG4ILuB3XvpXNll4gKYazoYUaw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>HTTP 长连接</p>
<p>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p>
<p>怎么才能使用 HTTP 的 Keep-Alive 功能？</p>
<p>在 HTTP 1.0 中默认是关闭的，如果浏览器要开启 Keep-Alive，它必须在请求的包头中添加：</p>
<p><code>Connection: Keep-Alive   </code></p>
<p>然后当服务器收到请求，作出回应的时候，它也添加一个头在响应中：</p>
<p><code>Connection: Keep-Alive   </code></p>
<p>这样做，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接。这一直继续到客户端或服务器端提出断开连接。</p>
<p><strong>从 HTTP 1.1 开始， 就默认是开启了 Keep-Alive</strong>，如果要关闭 Keep-Alive，需要在 HTTP 请求的包头里添加：</p>
<p><code>Connection:close   </code></p>
<p>现在大多数浏览器都默认是使用 HTTP&#x2F;1.1，所以 Keep-Alive 都是默认打开的。一旦客户端和服务端达成协议，那么长连接就建立好了。</p>
<p>HTTP 长连接不仅仅减少了 TCP 连接资源的开销，而且这给 <strong>HTTP 流水线</strong>技术提供了可实现的基础。</p>
<p>所谓的 HTTP 流水线，是<strong>客户端可以先一次性发送多个请求，而在发送过程中不需先等待服务器的回应</strong>，可以减少整体的响应时间。</p>
<p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。HTTP 流水线机制则允许客户端同时发出 A 请求和 B 请求。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcicwmSuxnPJ1qyiaohMl86ibZy8Ha8LtNZHu3672NVwlpK4iaf9TibSkhbPfHKZHeruKPYdZ87utlcIIw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>右边为 HTTP 流水线机制</p>
<p>但是<strong>服务器还是按照顺序响应</strong>，先回应 A 请求，完成后再回应 B 请求。</p>
<p>而且要等服务器响应完客户端第一批发送的请求后，客户端才能发出下一批的请求，也就说如果服务器响应的过程发生了阻塞，那么客户端就无法发出下一批的请求，此时就造成了「队头阻塞」的问题。</p>
<p>可能有的同学会问，如果使用了 HTTP 长连接，如果客户端完成一个 HTTP 请求后，就不再发起新的请求，此时这个 TCP 连接一直占用着不是挺浪费资源的吗？</p>
<p>对没错，所以为了避免资源浪费的情况，web 服务软件一般都会提供 <code>keepalive_timeout</code> 参数，用来指定 HTTP 长连接的超时时间。</p>
<p>比如设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会<strong>启动一个定时器</strong>，如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，<strong>定时器的时间一到，就会触发回调函数来释放该连接。</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcicwmSuxnPJ1qyiaohMl86ibZlTIRFic7L5E39WAIhnL2EibUTRwYIqCReFq4J6RKfcmozBP9agZCundA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>HTTP 长连接超时</p>
<h4 id="TCP-的-Keepalive"><a href="#TCP-的-Keepalive" class="headerlink" title="TCP 的 Keepalive"></a>TCP 的 Keepalive</h4><p>TCP 的 Keepalive 这东西其实就是 <strong>TCP 的保活机制</strong>，它的工作原理我之前的文章写过，这里就直接贴下以前的内容。</p>
<p>如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。</p>
<ul>
<li><p>如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</p>
</li>
<li><p>如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</p>
</li>
</ul>
<p>所以，TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活，这个工作是在内核完成的。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcicwmSuxnPJ1qyiaohMl86ibZHmAI3j2722ibjS7IibNtaiaZibbDpMpBPC8OWbfHsEHwcacE0ZRjgc8pibg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>TCP 保活机制</p>
<p>注意，应用程序若想使用 TCP 保活机制需要通过 socket 接口设置 <code>SO_KEEPALIVE</code> 选项才能够生效，如果没有设置，那么就无法使用 TCP 保活机制。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>HTTP 的 Keep-Alive 也叫 HTTP 长连接，该功能是由「应用程序」实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求&#x2F;应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销。</p>
<p>TCP 的 Keepalive 也叫 TCP 保活机制，该功能是由「内核」实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。</p>
<h3 id="HTTPS-一定安全可靠吗？"><a href="#HTTPS-一定安全可靠吗？" class="headerlink" title="HTTPS 一定安全可靠吗？"></a>HTTPS 一定安全可靠吗？</h3><p>客户端通过浏览器向服务端发起 HTTPS 请求时，被「假基站」转发到了一个「中间人服务器」，于是客户端是和「中间人服务器」完成了 TLS 握手，然后这个「中间人服务器」再与真正的服务端完成 TLS 握手。</p>
<p>具体过程如下：<br>![[Pasted image 20230517164728.png]]</p>
<ul>
<li><p>客户端向服务端发起 HTTPS 建立连接请求时，然后被「假基站」转发到了一个「中间人服务器」，接着中间人向服务端发起 HTTPS 建立连接请求，此时客户端与中间人进行 TLS 握手，中间人与服务端进行 TLS 握手；</p>
</li>
<li><p>在客户端与中间人进行 TLS 握手过程中，中间人会发送自己的公钥证书给客户端，<strong>客户端验证证书的真伪</strong>，然后从证书拿到公钥，并生成一个随机数，用公钥加密随机数发送给中间人，中间人使用私钥解密，得到随机数，此时双方都有随机数，然后通过算法生成对称加密密钥（A），后续客户端与中间人通信就用这个对称加密密钥来加密数据了。</p>
</li>
<li><p>在中间人与服务端进行 TLS 握手过程中，服务端会发送从 CA 机构签发的公钥证书给中间人，从证书拿到公钥，并生成一个随机数，用公钥加密随机数发送给服务端，服务端使用私钥解密，得到随机数，此时双方都有随机数，然后通过算法生成对称加密密钥（B），后续中间人与服务端通信就用这个对称加密密钥来加密数据了。</p>
</li>
<li><p>后续的通信过程中，中间人用对称加密密钥（A）解密客户端的 HTTPS 请求的数据，然后用对称加密密钥（B）加密 HTTPS 请求后，转发给服务端，接着服务端发送 HTTPS 响应数据给中间人，中间人用对称加密密钥（B）解密 HTTPS 响应数据，然后再用对称加密密钥（A）加密后，转发给客户端。</p>
</li>
</ul>
<p>从客户端的角度看，其实并不知道网络中存在中间人服务器这个角色。</p>
<p>那么中间人就可以解开浏览器发起的 HTTPS 请求里的数据，也可以解开服务端响应给浏览器的 HTTPS 响应数据。相当于，中间人能够 “偷看” 浏览器与服务端之间的 HTTPS 请求和响应的数据。</p>
<p>但是要发生这种场景是有前提的，<strong>前提是用户点击接受了中间人服务器的证书。</strong></p>
<p>中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0Dm1SNmvUayxCflHTROibNzricwiaRlwzuc1CUqXYTYEapwDNUybxhiaWfofHt7LSuzC4cFdYvwcJoA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>如果用户执意点击「继续浏览此网站」，相当于用户接受了中间人伪造的证书，那么后续整个 HTTPS 通信都能被中间人监听了。</p>
<p>所以，这其实并不能说 HTTPS 不够安全，毕竟浏览器都已经提示证书有问题了，如果用户坚决要访问，那<strong>不能怪 HTTPS ，得怪自己手贱</strong>。</p>
<h4 id="客户端是如何验证证书的？"><a href="#客户端是如何验证证书的？" class="headerlink" title="客户端是如何验证证书的？"></a>客户端是如何验证证书的？</h4><p>接下来，详细说一下实际中数字证书签发和验证流程。</p>
<p>如下图图所示，为数字证书签发和验证流程：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0Dm1SNmvUayxCflHTROibNMxlSGIfI1kiav1TwxTK6ZtGiaCiaygM3g0fFnPYo3n9atZlbhvpkWt77Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">当服务端向 CA 机构申请证书的时候，CA 签发证书的过程，如上图左边部分：</p>
<ul>
<li><p>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</p>
</li>
<li><p>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</p>
</li>
<li><p>最后将 Certificate Signature 添加在文件证书上，形成数字证书；</p>
</li>
</ul>
<p>客户端校验服务端的数字证书的过程，如上图右边部分：</p>
<ul>
<li><p>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</p>
</li>
<li><p>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</p>
</li>
<li><p>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</p>
</li>
</ul>
<p>但事实上，证书的验证过程中<strong>还存在一个证书信任链的问题</strong>，因为我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的，比如百度的证书，从下图你可以看到，证书的层级有三级：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0Dm1SNmvUayxCflHTROibNVINCkWDhqk7OiaibpvuUnYAt2GXtShM9z5bWCG1TSZH6LzzylakSk83w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>对于这种三级层级关系的证书的验证过程如下：</p>
<ul>
<li><p>客户端收到 baidu.com 的证书后，发现这个证书的签发者不是根证书，就无法根据本地已有的根证书中的公钥去验证 baidu.com 证书是否可信。于是，客户端根据 baidu.com 证书中的签发者，找到该证书的颁发机构是 “GlobalSign Organization Validation CA - SHA256 - G2”，然后向 CA 请求该中间证书。</p>
</li>
<li><p>请求到证书后发现 “GlobalSign Organization Validation CA - SHA256 - G2” 证书是由 “GlobalSign Root CA” 签发的，由于 “GlobalSign Root CA” 没有再上级签发机构，说明它是根证书，也就是自签证书。应用软件会检查此证书有否已预载于根证书清单上，如果有，则可以利用根证书中的公钥去验证 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，如果发现验证通过，就认为该中间证书是可信的。</p>
</li>
<li><p>“GlobalSign Organization Validation CA - SHA256 - G2” 证书被信任后，可以使用 “GlobalSign Organization Validation CA - SHA256 - G2” 证书中的公钥去验证 baidu.com 证书的可信性，如果验证通过，就可以信任 baidu.com 证书。</p>
</li>
</ul>
<p>在这四个步骤中，最开始客户端只信任根证书 GlobalSign Root CA 证书的，然后 “GlobalSign Root CA” 证书信任 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，而 “GlobalSign Organization Validation CA - SHA256 - G2” 证书又信任 baidu.com 证书，于是客户端也信任 baidu.com 证书。总括来说，由于用户信任 GlobalSign，所以由 GlobalSign 所担保的 baidu.com 可以被信任，另外由于用户信任操作系统或浏览器的软件商，所以由软件商预载了根证书的 GlobalSign 都可被信任。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0Dm1SNmvUayxCflHTROibNIPhXyF7S1WDIbuUbGwgLjwr47iau48ape1H3GYg8B0hDEKeqdz7xZgg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>操作系统里一般都会内置一些根证书，比如我的 MAC 电脑里内置的根证书有这么多：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0Dm1SNmvUayxCflHTROibNloHzrlsep6vZgNvz8sA8LDBHnAWyErqcpicRM6kovSB5L3IQcjdD5aw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这样的一层层地验证就构成了一条信任链路，整个证书信任链验证流程如下图所示：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0Dm1SNmvUayxCflHTROibNFruFDENMpzLgnfRH9T8uN0TAOItwoqia9mXLNLsE7UErltjyBu2zicNQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>如果你的电脑中毒了，被恶意导入了中间人的根证书，那么在验证中间人的证书的时候，由于你操作系统信任了中间人的根证书，那么等同于中间人的证书是合法的。</p>
<p>这种情况下，浏览器是不会弹出证书存在问题的风险提醒的。</p>
<p>这其实也不关 HTTPS 的事情，是你电脑中毒了才导致 HTTPS 数据被中间人劫持的。</p>
<p>所以，<strong>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全。</strong></p>
<h4 id="为什么抓包工具能截取-HTTPS-数据？"><a href="#为什么抓包工具能截取-HTTPS-数据？" class="headerlink" title="为什么抓包工具能截取 HTTPS 数据？"></a>为什么抓包工具能截取 HTTPS 数据？</h4><p>抓包工具 Fiddler 之所以可以明文看到 HTTPS 数据，工作原理与中间人一致的。</p>
<p>对于 HTTPS 连接来说，中间人要满足以下两点，才能实现真正的明文代理:</p>
<ol>
<li><p>中间人，作为客户端与真实服务端建立连接这一步不会有问题，因为服务端不会校验客户端的身份；</p>
</li>
<li><p>中间人，作为服务端与真实客户端建立连接，这里会有客户端信任服务端的问题，也就是服务端必须有对应域名的私钥；</p>
</li>
</ol>
<p>中间人要拿到私钥只能通过如下方式：</p>
<ol>
<li><p>去网站服务端拿到私钥；</p>
</li>
<li><p>去CA处拿域名签发私钥；</p>
</li>
<li><p>自己签发证书，且被浏览器信任；</p>
</li>
</ol>
<p>不用解释，抓包工具只能使用第三种方式取得中间人的身份。</p>
<p>使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装 Fiddler 的根证书，这里实际上起认证中心（CA）的作用。</p>
<p>Fiddler 能够抓包的关键是客户端会往系统受信任的根证书列表中导入 Fiddler 生成的证书，而这个证书会被浏览器信任，也就是 Fiddler 给自己创建了一个认证中心 CA。</p>
<p>客户端拿着中间人签发的证书去中间人自己的 CA 去认证，当然认为这个证书是有效的。</p>
<h4 id="如何避免被中间人抓取数据？"><a href="#如何避免被中间人抓取数据？" class="headerlink" title="如何避免被中间人抓取数据？"></a>如何避免被中间人抓取数据？</h4><p>我们要保证自己电脑的安全，不要被病毒乘虚而入，而且也不要点击任何证书非法的网站，这样 HTTPS 数据就不会被中间人截取到了。</p>
<p>当然，我们还可以通过 HTTPS 双向认证来避免这种问题。</p>
<p>一般我们的 HTTPS 是单向认证，客户端只会验证了服务端的身份，但是服务端并不会验证客户端的身份。</p>
<p>如果用了双向认证方式，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0Dm1SNmvUayxCflHTROibNccBibe4MEf260dWmCfGnvHgz7iaZza3s1Sq6UwibbuGickDfMIcwAlGBGQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。</p>
<h3 id="客户端连接一个不存在的-IP-地址，会发生什么？客户端连接一个存在的-IP-地址但是端口不存在，会发生什么？"><a href="#客户端连接一个不存在的-IP-地址，会发生什么？客户端连接一个存在的-IP-地址但是端口不存在，会发生什么？" class="headerlink" title="客户端连接一个不存在的 IP 地址，会发生什么？客户端连接一个存在的 IP 地址但是端口不存在，会发生什么？"></a>客户端连接一个不存在的 IP 地址，会发生什么？客户端连接一个存在的 IP 地址但是端口不存在，会发生什么？</h3><p>PS：这里的「连接」指的是 TCP 连接。</p>
<blockquote>
<p>Q1：客户端连接一个不存在的 IP 地址，会发生什么？</p>
</blockquote>
<p>这个问题要分两种情况来思考，不同的情况得到的结论是不同的。</p>
<p><em>第一个情况：目标 IP 地址和客户端的 IP 地址是同一个局域网（网络号相同）。</em></p>
<p>第一种情况，客户端无法发出 SYN 报文，主要卡在数据链路层。</p>
<p>因为目标地址不存在 IP 地址，客户端的内核在发 arp 请求的时候，广播询问这个目标 IP 地址是谁的，由于网络中不存在该目标 IP 地址，所以没有设备应答客户端的 arp 请求。</p>
<p>由于<strong>客户端无法拿到目标设备的 MAC，这样就没办法组装 MAC 头的信息，所以 SYN 报文无法发送出去</strong>。</p>
<p><em>第二个情况：目标 IP 地址和客户端的 IP 地址不在同一个局域网（网络号不同）。</em></p>
<p>第二种情况，客户端会先将 SYN 报文发给路由器，然后路由器会继续转发。</p>
<p>由于目标 IP 地址是不存在的，该 SYN 报文会在网络中消亡，因此客户端是不会收到对 SYN 报文的确认报文的，接着<strong>客户端会触发超时重传，重传 SYN 报文，直到重传的次数达到最大次数后，客户端的连接就会被释放</strong>。</p>
<p>可能有的同学好奇，为什么这种情况客户端的 SYN 报文可以发出来？</p>
<p>因为当目标 IP 地址和客户端 IP 地址不在同一个局域网时，客户端客通过路由表的判断，判断到下一步是要将网络报文发送给路由器。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfm4PfB688v0rxFhJb6z15lQyA1upkFc3DxHn6sJ50fuyvdBMNTQUZ1FK1d5qM2C9ibWQP0eOKpcaw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这时候数据链路层的 arp 请求，会广播询问 IP 地址（路由器 IP 地址）是谁的，路由器发现是自己的 IP 地址，于是就会将自己的 MAC 地址告诉客户端。</p>
<p>然后客户端的网络报文中 MAC 头的「目标 MAC 地址」填入的就是路由器的 MAC 地址，于是 SYN 报文就可以发送出去了。</p>
<p>由于目标 MAC 地址是路由器的，所以就会被路由器接收，然后路由器继续通过路由表的判断，转发给下一个路由器，直到找到目标设备。</p>
<blockquote>
<p>Q2：客户端连接一个存在的 IP 地址但是端口不存在，会发生什么？</p>
</blockquote>
<p>客户端连接的目标 IP 地址是存在的，那么 SYN 报文就能正确的抵达到目标设备。</p>
<p>目标设备收到 SYN 报文后，发现端口号并没有被进程监听，这时候目标设备的内核就会回 RST 报文。</p>
<p>客户端收到 RST 报文后，就会释放连接。</p>
<p>…….</p>
<p>至此，结论已说完。</p>
<p>不知道你们会不会觉得信息量很大，如果你觉得信息量大，那么你该补补网络知识啦。</p>
<p>第二题不难，难在的是第一题，如果你没有把两台电脑之间是怎么通信的搞清楚，那么你是无从下手回答的，所以建立好体系化的网络知识，面对这类的场景题目，就能做到举一反三了。</p>
<p>最近比较忙，偷懒了，没有画图，如果哪里没理解的，可以先看我以前写的这篇文章：<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247483989&idx=1&sn=7e2ed852770743d3955ef9d5561fcef3&chksm=f98e46ffcef9cfe98e6c753afac86125b0d5891ca5e63968b5f3a8da4905d14274088f40c34e&scene=21#wechat_redirect">探究！一个数据包在网络中的心路历程</a>，有详细讲解每一层是怎么封装头部的，以及路由表是怎么判断的。</p>
<p><strong>最后再提一个问题：****客户端发送了一个目标 IP 地址存在但是</strong>端口不存在的 UDP 报文<strong>，UDP 没有像 TCP 那样的 RST 报文，此时会发生什么？</strong></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-08-15T09:50:31.526Z" title="2024/8/15 17:50:31">2024-08-15</time>发表</span><span class="level-item"><time dateTime="2024-08-15T09:50:43.445Z" title="2024/8/15 17:50:43">2024-08-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/100-CodingSkills/">100_CodingSkills</a><span> / </span><a class="link-muted" href="/categories/100-CodingSkills/106-Cpp/">106_Cpp</a></span><span class="level-item">38 分钟读完 (大约5651个字)</span></div></div><div class="content"><hr>
<p>00_CppInterview<br>aliases:<br>tags: #cs#interview #cpp<br>date: 2023-10-08 15:29</p>
<hr>
<h2 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h2><h3 id="对new和malloc的理解"><a href="#对new和malloc的理解" class="headerlink" title="对new和malloc的理解"></a>对new和malloc的理解</h3><p>new和malloc都是动态内存分配函数。其中，new是C++中的操作符，malloc是C语言中的函数。new会调用对象的构造函数，而malloc不会。使用new可以简化代码，并且更加类型安全。<br><strong>new和malloc区别：</strong></p>
<ul>
<li><p><strong>分配内存的位置</strong>：malloc是从堆上动态分配内存，new是从自由存储区为对象动态分配内存。自由存储区的位置取决于operator new的实现。自由存储区不仅可以为堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。</p>
</li>
<li><p><strong>返回类型安全性</strong>：malloc内存分配成功后返回void*，然后再强制类型转换为需要的类型；new操作符分配内存成功后返回与对象类型相匹配的指针类型；因此new是符合类型安全的操作符。</p>
</li>
<li><p><strong>内存分配失败返回值</strong>：malloc内存分配失败后返回NULL。new分配内存失败则会抛异常（bac_alloc）。</p>
</li>
<li><p><strong>分配内存的大小的计算</strong>：使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。</p>
</li>
<li><p><strong>是否可以被重载</strong>：opeartor new &#x2F;operator delete可以被重载。而malloc&#x2F;free则不能重载。</p>
</li>
</ul>
<p><strong>new是在内存上哪一块去分配的内存</strong></p>
<p>堆</p>
<p><strong>补充：</strong></p>
<p>new所申请的内存区域在C++中称为自由存储区。很多编译器的new&#x2F;delete都是以malloc&#x2F;free为基础来实现的，所以通常都是借由堆实现来实现自由存储，这时候就可以说new所申请的内存区域在堆上。</p>
<p><strong>如果new内存失败了会是怎么样？</strong></p>
<p>会抛出std::bad_alloc异常。</p>
<p><strong>补充：</strong></p>
<p>如果加上std::nothrow关键字，A* p &#x3D; new (std::nothrow) A;，new 就不会抛出异常而是会返回空指针。</p>
<h3 id="析构函数为什么通常是会做成一个虚函数呢"><a href="#析构函数为什么通常是会做成一个虚函数呢" class="headerlink" title="析构函数为什么通常是会做成一个虚函数呢"></a>析构函数为什么通常是会做成一个虚函数呢</h3><p>如果一个类有虚函数，就应该为其定义一个虚析构函数。这是因为在使用delete操作符释放一个指向派生类对象的基类指针时，如果基类的析构函数不是虚函数，那么只会调用基类的析构函数，而不会调用派生类的析构函数，这样就会导致内存泄漏和未定义行为的问题。通过将析构函数定义为虚函数，可以确保在释放派生类对象时，先调用派生类的析构函数，再调用基类的析构函数，从而避免内存泄漏和未定义行为的问题。</p>
<h3 id="右值引用有什么作用"><a href="#右值引用有什么作用" class="headerlink" title="右值引用有什么作用"></a>右值引用有什么作用</h3><p>右值引用是C++11引入的特性，它是指对右值进行引用的一种方式。右值引用的作用主要有两个：</p>
<ul>
<li>在传递一个对象时，如果使用的是左值引用，那么会调用对象的拷贝构造函数。但是如果该对象只需要被移动而不需要进行复制，就会浪费时间和内存。右值引用可以通过std::move将一个左值转换为右值，从而调用对象的移动构造函数，实现了移动语义，避免了不必要的拷贝操作，提高了程序的效率。</li>
<li>右值引用还可以用于完美转发。在函数模板中，通过使用右值引用类型的形参来接收参数，可以实现完美转发，即保持原参数的值类别（左值还是右值），将参数传递给另一个函数。</li>
</ul>
<h3 id="智能指针相关"><a href="#智能指针相关" class="headerlink" title="智能指针相关"></a>智能指针相关</h3><p><strong>定义</strong><br>智能指针是C++中的一种特殊指针，它是一个对象，用来管理另一个指针所指向的对象的生命周期。智能指针可以自动地分配和释放内存，避免手动管理内存的麻烦和出错风险。</p>
<p>C++标准库提供了三种智能指针：</p>
<ul>
<li>shared_ptr：多个智能指针可以共享同一个对象，当最后一个指针被销毁时，它会释放对象的内存。</li>
<li>unique_ptr：独占式智能指针，不能共享同一个对象，当智能指针被销毁时，它会释放对象的内存。</li>
<li>weak_ptr：弱引用智能指针，不会增加对象的引用计数，用于避免shared_ptr循环引用时的内存泄漏问题。</li>
</ul>
<p><strong>在哪些场景下会应用智能指针</strong></p>
<p>我自己是在在动态内存管理中，使用智能指针可以避免手动管理内存的麻烦和出错风险。</p>
<h3 id="如果遇到内存泄漏这种问题，你一般是怎么去解决"><a href="#如果遇到内存泄漏这种问题，你一般是怎么去解决" class="headerlink" title="如果遇到内存泄漏这种问题，你一般是怎么去解决"></a>如果遇到内存泄漏这种问题，你一般是怎么去解决</h3><ul>
<li>在程序中加入必要的错误处理代码，避免程序因为异常情况而导致内存泄漏。</li>
<li>使用智能指针等RAII机制，自动管理内存，避免手动管理内存的麻烦和出错风险。</li>
<li>使用内存分析工具，检测程序中的内存泄漏，并进行相应的修复</li>
</ul>
<h3 id="shared-ptr的原理"><a href="#shared-ptr的原理" class="headerlink" title="shared_ptr的原理"></a>shared_ptr的原理</h3><p>答：内部的共享数据和引用计数实现</p>
<p><strong>补充：</strong></p>
<p>shared_ptr多个指针指向相同的对象。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。</p>
<p>shared_ptr的一个最大的陷阱是循环引用，循环引用会导致堆内存无法正确释放，导致内存泄漏，可以通过 weak_ptr 来解决这个问题。</p>
<h3 id="多线程怎么保证引用计数的安全的"><a href="#多线程怎么保证引用计数的安全的" class="headerlink" title="多线程怎么保证引用计数的安全的"></a>多线程怎么保证引用计数的安全的</h3><p>答：引用计数这个变量是std::atomic，操作时自带锁</p>
<h3 id="常见的锁有哪些"><a href="#常见的锁有哪些" class="headerlink" title="常见的锁有哪些"></a>常见的锁有哪些</h3><p>答：读写锁、互斥锁这些，再就是一些锁思想，比如乐观锁、悲观锁、自旋锁</p>
<h3 id="valotile关键字的用处"><a href="#valotile关键字的用处" class="headerlink" title="valotile关键字的用处"></a>valotile关键字的用处</h3><p><code>volatile</code>是C和C++中的一个关键字，用于告诉编译器，所修饰的变量在程序执行期间可能会被意外地改变，因此不能进行优化。下面是几个<code>volatile</code>关键字的用处：</p>
<ol>
<li>防止编译器进行优化 当使用<code>volatile</code>关键字修饰变量时，编译器就不会对这个变量进行优化，因为这个变量可能会在程序运行期间被其他程序或者硬件进行修改。例如：</li>
</ol>
<p><code>volatile int* ptr = ...; int a = *ptr;</code></p>
<p>如果<code>ptr</code>所指向的内存是由硬件设备直接控制，则编译器不能对其进行优化。</p>
<ol start="2">
<li><p>多线程访问同一个变量 在多线程编程中，如果多个线程都需要访问同一个变量，并且该变量可能会被其他线程修改，则应该使用<code>volatile</code>来修饰这个变量，以确保每个线程都能正确读取变量的最新值。</p>
</li>
<li><p>访问硬件寄存器 当程序需要访问硬件寄存器时，应该使用<code>volatile</code>来修饰寄存器，因为寄存器的值可能会被其他程序或者硬件进行修改。</p>
</li>
</ol>
<p>总之，<code>volatile</code>关键字用于告诉编译器，所修饰的变量在程序执行期间可能会被意外地改变，因此不能进行优化。在多线程编程和访问硬件寄存器时，应该使用<code>volatile</code>来修饰变量，以确保程序能够正确地读取最新的值。</p>
<ul>
<li>数组、指针和引用的区别</li>
<li>类成员和方法，说出方法匹配顺序、默认参数</li>
<li>继承 构造函数和析构函数 调用顺序</li>
<li>const、static的使用场景</li>
<li>多态的实现、虚表实现多态机制</li>
<li>虚函数、纯虚函数、抽象类概念，抽象类为什么不能实例化</li>
</ul>
<h3 id="vector和list区别，-内存分别，-不同的使用场景，"><a href="#vector和list区别，-内存分别，-不同的使用场景，" class="headerlink" title="vector和list区别， 内存分别， 不同的使用场景，"></a>vector和list区别， 内存分别， 不同的使用场景，</h3><p><code>vector</code>和<code>list</code>都是C++ STL（Standard Template Library）中的容器。它们在存储数据时的内存分配方式不同，具有以下几点区别：</p>
<ol>
<li><p>存储方式 <code>vector</code>采用连续的动态数组存储元素，因此在访问元素时可以随机访问，速度较快。而<code>list</code>采用双向链表存储元素，因此在访问元素时只能顺序访问，速度相对较慢。</p>
</li>
<li><p>内存分配 由于<code>vector</code>采用连续的动态数组存储元素，因此需要预分配一块连续的内存空间。当插入元素时，如果当前内存空间不足，则需要重新分配一块更大的内存空间，并将原有元素复制到新的内存空间中。而<code>list</code>则是通过链表进行存储，每个节点存储一个元素，因此在插入或者删除元素时，只需要修改相应的链表指针即可。</p>
</li>
<li><p>内存占用 由于<code>vector</code>需要预分配一段连续的内存空间，因此在存储大量元素时可能会浪费一定的内存空间。而<code>list</code>则是通过链表进行存储，每个节点只存储一个元素和两个指针，因此在存储大量元素时占用的内存空间相对较小。</p>
</li>
<li><p>插入、删除操作 由于<code>vector</code>采用连续的动态数组存储元素，因此在插入或者删除元素时需要移动其它元素，并且可能需要重新分配内存空间。而<code>list</code>则是通过链表进行存储，每个节点只需要修改指针即可进行插入或者删除操作。</p>
</li>
</ol>
<p>总之，<code>vector</code>和<code>list</code>是C++ STL中的常用容器，它们在存储数据时的内存分配方式不同，具有各自的优缺点。在使用时需要根据具体情况选择合适的容器，并结合实际场景进行性能分析和测试，以确保程序的高效运行。</p>
<h3 id="swap实现快速删除"><a href="#swap实现快速删除" class="headerlink" title="swap实现快速删除"></a>swap实现快速删除</h3><h3 id="vector和list区别"><a href="#vector和list区别" class="headerlink" title="vector和list区别"></a><code>vector</code>和list区别</h3><p>都是C++ STL（Standard Template Library）中的容器。它们在存储数据时的内存分配方式不同，具有以下几点区别：</p>
<ol>
<li><p>存储方式 <code>vector</code>采用连续的动态数组存储元素，因此在访问元素时可以随机访问，速度较快。而<code>list</code>采用双向链表存储元素，因此在访问元素时只能顺序访问，速度相对较慢。</p>
</li>
<li><p>内存分配 由于<code>vector</code>采用连续的动态数组存储元素，因此需要预分配一块连续的内存空间。当插入元素时，如果当前内存空间不足，则需要重新分配一块更大的内存空间，并将原有元素复制到新的内存空间中。而<code>list</code>则是通过链表进行存储，每个节点存储一个元素，因此在插入或者删除元素时，只需要修改相应的链表指针即可。</p>
</li>
<li><p>内存占用 由于<code>vector</code>需要预分配一段连续的内存空间，因此在存储大量元素时可能会浪费一定的内存空间。而<code>list</code>则是通过链表进行存储，每个节点只存储一个元素和两个指针，因此在存储大量元素时占用的内存空间相对较小。</p>
</li>
<li><p>插入、删除操作 由于<code>vector</code>采用连续的动态数组存储元素，因此在插入或者删除元素时需要移动其它元素，并且可能需要重新分配内存空间。而<code>list</code>则是通过链表进行存储，每个节点只需要修改指针即可进行插入或者删除操作。</p>
</li>
</ol>
<p>总之，<code>vector</code>和<code>list</code>是C++ STL中的常用容器，它们在存储数据时的内存分配方式不同，具有各自的优缺点。在使用时需要根据具体情况选择合适的容器，并结合实际场景进行性能分析和测试，以确保程序的高效运行。</p>
<ul>
<li><p>map实现，map.find时间复杂度</p>
</li>
<li><p>gdb的使用， 如何调试多线程</p>
</li>
<li><p>浅拷贝、深拷贝，如何通过自定义拷贝构造函数实现深拷贝</p>
</li>
<li><p>map、unorder_map区别，了解使用场景</p>
</li>
<li><p>new、delete过程，继承情况下调用顺序</p>
</li>
<li><p>全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？<br>  <code>  可以，在不同的C文件中以static形式来声明同名全局变量。可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错.  </code></p>
</li>
<li><p>static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？Static函数与普通函数有什么区别？<br>  <code>  (1)把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。    全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。(2)把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。(3)static函数与普通函数作用域不同,仅在本文件。    综上所述:     static全局变量与普通的全局变量有什么区别：    static全局变量只初使化一次，防止在其他文件单元中被引用;    static局部变量和普通局部变量有什么区别：    static局部变量只被初始化一次，下一次依据上一次结果值；    static函数与普通函数有什么区别：    static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝  </code></p>
</li>
<li><p>以下代码存在的问题？<br>  <code>  char string[] = “Linux C”;   char *p = “Linux C”;   string[0] = &#39;a&#39;;   p[0] = &#39;a&#39;;   注：”Linux C”是一个字符串常量。C语言对于字符串常量通常是这样处理的：在内存中开辟一个字符数组来存储该字符串常量，并把开辟出的字符数组的首地址赋给p.   注：string[0] = ‘a’是可以的，而p[0] = ‘a’是非法的，因为p指向的是字符串常量，常量的内容不可改变。把p指向一个字符串常量或字符数组时合法的，例如：p = “Hello World!”; p= string;</code></p>
</li>
<li><p>什么函数不能声明为虚函数？<br>  <code>构造函数</code></p>
</li>
<li><p>不能做switch()的参数类型<br>  <code>switch的参数不能为实型。</code></p>
</li>
<li><p>如何引用一个已经定义过的全局变量？<br>  <code>可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变量，假定你将那个变量写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。</code></p>
</li>
<li><p>C++中虚函数的意义<br>  &#96;&#96;<br>  C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数；在派生类中对基类定义的虚函数进行重写时，需要再派生类中声明该方法为虚方法。当子类重新定义了父类的虚函数后，当父类的指针指向子类对象的地址时，[即B b; A a &#x3D; &amp;b;] 父类指针根据赋给它的不同子类指针，动态的调用子类的该函数，而不是父类的函数（如果不使用virtual方法，请看后面★*），且这样的函数调用发生在运行阶段，而不是发生在编译阶段，称为动态联编。而函数的重载可以认为是多态，只不过是静态的。注意，非虚函数静态联编，效率要比虚函数高，但是不具备动态联编能力。</p>
<p>  如果使用了virtual关键字，程序将根据引用或指针指向的 对 象 类 型 来选择方法，否则使用引用类型或指针类型来选择方法。<br>  编译器处理虚函数的方法是：为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，称为虚表指针（vptr），这种数组成为虚函数表（virtual function table, vtbl），即，每个类使用一个虚函数表，每个类对象用一个虚表指针。<br>  举个例子：基类对象包含一个虚表指针，指向基类中所有虚函数的地址表。派生类对象也将包含一个虚表指针，指向派生类虚函数表。看下面两种情况：<br>  如果派生类重写了基类的虚方法，该派生类虚函数表将保存重写的虚函数的地址，而不是基类的虚函数地址。<br>  如果基类中的虚方法没有在派生类中重写，那么派生类将继承基类中的虚方法，而且派生类中虚函数表将保存基类中未被重写的虚函数的地址。注意，如果派生类中定义了新的虚方法，则该虚函数的地址也将被添加到派生类虚函数表中。</p>
<p>  &#96;&#96;</p>
</li>
<li><p>参见《Effective C++》 条款09：绝不在构造函数或析构函数中调用虚函数。<br>  <code>原因分析：１.　从语法上讲，调用完全没有问题。２.　但是从效果上看，往往不能达到需要的目的。Effective 的解释是：派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。同样，进入基类析构函数时，对象也是基类类型。所以，虚函数始终仅仅调用基类的虚函数（如果是基类调用虚函数），不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果。</code></p>
</li>
<li><p>一个C++对象的大小由哪些因素决定？基类，成员，内存对齐，虚函数。</p>
</li>
<li><p>C++对象的成员函数对对象大小有什么影响？是否有虚函数，虚函数的个数多少对对象大小有什么影响？</p>
</li>
<li><p>一个C++对象的初始化顺序是什么？</p>
</li>
<li><p>虚析构函数有什么用途？</p>
</li>
<li><p>new operator和operator new什么区别和联系？</p>
</li>
<li><p>什么是placement new？</p>
</li>
<li><p>STL迭代器按照支持的操作分为哪几类？</p>
</li>
<li><p>Map和UnorderedMap的主要区别是什么？如何选择？</p>
</li>
<li><p>UnorderedMap如何解决Hash冲突？</p>
</li>
<li><p>Deque和Vector有什么区别？</p>
</li>
<li><p>什么是RAII机制？</p>
</li>
<li><p>在C++中，如何避免内存泄漏？</p>
</li>
<li><p>智能指针有哪些？什么用途？</p>
</li>
</ul>
<p>面试问题</p>
<p>1）TCP&#x2F;IP协议<br>    1）三次握手&#x2F;四次挥手过程<br>    2）TIME_WAIT状态<br>        1）主动关闭&#x2F;被动关闭<br>        2）需要的原因<br>        3）缓解措施<br>        4）有没有方式不出现TIME_WAIT状态<br>    3）RST出现的场景<br>    4）滑动窗口<br>2）网络编程<br>    1）EPOLL&#x2F;SELECT的区别<br>    2）边沿触发&#x2F;水平触发<br>    3）事件触发的场景<br>        1）读事件 有哪些场景<br>        2）写事件 有哪些场景<br>    4）READ调用返回值场景<br>        1）0<br>        2）-1<br>        3）&gt;0<br>    5）UDP客户端可以CONNECT不，那CONNECT和不CONNECT有啥区别<br>3）后台编程<br>    1）FORK的用途，FORK区分父子进程方式<br>    2）进程间通信方式<br>    3）僵尸进程<br>    4）内存模型，有哪些段构成<br>    5）进程&#x2F;线程&#x2F;协程的区别<br>4）常见中间件<br>    1）MYSQL<br>        1）为啥不建议SELECT *<br>        2）覆盖索引<br>        3）分页优化<br>    2）ZOOKEEPER<br>        1）有哪些WATCH以及对应唤醒事件<br>    3）KAFKA<br>        1）分区分服<br>        2）生产者<br>        3）消费者<br>5）语言<br>    1）JAVA语言<br>        1）内存管理<br>6）设计模式<br>    1）单例模式<br>7）项目中的难点、挑战点</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-08-15T09:50:31.526Z" title="2024/8/15 17:50:31">2024-08-15</time>发表</span><span class="level-item"><time dateTime="2024-08-16T02:52:23.826Z" title="2024/8/16 10:52:23">2024-08-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/100-CodingSkills/">100_CodingSkills</a><span> / </span><a class="link-muted" href="/categories/100-CodingSkills/105-Python/">105_Python</a><span> / </span><a class="link-muted" href="/categories/100-CodingSkills/105-Python/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/">数据挖掘</a></span><span class="level-item">6 分钟读完 (大约881个字)</span></div></div><div class="content"><h1 id="数据挖掘-2"><a href="#数据挖掘-2" class="headerlink" title="数据挖掘 2"></a>数据挖掘 2</h1><h2 id="四大块"><a href="#四大块" class="headerlink" title="四大块"></a>四大块</h2><p><img src="/../../../../images/data_dig.jpg" alt="image-20210908195234323"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44623752/article/details/118975075">https://blog.csdn.net/weixin_44623752/article/details/118975075</a></p>
<p>1，给定一个样本特征 , 我们希望预测其对应的属性值 , 如果 是离散的, 那么这就是一个分类问题，反之，如果 是连续的实数, 这就是一个回归问题。<br>2，如果给定一组样本特征 , 我们没有对应的属性值 , 而是想发掘这组样本在 二维空间的分布, 比如分析哪些样本靠的更近，哪些样本之间离得很远, 这就是属于聚类问题。<br>3，如果我们想用维数更低的子空间来表示原来高维的特征空间, 那么这就是降维问题。</p>
<p>无论是分类还是回归，都是想建立一个预测模型 ，给定一个输入 , 可以得到一个输出，<strong>不同的只是在分类问题中,</strong> <strong>是离散的; 而在回归问题中</strong> <strong>是连续的</strong></p>
<h2 id="分类-classification"><a href="#分类-classification" class="headerlink" title="分类 classification"></a>分类 classification</h2><p>有监督学习的两大应用之一，产生离散的结果</p>
<p><strong>分类问题最常用的学习算法包括 SVM (支持向量机) , SGD (随机梯度下降算法), Bayes (贝叶斯估计), Ensemble, KNN 等。</strong>而<strong>回归问题也能使用 SVR, SGD, Ensemble 等算</strong>法，以及其它线性回归算法。</p>
<p>例如向模型输入人的各种数据的训练样本，产生“输入一个人的数据，判断是否患有癌症”的结果，结果必定是离散的，只有“是”或“否”。（即有目标和标签，能判断目标特征是属于哪一个类型）</p>
<h2 id="回归-regression"><a href="#回归-regression" class="headerlink" title="回归 regression"></a>回归 regression</h2><p>有监督学习的两大应用之一，产生连续的结果。</p>
<p>例如向模型输入人的各种数据的训练样本，产生“输入一个人的数据，判断此人20年后今后的经济能力”的结果，结果是连续的，往往得到一条回归曲线。当输入自变量不同时，输出的因变量非离散分布（不仅仅是一条线性直线，多项曲线也是回归曲线）。<br>classification &amp; regression：分类与回归</p>
<h2 id="聚类-clustering"><a href="#聚类-clustering" class="headerlink" title="聚类 clustering"></a>聚类 clustering</h2><p>聚类也是分析样本的属性, 有点类似classification, 不同的就是classification 在预测之前是知道  的范围, 或者说知道到底有几个类别, 而聚类是不知道属性的范围的。所以 classification 也常常被称为 supervised learning, 而clustering就被称为unsupervised learning。<br>clustering 事先不知道样本的属性范围，只能凭借样本在特征空间的分布来分析样本的属性。这种问题一般更复杂。而常用的算法包括 k-means (K-均值), GMM (高斯混合模型) 等。</p>
<p>无监督学习的结果。聚类的结果将产生一组集合，集合中的对象与同集合中的对象彼此相似，与其他集合中的对象相异。</p>
<h2 id="降维-dimensionality-reduction"><a href="#降维-dimensionality-reduction" class="headerlink" title="降维 dimensionality reduction"></a>降维 dimensionality reduction</h2><p>降维是机器学习另一个重要的领域, 降维有很多重要的应用, **特征的维数过高, 会增加训练的负担与存储空间, 降维就是希望去除特征的冗余, 用更加少的维数来表示特征.**降维算法最基础的就是PCA了, 后面的很多算法都是以PCA为基础演化而来。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-08-15T09:50:31.524Z" title="2024/8/15 17:50:31">2024-08-15</time>发表</span><span class="level-item"><time dateTime="2024-08-15T09:50:43.445Z" title="2024/8/15 17:50:43">2024-08-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/100-CodingSkills/">100_CodingSkills</a><span> / </span><a class="link-muted" href="/categories/100-CodingSkills/105-Python/">105_Python</a></span><span class="level-item">4 分钟读完 (大约626个字)</span></div></div><div class="content"><h1 id="CentOS7-安装Python3"><a href="#CentOS7-安装Python3" class="headerlink" title="CentOS7 安装Python3"></a>CentOS7 安装Python3</h1><hr>
<p><strong>本文主要介绍在CentOS7上通过源码编译的方式案头Python3, 文中用到的是CentOS7.2, Python版本是3.6.7,其他类似版本的处理也是大致相同的.</strong></p>
<p>在安装Python3之前需要解决两个问题：</p>
<ul>
<li><strong>一是 开发环境安装，比如gcc等</strong></li>
<li><strong>二是 openssl的安装， 因为CentOS自带的openssl版本比较低，导致Python3安装完后，在python命令行中执行import ssl会报错：ImportError: No module named _ssl。</strong></li>
</ul>
<p>特别是第二个ssl错误，相信很多人都遇到过，我自己也在这个问题上纠缠了很长时间， 现在将亲测有效的解决方案分享给大家。</p>
<h2 id="1-安装开发环境依赖"><a href="#1-安装开发环境依赖" class="headerlink" title="1.安装开发环境依赖"></a>1.安装开发环境依赖</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y groupinstall development</span><br><span class="line">sudo yum -y install zlib-devel</span><br><span class="line">sudo yum -y install libffi-devel</span><br></pre></td></tr></table></figure>

<h2 id="2-更新openssl"><a href="#2-更新openssl" class="headerlink" title="2.更新openssl"></a>2.更新openssl</h2><p>先通过命令看看筷的openssl版本，如果返回是0.9.x， 那肯定需要升级了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl version</span><br></pre></td></tr></table></figure>
<p>按照如下方式升级openssl</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.openssl.org/source/openssl-1.0.2e.tar.gz</span><br><span class="line">tar xvzf openssl-1.0.2e.tar.gz</span><br><span class="line">cd openssl-1.0.2e</span><br><span class="line">./config --prefix=/usr/local/openssl --openssldir=/usr/local/openssl</span><br><span class="line">make</span><br><span class="line">make test</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>到这openssl安装完成了， 接下来可以开始编译安装Python3了， 注意我们指定的openssl安装路径是在&#x2F;usr&#x2F;local&#x2F;openssl， 这个后面要用到。</p>
<h2 id="3-安装Python3"><a href="#3-安装Python3" class="headerlink" title="3.安装Python3"></a>3.安装Python3</h2><ul>
<li><p>先下载解压Python3.6.7安装包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.python.org/ftp/python/3.6.7/Python-3.6.7.tgz</span><br><span class="line">tar xvzf Python-3.6.7.tgz</span><br><span class="line">cd Python-3.6.7</span><br></pre></td></tr></table></figure></li>
<li><p>然后修改Setup.dist, 指定ssl位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi Modules/Setup.dist</span><br></pre></td></tr></table></figure>
<p>搜索ssl, 取消以下几行注释， 并且修改SSL的值为我们实际安装openssl的值， 即：&#x2F;usr&#x2F;local&#x2F;openssl</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_socket socketmodule.c</span><br><span class="line"></span><br><span class="line"># Socket module helper for SSL support; you must comment out the other</span><br><span class="line"># socket line above, and possibly edit the SSL variable:</span><br><span class="line">SSL=/usr/local/openssl</span><br><span class="line">_ssl _ssl.c \</span><br><span class="line"> -DUSE_SSL -I$(SSL)/include -I$(SSL)/include/openssl \</span><br><span class="line"> -L$(SSL)/lib -lssl -lcrypto</span><br></pre></td></tr></table></figure>
<p><em>注： 网上很多说在.&#x2F;configure 后面加–with-openssl的方法来指定openssl的方法自测无效， 通过修改Setup.dist方才生效。</em></p>
</li>
<li><p>完成以上修改后，即可开始编译Python3, 命令如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-验证Python3"><a href="#4-验证Python3" class="headerlink" title="4.验证Python3"></a>4.验证Python3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3</span><br><span class="line">import ssl</span><br></pre></td></tr></table></figure>

<p>正常不会报错， 则Python3安装成功。<br>另外，给大家推荐一个Python虚拟环境的包pipenv, 强大又好用， 大家可以试试。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install pipenv</span><br></pre></td></tr></table></figure>

<p>至此，CentOS7上安装Python3完毕。<br>这个是我参考的文章，感谢前人的分享！<a target="_blank" rel="noopener" href="https://techglimpse.com/install-python-openssl-support-tutorial/#check-python-for-openssl-support">How to Compile and Install Python with OpenSSL Support?</a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">上一页</a></div><div class="pagination-next"><a href="/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/5/">5</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="Amazing Coder"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Amazing Coder</p><p class="is-size-6 is-block">A programmer who loves coding and life.</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Xi&#039;an China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">45</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">7</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/amazingcoderpro/" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/amazingcoderpro/"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/100-CodingSkills/"><span class="level-start"><span class="level-item">100_CodingSkills</span></span><span class="level-end"><span class="level-item tag">24</span></span></a><ul><li><a class="level is-mobile" href="/categories/100-CodingSkills/101-Basic/"><span class="level-start"><span class="level-item">101_Basic</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/100-CodingSkills/102-Architecture/"><span class="level-start"><span class="level-item">102_Architecture</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/100-CodingSkills/103-Productivity/"><span class="level-start"><span class="level-item">103_ Productivity</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/100-CodingSkills/104-MiddleWare/"><span class="level-start"><span class="level-item">104_MiddleWare</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/100-CodingSkills/105-Python/"><span class="level-start"><span class="level-item">105_Python</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/100-CodingSkills/105-Python/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"><span class="level-start"><span class="level-item">数据挖掘</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/100-CodingSkills/106-Cpp/"><span class="level-start"><span class="level-item">106_Cpp</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/100-CodingSkills/107-Network/"><span class="level-start"><span class="level-item">107_Network</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/100-CodingSkills/108-Coding/"><span class="level-start"><span class="level-item">108_Coding</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/200-SoftSkills/"><span class="level-start"><span class="level-item">200_SoftSkills</span></span><span class="level-end"><span class="level-item tag">15</span></span></a><ul><li><a class="level is-mobile" href="/categories/200-SoftSkills/Trade/"><span class="level-start"><span class="level-item">Trade</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/200-SoftSkills/%E8%AF%BB%E4%B9%A6%E5%8D%A1/"><span class="level-start"><span class="level-item">读书卡</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/300-Sinology/"><span class="level-start"><span class="level-item">300_Sinology</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/TAG1/"><span class="tag">TAG1</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TAG2/"><span class="tag">TAG2</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cs/"><span class="tag">cs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/interview/"><span class="tag">interview</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/os/"><span class="tag">os</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9F%BA%E7%A1%80/"><span class="tag">基础</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-08-15T12:14:36.000Z">2024-08-15</time></p><p class="title"><a href="/2024/08/15/hideabcabcef-md/">_hideabcabcef.md</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-08-15T12:13:54.000Z">2024-08-15</time></p><p class="title"><a href="/2024/08/15/abcabcef-md/">abcabcef.md</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-08-15T09:50:31.529Z">2024-08-15</time></p><p class="title"><a href="/2024/08/15/100-CodingSkills-107-Network-20220814-%E7%BD%91%E7%BB%9C%E4%BF%AE%E7%82%BC-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"> </a></p><p class="categories"><a href="/categories/100-CodingSkills/">100_CodingSkills</a> / <a href="/categories/100-CodingSkills/107-Network/">107_Network</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-08-15T09:50:31.529Z">2024-08-15</time></p><p class="title"><a href="/2024/08/15/100-CodingSkills-108-Coding-00-CodingInterview/"> </a></p><p class="categories"><a href="/categories/100-CodingSkills/">100_CodingSkills</a> / <a href="/categories/100-CodingSkills/108-Coding/">108_Coding</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-08-15T09:50:31.528Z">2024-08-15</time></p><p class="title"><a href="/2024/08/15/100-CodingSkills-107-Network-202201-Linux%E7%BD%91%E7%BB%9C%E8%B0%83%E4%BC%98/"> </a></p><p class="categories"><a href="/categories/100-CodingSkills/">100_CodingSkills</a> / <a href="/categories/100-CodingSkills/107-Network/">107_Network</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/08/"><span class="level-start"><span class="level-item">八月 2024</span></span><span class="level-end"><span class="level-item tag">25</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/01/"><span class="level-start"><span class="level-item">一月 2024</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/10/"><span class="level-start"><span class="level-item">十月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Amazing Coder" height="28"></a><p class="is-size-7"><span>&copy; 2024 小武哥</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/amazingcoderpro/"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>