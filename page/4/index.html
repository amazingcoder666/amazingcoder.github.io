<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Amazing Coder</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Amazing Coder"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Amazing Coder"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="A programmer who loves coding and life."><meta property="og:type" content="blog"><meta property="og:title" content="Amazing Coder"><meta property="og:url" content="http://amazingcoderxyz.github.io/"><meta property="og:site_name" content="Amazing Coder"><meta property="og:description" content="A programmer who loves coding and life."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://amazingcoderxyz.github.io/img/og_image.png"><meta property="article:author" content="小武哥"><meta property="article:tag" content="代码 国学 篮球 音乐 Python Cpp 协作 项目管理"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://amazingcoderxyz.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://amazingcoderxyz.github.io"},"headline":"Amazing Coder","image":["http://amazingcoderxyz.github.io/img/og_image.png"],"author":{"@type":"Person","name":"小武哥"},"publisher":{"@type":"Organization","name":"Amazing Coder","logo":{"@type":"ImageObject","url":"http://amazingcoderxyz.github.io/img/logo.svg"}},"description":"A programmer who loves coding and life."}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Amazing Coder" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/amazingcoderxyz/"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-26T09:35:22.715Z" title="1/26/2024, 5:35:22 PM">2024-01-26</time>发表</span><span class="level-item"><time dateTime="2024-01-31T07:48:49.725Z" title="1/31/2024, 3:48:49 PM">2024-01-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/100-CoderSkills/">100_CoderSkills</a><span> / </span><a class="link-muted" href="/categories/100-CoderSkills/106-Network/">106_Network</a></span><span class="level-item">3 小时读完 (大约28025个字)</span></div></div><div class="content"><hr>
<p>00_NetworkInterview<br>aliases:<br>tags: #cs#interview #network<br>date: 2023-10-08 15:29</p>
<hr>
<h1 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h1><h2 id="1-Basic-Concept"><a href="#1-Basic-Concept" class="headerlink" title="1. Basic Concept"></a>1. Basic Concept</h2><h3 id="TCP连接中间会有什么操作"><a href="#TCP连接中间会有什么操作" class="headerlink" title="TCP连接中间会有什么操作"></a>TCP连接中间会有什么操作</h3><p>在TCP连接中，客户端和服务器之间会进行以下操作：</p>
<ul>
<li><p>握手阶段：客户端向服务器发送SYN包（同步包），请求建立连接。服务器收到SYN包后，向客户端发送SYN+ACK包（同步确认包），表示可以建立连接。客户端收到SYN+ACK包后，再向服务器发送ACK包（确认包），表示连接建立成功。</p>
</li>
<li><p>数据传输阶段：连接建立成功后，客户端和服务器之间可以进行数据的传输。客户端向服务器发送数据包，服务器接收数据包并进行处理，然后向客户端发送响应包。客户端收到响应包后，可以再次向服务器发送数据包，以此类推。</p>
</li>
<li><p>断开连接阶段：当客户端或服务器不再需要连接时，可以发送FIN包（结束包）来请求断开连接。对方收到FIN包后，也发送FIN包进行响应，表示同意断开连接。当两端都收到对方的FIN包后，连接才真正关闭。</p>
</li>
</ul>
<p>需要注意的是，在TCP连接中可能会出现丢包、拥塞等情况，需要进行相应的处理，例如重传丢失的数据包、调整发送窗口大小等</p>
<h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><ul>
<li>TCP 三次握手中，客户端收到的第二次握手中 ack 确认号不是自己期望的，会发生什么？是直接丢弃 or 回 RST 报文？</li>
<li>什么情况下会收到不正确的 ack（第二次握手中的 ack） 呢？<br>不卖关子，直接说这个问题，是<strong>回 RST 报文</strong>。过程如下图：</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeRVaGLU0HSwicWshvgthyXukQSF6kevWWckbxxO3pOCgfYqSVl8H7icM0zFzWD6gjg5n0mI1ETeZew/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>三次握手避免历史连接</p>
<p>当客户端连续发送多次建立连接的 SYN 报文，然后在网络拥堵的情况，就会发生客户端收到不正确的 ack 的情况。具体过程如下：</p>
<ul>
<li><p>客户端先发送了 SYN（seq &#x3D; 90） 报文，但是被网络阻塞了，服务端并没有收到，接着客户端又重新发送了 SYN（seq &#x3D; 100） 报文，注意不是重传 SYN，重传的 SYN 的序列号是一样的。</p>
</li>
<li><p>「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端，那么此时服务端就会回一个 SYN + ACK 报文给客户端，此报文的确认号是 91（90+1）。</p>
</li>
<li><p>客户端收到后，发行自己期望收到的确认号应该是 100+1，而不是 90 + 1，于是就会回 RST 报文。</p>
</li>
<li><p>服务端收到 RST 报文后，就会中止连接。</p>
</li>
<li><p>后续最新的 SYN 抵达了服务端后，客户端与服务端就可以正常的完成三次握手了。</p>
</li>
</ul>
<p>上述中的「旧 SYN 报文」称为历史连接，TCP 使用三次握手建立连接的<strong>最主要原因就是防止「历史连接」初始化了连接</strong>。</p>
<p>我们也可以从 RFC 793 知道 TCP 连接使用三次握手的首要原因：</p>
<p><em>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</em></p>
<p>简单来说，三次握手的首要原因是为了防止旧的重复连接初始化造成混乱。RFC 给出的三次握手防止历史连接的案例图如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeRVaGLU0HSwicWshvgthyXulbVmhSyuhoYJicsSqqzlLicN8vibzkAZB3WoAw0cCYE990DtCZckUXdwQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>RFC 793</p>
<p>如果是两次握手连接，就无法阻止历史连接，那<strong>为什么 TCP 两次握手为什么无法阻止历史连接呢？</strong></p>
<p>我先直接说结论，主要是因为<strong>在两次握手的情况下，「被动发起方」没有中间状态给「主动发起方」来阻止历史连接，导致「被动发起方」可能建立一个历史连接，造成资源浪费</strong>。</p>
<p>你想想，两次握手的情况下，「被动发起方」在收到 SYN 报文后，就进入 ESTABLISHED 状态，意味着这时可以给对方发送数据给，但是「主动发」起方此时还没有进入 ESTABLISHED 状态，假设这次是历史连接，主动发起方判断到此次连接为历史连接，那么就会回 RST 报文来断开连接，而「被动发起方」在第一次握手的时候就进入 ESTABLISHED 状态，所以它可以发送数据的，但是它并不知道这个是历史连接，它只有在收到 RST 报文后，才会断开连接。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeRVaGLU0HSwicWshvgthyXuHS7B2sADweWDX3rVH109Hqdw5fbYbJMetYTT3xEicicBrYiaSm7KYnPfg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>两次握手无法阻止历史连接</p>
<p>可以看到，上面这种场景下，「被动发起方」在向「主动发起方」发送数据前，并没有阻止掉历史连接，导致「被动发起方」建立了一个历史连接，又白白发送了数据，妥妥地浪费了「被动发起方」的资源。</p>
<p>因此，<strong>要解决这种现象，最好就是在「被动发起方」发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手</strong>。</p>
<p>我说回 RST 就回 RST 吗？当然不是了，肯定得用源码证明我说的这个结论。</p>
<p>听到要源码分析，可能有的同学就怂了。</p>
<p>其实要分析我们今天这个问题，只要懂 if else 就行了，我也会用中文来表述代码的逻辑，所以单纯看我的文字也是可以的。</p>
<p>这次我们重点分析的是，在 SYN_SENT 状态下，收到不正确的确认号的 syn+ack 报文是如何处理的。</p>
<p>处于 SYN_SENT 状态下的客户端，在收到服务端的  syn+ack 报文后，最终会调用  tcp_rcv_state_process，在这里会根据 TCP 状态做对应的处理，这里我们只关注 SYN_SENT 状态。</p>
<p><code>// net/ipv4/tcp_ipv4.c   int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb)   &#123;    ...         int queued = 0;          ...         switch (sk-&gt;sk_state) &#123;    case TCP_CLOSE:     ...    case TCP_LISTEN:     ...    case TCP_SYN_SENT:       ....     queued = tcp_rcv_synsent_state_process(sk, skb, th);     if (queued &gt;= 0)      return queued;       ...    &#125;   </code></p>
<p>可以看到，接下来，会继续调用 tcp_rcv_synsent_state_process 函数。</p>
<p><code>static int tcp_rcv_synsent_state_process(struct sock *sk, struct sk_buff *skb,         const struct tcphdr *th)   &#123;    ....       if (th-&gt;ack) &#123;     /* rfc793:      * &quot;If the state is SYN-SENT then      *    first check the ACK bit      *      If the ACK bit is set      *   If SEG.ACK =&lt; ISS, or SEG.ACK &gt; SND.NXT, send      *        a reset (unless the RST bit is set, if so drop      *        the segment and return)&quot;      */       // ack 的确认号不是预期的     if (!after(TCP_SKB_CB(skb)-&gt;ack_seq, tp-&gt;snd_una) ||         after(TCP_SKB_CB(skb)-&gt;ack_seq, tp-&gt;snd_nxt))         //回 RST 报文      goto reset_and_undo;        ...   &#125;      </code></p>
<p>从上面的函数，就可以得知了，客户端在 SYN_SENT 状态下，收到不正确的确认号的 syn+ack 报文会回 RST 报文。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><blockquote>
<p>TCP 三次握手中，客户端收到的第二次握手中 ack 确认号不是自己期望的，会发生什么？是直接丢弃 or 回 RST 报文？</p>
</blockquote>
<p>回 RST 报文。</p>
<blockquote>
<p>什么情况下会收到不正确的 ack（第二次握手中的 ack） 呢？</p>
</blockquote>
<p>当客户端发起多次 SYN 报文，然后网络拥堵的情况下，「旧的 SYN 报文」比「新的 SYN 报文」早抵达服务端，此时服务端就会按照收到的「旧的 SYN 报文」回复 syn+ack 报文，而此报文的确认号并不是客户端期望收到的，于是客户端就会回 RST 报文。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>虽然我们在学习 TCP 挥手时，学到的是需要四次来完成 TCP 挥手，但是<strong>在一些情况下， TCP 四次挥手是可以变成 TCP 三次挥手的</strong>。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtq0WaxOzTFbA8SQ5Am8ibRL1JMdq5GibqVeXYWOXB3gtdHAMwic01mMAOSw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>而且在用 wireshark 工具抓包的时候，我们也会常看到 TCP 挥手过程是三次，而不是四次，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqh59jUuDV016elb1Z9Hn0GwfCuDdZbqm1cAn3Pf8FI7RSyficSXgT8Qg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>先来回答为什么 RFC 文档里定义 TCP 挥手过程是要四次？</p>
<p>再来回答什么情况下，什么情况会出现三次挥手？</p>
<h4 id="为什么-TCP-挥手需要四次？"><a href="#为什么-TCP-挥手需要四次？" class="headerlink" title="为什么 TCP 挥手需要四次？"></a>为什么 TCP 挥手需要四次？</h4><p>TCP 四次挥手的过程如下：<br>![[Pasted image 20230518120138.png]]</p>
<p>具体过程：</p>
<ul>
<li><p>客户端主动调用关闭连接的函数，于是就会发送 FIN 报文，这个  FIN 报文代表客户端不会再发送数据了，进入 FIN_WAIT_1 状态；</p>
</li>
<li><p>服务端收到了 FIN 报文，然后马上回复一个 ACK 确认报文，此时服务端进入 CLOSE_WAIT 状态。在收到 FIN 报文的时候，TCP 协议栈会为 FIN 包插入一个文件结束符 EOF 到接收缓冲区中，服务端应用程序可以通过 read 调用来感知这个 FIN 包，这个 EOF 会被<strong>放在已排队等候的其他已接收的数据之后</strong>，所以必须要得继续 read 接收缓冲区已接收的数据；</p>
</li>
<li><p>接着，当服务端在 read 数据的时候，最后自然就会读到 EOF，接着 <strong>read() 就会返回 0，这时服务端应用程序如果有数据要发送的话，就发完数据后才调用关闭连接的函数，如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数</strong>，这时服务端就会发一个 FIN 包，这个  FIN 报文代表服务端不会再发送数据了，之后处于 LAST_ACK 状态；</p>
</li>
<li><p>客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进入 TIME_WAIT 状态；</p>
</li>
<li><p>服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态；</p>
</li>
<li><p>客户端经过 2MSL 时间之后，也进入 CLOSE 状态；</p>
</li>
</ul>
<p>你可以看到，每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。</p>
<h4 id="为什么-TCP-挥手需要四次呢？"><a href="#为什么-TCP-挥手需要四次呢？" class="headerlink" title="为什么 TCP 挥手需要四次呢？"></a>为什么 TCP 挥手需要四次呢？</h4><p>服务器收到客户端的 FIN 报文时，内核会马上回一个 ACK 应答报文，<strong>但是服务端应用程序可能还有数据要发送，所以并不能马上发送 FIN 报文，而是将发送 FIN 报文的控制权交给服务端应用程序</strong>：</p>
<ul>
<li><p>如果服务端应用程序有数据要发送的话，就发完数据后，才调用关闭连接的函数；</p>
</li>
<li><p>如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数，</p>
</li>
</ul>
<p>从上面过程可知，<strong>是否要发送第三次挥手的控制权不在内核，而是在被动关闭方（上图的服务端）的应用程序，因为应用程序可能还有数据要发送，由应用程序决定什么时候调用关闭连接的函数，当调用了关闭连接的函数，内核就会发送 FIN 报文了，</strong>所以服务端的 ACK 和 FIN 一般都会分开发送。</p>
<blockquote>
<p>FIN 报文一定得调用关闭连接的函数，才会发送吗？</p>
</blockquote>
<p>不一定。</p>
<p>如果进程退出了，不管是不是正常退出，还是异常退出（如进程崩溃），内核都会发送 FIN 报文，与对方完成四次挥手。</p>
<h4 id="粗暴关闭-vs-优雅关闭"><a href="#粗暴关闭-vs-优雅关闭" class="headerlink" title="粗暴关闭 vs 优雅关闭"></a>粗暴关闭 vs 优雅关闭</h4><p>前面介绍 TCP 四次挥手的时候，并没有详细介绍关闭连接的函数，其实关闭的连接的函数有两种函数：</p>
<ul>
<li><p>close 函数，同时 socket 关闭发送方向和读取方向，也就是 socket 不再有发送和接收数据的能力。如果有多进程&#x2F;多线程共享同一个 socket，如果有一个进程调用了 close 关闭只是让 socket 引用计数 -1，并不会导致 socket 不可用，同时也不会发出 FIN 报文，其他进程还是可以正常读写该 socket，直到引用计数变为 0，才会发出 FIN 报文。</p>
</li>
<li><p>shutdown 函数，可以指定 socket 只关闭发送方向而不关闭读取方向，也就是 socket 不再有发送数据的能力，但是还是具有接收数据的能力。如果有多进程&#x2F;多线程共享同一个 socket，shutdown 则不管引用计数，直接使得该 socket 不可用，然后发出 FIN 报文，如果有别的进程企图使用该 socket，将会受到影响。</p>
</li>
</ul>
<p>如果客户端是用 close 函数来关闭连接，那么在 TCP 四次挥手过程中，如果收到了服务端发送的数据，由于客户端已经不再具有发送和接收数据的能力，所以客户端的内核会回 RST 报文给服务端，然后内核会释放连接，这时就不会经历完成的 TCP 四次挥手，所以我们常说，调用 close 是粗暴的关闭。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqTKiaCezviad9jEJ6laX7YTvmNr0CNBAeFq1ibFtDo8daKnLoiaZf86QXdg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>当服务端收到 RST 后，内核就会释放连接，当服务端应用程序再次发起读操作或者写操作时，就能感知到连接已经被释放了：</p>
<ul>
<li><p>如果是读操作，则会返回 RST 的报错，也就是我们常见的Connection reset by peer。</p>
</li>
<li><p>如果是写操作，那么程序会产生 SIGPIPE 信号，应用层代码可以捕获并处理信号，如果不处理，则默认情况下进程会终止，异常退出。</p>
</li>
</ul>
<p>相对的，shutdown 函数因为可以指定只关闭发送方向而不关闭读取方向，所以即使在 TCP 四次挥手过程中，如果收到了服务端发送的数据，客户端也是可以正常读取到该数据的，然后就会经历完整的 TCP 四次挥手，所以我们常说，调用 shutdown 是优雅的关闭。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqjibEsjHAFttJCMw712anZwKVHb6YNvqNjib3Vy9pHQOmeibVYjDNfEnAw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>但是注意，shutdown 函数也可以指定「只关闭读取方向，而不关闭发送方向」，但是这时候内核是不会发送 FIN 报文的，因为发送 FIN 报文是意味着我方将不再发送任何数据，而 <strong>shutdown 如果指定「不关闭发送方向」，就意味着 socket 还有发送数据的能力，所以内核就不会发送 FIN</strong>。</p>
<h4 id="什么情况会出现三次挥手？"><a href="#什么情况会出现三次挥手？" class="headerlink" title="什么情况会出现三次挥手？"></a>什么情况会出现三次挥手？</h4><p>当被动关闭方（上图的服务端）在 TCP 挥手过程中，「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtq0WaxOzTFbA8SQ5Am8ibRL1JMdq5GibqVeXYWOXB3gtdHAMwic01mMAOSw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>然后因为 TCP 延迟确认机制是默认开启的，所以导致我们抓包时，看见三次挥手的次数比四次挥手还多。</p>
<blockquote>
<p>什么是  TCP 延迟确认机制？</p>
</blockquote>
<p>当发送没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文。</p>
<p>为了解决 ACK 传输效率低问题，所以就衍生出了 <strong>TCP 延迟确认</strong>。</p>
<p>TCP 延迟确认的策略：</p>
<ul>
<li><p>当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方</p>
</li>
<li><p>当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</p>
</li>
<li><p>如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK</p>
</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqoexLQeRzR1uwXIKrH3jJ9b0NNcrbxEKo7uvPp3eZLiafZkVfiaiaibVulg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>延迟等待的时间是在 Linux 内核中定义的，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqvkkq2d3h7qiaibwa8q3NghgrSVU48FFROd8ydmATAMAaMQpHiapicKTytw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>关键就需要 HZ 这个数值大小，HZ 是跟系统的时钟频率有关，每个操作系统都不一样，在我的 Linux 系统中 HZ 大小是 1000，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqJzGZ8BicbA81zRB4HzbGnFrxdC9tfsZSK1uj82ZPS52d74JTRMqG4Jg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>知道了 HZ 的大小，那么就可以算出：</p>
<ul>
<li><p>最大延迟确认时间是 200 ms （1000&#x2F;5）</p>
</li>
<li><p>最短延迟确认时间是 40 ms （1000&#x2F;25）</p>
</li>
</ul>
<blockquote>
<p>怎么关闭 TCP 延迟确认机制？</p>
</blockquote>
<p>如果要关闭 TCP 延迟确认机制，可以在 Socket 设置里启用 TCP_QUICKACK，启用 TCP_QUICKACK，就相当于关闭 TCP 延迟确认机制。</p>
<p>&#x2F;&#x2F; 1 表示开启 TCP_QUICKACK，即关闭 TCP 延迟确认机制<br>int value &#x3D; 1;<br>setsockopt(socketfd, IPPROTO_TCP, TCP_QUICKACK, (char*)&amp; value, sizeof(int));  </p>
<h4 id="实验验证"><a href="#实验验证" class="headerlink" title="实验验证"></a>实验验证</h4><h5 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h5><p>接下来，来给大家做个实验，验证这个结论：</p>
<blockquote>
<p>当被动关闭方（上图的服务端）在 TCP 挥手过程中，「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p>
</blockquote>
<p>服务端的代码如下，做的事情很简单，就读取数据，然后当 read 返回 0 的时候，就马上调用 close 关闭连接。因为 TCP 延迟确认机制是默认开启的，所以不需要特殊设置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;netdb.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;netinet/in.h&gt;  </span><br><span class="line">#include &lt;sys/socket.h&gt;  </span><br><span class="line">#include &lt;netinet/tcp.h&gt;  </span><br><span class="line">  </span><br><span class="line">#define MAXLINE 1024  </span><br><span class="line">  </span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line">    // 1. 创建一个监听 socket  </span><br><span class="line">    int listenfd = socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">    if(listenfd &lt; 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">        fprintf(stderr, &quot;socket error : %s\n&quot;, strerror(errno));  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 2. 初始化服务器地址和端口  </span><br><span class="line">    struct sockaddr_in server_addr;  </span><br><span class="line">    bzero(&amp;server_addr, sizeof(struct sockaddr_in));  </span><br><span class="line">    server_addr.sin_family = AF_INET;  </span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">    server_addr.sin_port = htons(8888);  </span><br><span class="line">  </span><br><span class="line">    // 3. 绑定地址+端口  </span><br><span class="line">    if(bind(listenfd, (struct sockaddr *)(&amp;server_addr), sizeof(struct sockaddr)) &lt; 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">        fprintf(stderr,&quot;bind error:%s\n&quot;, strerror(errno));  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;begin listen....\n&quot;);  </span><br><span class="line">  </span><br><span class="line">    // 4. 开始监听  </span><br><span class="line">    if(listen(listenfd, 128))  </span><br><span class="line">    &#123;  </span><br><span class="line">        fprintf(stderr, &quot;listen error:%s\n\a&quot;, strerror(errno));  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    // 5. 获取已连接的socket  </span><br><span class="line">    struct sockaddr_in client_addr;  </span><br><span class="line">    socklen_t client_addrlen = sizeof(client_addr);  </span><br><span class="line">    int clientfd = accept(listenfd, (struct sockaddr *)&amp;client_addr, &amp;client_addrlen);  </span><br><span class="line">    if(clientfd &lt; 0) &#123;  </span><br><span class="line">        fprintf(stderr, &quot;accept error:%s\n\a&quot;, strerror(errno));  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;accept success\n&quot;);  </span><br><span class="line">  </span><br><span class="line">    char message[MAXLINE] = &#123;0&#125;;  </span><br><span class="line">      </span><br><span class="line">    while(1) &#123;  </span><br><span class="line">        //6. 读取客户端发送的数据  </span><br><span class="line">        int n = read(clientfd, message, MAXLINE);  </span><br><span class="line">        if(n &lt; 0) &#123; // 读取错误  </span><br><span class="line">            fprintf(stderr, &quot;read error:%s\n\a&quot;, strerror(errno));  </span><br><span class="line">            break;  </span><br><span class="line">        &#125; else if(n == 0) &#123;  // 返回 0 ，代表读到 FIN 报文  </span><br><span class="line">            fprintf(stderr, &quot;client closed \n&quot;);  </span><br><span class="line">            close(clientfd); // 没有数据要发送，立马关闭连接  </span><br><span class="line">            break;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        message[n] = 0;   </span><br><span class="line">        printf(&quot;received %d bytes: %s\n&quot;, n, message);  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    close(listenfd);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<p>客户端代码如下，做的事情也很简单，与服务端连接成功后，就发送数据给服务端，然后睡眠一秒后，就调用 close 关闭连接，所以客户端是主动关闭方：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;netdb.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;netinet/in.h&gt;  </span><br><span class="line">#include &lt;sys/socket.h&gt;  </span><br><span class="line">  </span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line">    // 1. 创建一个监听 socket  </span><br><span class="line">    int connectfd = socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">    if(connectfd &lt; 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">        fprintf(stderr, &quot;socket error : %s\n&quot;, strerror(errno));  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 2. 初始化服务器地址和端口  </span><br><span class="line">    struct sockaddr_in server_addr;  </span><br><span class="line">    bzero(&amp;server_addr, sizeof(struct sockaddr_in));  </span><br><span class="line">    server_addr.sin_family = AF_INET;  </span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);  </span><br><span class="line">    server_addr.sin_port = htons(8888);  </span><br><span class="line">      </span><br><span class="line">    // 3. 连接服务器  </span><br><span class="line">    if(connect(connectfd, (struct sockaddr *)(&amp;server_addr), sizeof(server_addr)) &lt; 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">        fprintf(stderr,&quot;connect error:%s\n&quot;, strerror(errno));  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;connect success\n&quot;);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    char sendline[64] = &quot;hello, i am xiaolin&quot;;  </span><br><span class="line">  </span><br><span class="line">    //4. 发送数据  </span><br><span class="line">    int ret = send(connectfd, sendline, strlen(sendline), 0);  </span><br><span class="line">    if(ret != strlen(sendline)) &#123;  </span><br><span class="line">        fprintf(stderr,&quot;send data error:%s\n&quot;, strerror(errno));  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;already send %d bytes\n&quot;, ret);  </span><br><span class="line">  </span><br><span class="line">    sleep(1);  </span><br><span class="line">  </span><br><span class="line">    //5. 关闭连接  </span><br><span class="line">    close(connectfd);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>编译服务端和客户端的代码：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqXBTTjgQPl0KLGKMq7hAz9mod0RRYpjI9AXksu0CB1qmJDJN2aSMwPg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>先启用服务端：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqia1WLRBYhBiaU7XbDCHsGKWpIibs5WdibLJy6w0G9Oec7dqkw6cMpLKnoQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>然后用 tcpdump 工具开始抓包，命令如下：</p>
<p>tcpdump -i lo tcp and port 8888 -s0 -w &#x2F;home&#x2F;tcp_close.pcap  </p>
<p>然后启用客户端，可以看到，与服务端连接成功后，发完数据就退出了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqmnM7Byiagyo5RWxWm3LR58Zb4QdxDUQIJVa7S9GGfanHvlfTUzOBwKg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>此时，服务端的输出：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqSeF6vb50YiatBrEowxgAjYmgfy8liaL0TognAsrse1Dwm0u3GT7CENMw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>接下来，我们来看看抓包的结果。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtq48mB8VKryOjzdqyjjwy32kiakVBpvJPb1EdznqXfU2BicibY5mibccpbrA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>可以看到，TCP 挥手次数是 3 次。</p>
<p>所以，下面这个结论是没问题的。</p>
<blockquote>
<p>结论：当被动关闭方（上图的服务端）在 TCP 挥手过程中，「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制（默认会开启）」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p>
</blockquote>
<h5 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h5><p>我们再做一次实验，来看看<strong>关闭 TCP 延迟确认机制，会出现四次挥手吗？</strong></p>
<p>客户端代码保持不变，服务端代码需要增加一点东西。</p>
<p>在上面服务端代码中，增加了打开了 TCP_QUICKACK （快速应答）机制的代码，如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqS3Fia1ibn7iaKlicjzuPNeXibEPwKlzv9uJSsZ63RkzEOiadlLtMtic4loFXg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>编译好服务端代码后，就开始运行服务端和客户端的代码，同时用 tcpdump 进行抓包。</p>
<p>抓包的结果如下，可以看到是四次挥手。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqOQ7DhUPhZMcpfqkTHHh1XMUmic3od3mHibTwKTFgHhthltE0BxNdicAug/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>所以，当被动关闭方（上图的服务端）在 TCP 挥手过程中，「<strong>没有数据要发送」，同时「关闭了 TCP 延迟确认机制」，那么就会是四次挥手。</strong></p>
<blockquote>
<p>设置 TCP_QUICKACK 的代码，为什么要放在 read 返回 0 之后？</p>
</blockquote>
<p>我也是多次实验才发现，在 bind 之前设置 TCP_QUICKACK 是不生效的，只有在 read 返回 0 的时候，设置 TCP_QUICKACK 才会出现四次挥手。</p>
<p>网上查了下资料说，设置 TCP_QUICKACK 并不是永久的，所以每次读取数据的时候，如果想要立刻回 ACK，那就得在每次读取数据之后，重新设置 TCP_QUICKACK。</p>
<p>而我这里的实验，目的是为了当收到客户端的 FIN 报文（第一次挥手）后，立马回 ACK 报文，所以就在 read 返回 0 的时候，设置 TCP_QUICKACK。</p>
<p>当然，实际应用中，没人会在我这个位置设置 TCP_QUICKACK，因为操作系统都通过 TCP 延迟确认机制帮我们把四次挥手优化成了三次挥手了，这本来就是一件好事呀。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>当被动关闭方在 TCP 挥手过程中，如果「没有数据要发送」，同时「没有开启 TCP_QUICKACK（默认情况就是没有开启，没有开启 TCP_QUICKACK，等于就是在使用 TCP 延迟确认机制）」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</p>
<p><strong>所以，出现三次挥手现象，是因为 TCP 延迟确认机制导致的。</strong></p>
<h3 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h3><h3 id="TCP如何保证可靠性"><a href="#TCP如何保证可靠性" class="headerlink" title="TCP如何保证可靠性"></a>TCP如何保证可靠性</h3><h3 id="TCP-拆包沾包原因"><a href="#TCP-拆包沾包原因" class="headerlink" title="TCP 拆包沾包原因"></a>TCP 拆包沾包原因</h3><p>TCP 拆包和沾包现象是由于 TCP 协议的特性以及网络传输过程中的各种因素所导致的。<br>TCP 协议是基于字节流的传输层协议，没有固定的分包边界。发送方将数据分成多个小的数据包进行传输，接收方再将这些数据包组合成完整的数据。在这个过程中，可能会出现拆包和沾包现象。<br>网络传输中的延迟和拥塞会影响数据包发送的速度和到达接收方的顺序。这可能导致数据包的拆分和组合不规律，从而出现拆包和沾包现象。<br>接收方的缓冲区大小限制。当接收方的缓冲区不足以容纳一个完整的数据包时，可能会将数据包拆分成多个部分，导致拆包现象。<br>为了解决 TCP 拆包和沾包的问题，可以采用以下方法：<br>在应用层实现数据包的边界识别，例如通过添加包头，包头中包含数据包长度等信息，使得接收方能够准确地将数据包进行拼接。<br>使用固定长度的数据包或者特殊的分隔符，以便于接收方识别数据包的边界。<br>使用更高级的传输层协议，如 WebSocket，它在 TCP 基础上增加了数据帧的概念，可以更好地解决拆包和沾包问题。</p>
<h3 id="TCP粘包问题怎么解决"><a href="#TCP粘包问题怎么解决" class="headerlink" title="TCP粘包问题怎么解决"></a>TCP粘包问题怎么解决</h3><ul>
<li><p>答：特殊标记</p>
</li>
<li><p>追问：打断，如果使用特殊标记解决会遇到什么问题</p>
</li>
<li><p>答：正文转义字符</p>
</li>
</ul>
<p><strong>补充：</strong></p>
<p>1、固定长度的消息</p>
<p>这种是最简单方法，即每个用户消息都是固定长度的，比如规定一个消息的长度是 64 个字节，当接收方接满 64 个字节，就认为这个内容是一个完整且有效的消息。</p>
<p>但是这种方式灵活性不高，实际中很少用。</p>
<p>2、特殊字符作为边界</p>
<p>我们可以在两个用户消息之间插入一个特殊的字符串，这样接收方在接收数据时，读到了这个特殊字符，就把认为已经读完一个完整的消息。</p>
<p>HTTP 是一个非常好的例子。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeAuWVqVBTyJ8LzTIjpaUQ9QzbZBW2SaM2whfW9cXicKVPEw0Md73ibUf4BF1nOSqRW3dvpUA0e2oOQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>图片</p>
<p>HTTP 通过设置回车符、换行符作为 HTTP 报文协议的边界。</p>
<p>有一点要注意，这个作为边界点的特殊字符，如果刚好消息内容里有这个特殊字符，我们要对这个字符转义，避免被接收方当作消息的边界点而解析到无效的数据。</p>
<p>3、自定义消息结构</p>
<p>我们可以自定义一个消息结构，由包头和数据组成，其中包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大。</p>
<p>比如这个消息结构体，首先 4 个字节大小的变量来表示数据长度，真正的数据则在后面。</p>
<p><code>struct &#123;        u_int32_t message_length;        char message_data[];    &#125; message;   </code></p>
<p>当接收方接收到包头的大小（比如 4 个字节）后，就解析包头的内容，于是就可以知道数据的长度，然后接下来就继续读取数据，直到读满数据的长度，就可以组装成一个完整到用户消息来处理了。</p>
<h3 id="输入网址后发生了什么？"><a href="#输入网址后发生了什么？" class="headerlink" title="输入网址后发生了什么？"></a>输入网址后发生了什么？</h3><p>应用层 DNS 解析，传输层 TCP 连接，网络层 IP，数据链路 MAC，真实物理层，接收到之后再一层层扒皮。</p>
<h3 id="http报文长度判断"><a href="#http报文长度判断" class="headerlink" title="http报文长度判断"></a>http报文长度判断</h3><h3 id="udp为啥不可靠性。"><a href="#udp为啥不可靠性。" class="headerlink" title="udp为啥不可靠性。"></a>udp为啥不可靠性。</h3><h3 id="服务端挂了，客户端的-TCP-连接会发生什么？"><a href="#服务端挂了，客户端的-TCP-连接会发生什么？" class="headerlink" title="服务端挂了，客户端的 TCP 连接会发生什么？"></a>服务端挂了，客户端的 TCP 连接会发生什么？</h3><p>如果「服务端挂掉」指的是「<strong>服务端进程崩溃</strong>」，那么这个读者猜的想法是对的，服务端的进程在发生崩溃的时候，内核会发送 FIN 报文，与客户端进行四次挥手。</p>
<p>但是，如果「服务端挂掉」指的是「<strong>服务端主机宕机</strong>」，那么是不会发生四次挥手的，具体后续会发生什么？还要看客户端会不会发送数据？</p>
<ul>
<li><p>如果客户端会发送数据，由于服务端已经不存在，客户端的数据报文会超时重传，当重传次数达到一定阈值后，会断开 TCP 连接；</p>
</li>
<li><p>如果客户端一直不会发送数据，再看客户端有没有开启 TCP keepalive 机制？</p>
</li>
<li><p>如果有开启，客户端在一段时间后，检测到服务端的 TCP 连接已经不存在，则会断开自身的 TCP 连接；</p>
</li>
<li><p>如果没有开启，客户端的 TCP 连接会一直存在，并不会断开。</p>
</li>
</ul>
<h3 id="详细介绍一下TCP的四次挥手机制，为什么要有TIME-WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE-WAIT状态如何解决"><a href="#详细介绍一下TCP的四次挥手机制，为什么要有TIME-WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE-WAIT状态如何解决" class="headerlink" title="详细介绍一下TCP的四次挥手机制，为什么要有TIME_WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE_WAIT状态如何解决"></a>详细介绍一下TCP的四次挥手机制，为什么要有TIME_WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE_WAIT状态如何解决</h3><p>当客户端要服务器断开连接时，客户端 TCP 会向服务器发送一个特殊的报文段，该报文段的 FIN 标志位会被置1，接着服务器会向客户端发送一个确认报文段。然后服务器也会客户端发送一个 FIN 标志位为1的终止报文段，随后客户端回送一个确认报文段，服务器立即断开连接。客户端等待一段时间后也断开连接。</p>
<p>其实四次挥手的过程是很容易理解的，由于 TCP 协议是全双工的，也就是说客户端和服务端都可以发起断开连接。两边各发起一次断开连接的申请，加上各自的两次确认，看起来就像执行了四次挥手。</p>
<p>为什么要有 TIME_WAIT 状态？因为客户端最后向服务器发送的确认 ACK 是有可能丢失的，当出现超时，服务端会再次发送 FIN 报文段，如果客户端已经关闭了就收不到了。还有一点是避免新旧连接混杂。</p>
<p>大量 CLOSE_WAIT 表示程序出现了问题，对方的 socket 已经关闭连接，而我方忙于读或写没有及时关闭连接，需要检查代码，特别是释放资源的代码，或者是处理请求的线程配置</p>
<p>\3. TIME_WAIT状态<br>    经过前面的铺垫，终于要讲到与本文主题相关的内容了。 ^_^<br>    从TCP状态迁移图可知，只有首先调用close()发起主动关闭的一方才会进入TIME_WAIT状态，而且是必须进入（图中左下角所示的3条状态迁移线最终均要进入该状态才能回到初始的CLOSED状态）。<br>    从图中还可看到，进入TIME_WAIT状态的TCP连接需要经过2MSL才能回到初始状态，其中，MSL是指Max<br>Segment Lifetime，即数据包在网络中的最大生存时间。每种TCP协议的实现方法均要指定一个合适的MSL值，如RFC1122给出的建议值为2分钟，又如Berkeley体系的TCP实现通常选择30秒作为MSL值。这意味着TIME_WAIT的典型持续时间为1-4分钟。<br>    TIME_WAIT状态存在的原因主要有两点：<br>    1）为实现TCP这种全双工（full-duplex）连接的可靠释放<br>    参考本文前面给出的TCP释放连接4次挥手示意图，假设发起active close的一方（图中为client）发送的ACK（4次交互的最后一个包）在网络中丢失，那么由于TCP的重传机制，执行passiveclose的一方（图中为server）需要重发其FIN，在该FIN到达client（client是active close发起方）之前，client必须维护这条连接的状态（尽管它已调用过close），具体而言，就是这条TCP连接对应的（local_ip, local_port）资源不能被立即释放或重新分配。直到romete peer重发的FIN达到，client也重发ACK后，该TCP连接才能恢复初始的CLOSED状态。如果activeclose方不进入TIME_WAIT以维护其连接状态，则当passive close方重发的FIN达到时，active close方的TCP传输层会以RST包响应对方，这会被对方认为有错误发生（而事实上，这是正常的关闭连接过程，并非异常）。<br>    2）为使旧的数据包在网络因过期而消失<br>    为说明这个问题，我们先假设TCP协议中不存在TIME_WAIT状态的限制，再假设当前有一条TCP连接：(local_ip, local_port, remote_ip,remote_port)，因某些原因，我们先关闭，接着很快以相同的四元组建立一条新连接。本文前面介绍过，TCP连接由四元组唯一标识，因此，在我们假设的情况中，TCP协议栈是无法区分前后两条TCP连接的不同的，在它看来，这根本就是同一条连接，中间先释放再建立的过程对其来说是“感知”不到的。这样就可能发生这样的情况：前一条TCP连接由local peer发送的数据到达remote peer后，会被该remot peer的TCP传输层当做当前TCP连接的正常数据接收并向上传递至应用层（而事实上，在我们假设的场景下，这些旧数据到达remote peer前，旧连接已断开且一条由相同四元组构成的新TCP连接已建立，因此，这些旧数据是不应该被向上传递至应用层的），从而引起数据错乱进而导致各种无法预知的诡异现象。作为一种可靠的传输协议，TCP必须在协议层面考虑并避免这种情况的发生，这正是TIME_WAIT状态存在的第2个原因。<br>    具体而言，local peer主动调用close后，此时的TCP连接进入TIME_WAIT状态，处于该状态下的TCP连接不能立即以同样的四元组建立新连接，即发起active close的那方占用的local port在TIME_WAIT期间不能再被重新分配。由于TIME_WAIT状态持续时间为2MSL，这样保证了旧TCP连接双工链路中的旧数据包均因过期（超过MSL）而消失，此后，就可以用相同的四元组建立一条新连接而不会发生前后两次连接数据错乱的情况。</p>
<p>另一比较深入的说法</p>
<p>TIME_WAIT状态的存在有两个理由：（1）让4次握手关闭流程更加可靠；4次握手的最后一个ACK是是由主动关闭方发送出去的，若这个ACK丢失，被动关闭方会再次发一个FIN过来。若主动关闭方能够保持一个2MSL的TIME_WAIT状态，则有更大的机会让丢失的ACK被再次发送出去。（2）防止lost duplicate对后续新建正常链接的传输造成破坏。lost duplicate在实际的网络中非常常见，经常是由于路由器产生故障，路径无法收敛，导致一个packet在路由器A，B，C之间做类似死循环的跳转。IP头部有个TTL，限制了一个包在网络中的最大跳数，因此这个包有两种命运，要么最后TTL变为0，在网络中消失；要么TTL在变为0之前路由器路径收敛，它凭借剩余的TTL跳数终于到达目的地。但非常可惜的是TCP通过超时重传机制在早些时候发送了一个跟它一模一样的包，并先于它达到了目的地，因此它的命运也就注定被TCP协议栈抛弃。另外一个概念叫做incarnation connection，指跟上次的socket pair一摸一样的新连接，叫做incarnation of previous connection。lost duplicate加上incarnation connection，则会对我们的传输造成致命的错误。大家都知道TCP是流式的，所有包到达的顺序是不一致的，依靠序列号由TCP协议栈做顺序的拼接；假设一个incarnation connection这时收到的seq&#x3D;1000, 来了一个lost duplicate为seq&#x3D;1000, len&#x3D;1000, 则tcp认为这个lost duplicate合法，并存放入了receive buffer，导致传输出现错误。通过一个2MSL TIME_WAIT状态，确保所有的lost duplicate都会消失掉，避免对新连接造成错误。</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>从上面的图可以看到滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。</p>
<p>可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。</p>
<p>接着就讲讲什么是流量控制窗口，什么是拥塞控制窗口。</p>
<p>先讲流量控制：</p>
<p>TCP 是全双工的，客户端和服务器均可作为发送方或接收方，我们现在假设一个发送方向接收方发送数据的场景来讲解流量控制。首先我们的接收方有一块接收缓存，当数据来到时会先把数据放到缓存中，上层应用等缓存中有数据时就会到缓存中取数据。假如发送方没有限制地不断地向接收方发送数据，接收方的应用程序又没有及时把接收缓存中的数据读走，就会出现缓存溢出，数据丢失的现象，为了解决这个问题，我们引入流量控制窗口。</p>
<p>假设应用程序最后读走的数据序号是 lastByteRead，接收缓存中接收到的最后一个数据序号是 lastByteRcv，接收缓存的大小为 RcvSize，那么必须要满足 lastByteRcv - lastByteRead &lt;&#x3D; RcvSize 才能保证接收缓存不会溢出，所以我们定义流量窗口为接收缓存剩余的空间，也就是Rcv &#x3D; RcvSize - (lastByteRcv - lastByteRead)。只要接收方在响应 ACK 的时候把这个窗口的值带给发送方，发送方就能知道接收方的接收缓存还有多大的空间，进而设置滑动窗口的大小。</p>
<p>接着讲解拥塞控制：</p>
<p>拥塞控制是指发送方先设置一个小的窗口值作为发送速率，当成功发包并接收到ACK时，便以指数速率增大发送窗口的大小，直到遇到丢包（超时&#x2F;三个冗余ACK），才停止并调整窗口的大小。这么做能最大限度地利用带宽，又不至于让网络环境变得太过拥挤。</p>
<p>最终滑动窗口的值将设置为流量控制窗口和拥塞控制窗口中的较小值。</p>
<p>Q: 编写 TCP&#x2F;SOCK_STREAM 服务程序时，SO_REUSEADDR到底什么意思？</p>
<p>A: 这个套接字选项通知内核，如果端口忙，但TCP状态位于 TIME_WAIT ，可以重用端口。如果端口忙，而TCP状态位于其他状态，重用端口时依旧得到一个错误信息， 指明”地址已经使用中”。如果你的服务程序停止后想立即重启，而新套接字依旧 使用同一端口，此时 SO_REUSEADDR 选项非常有用。必须意识到，此时任何非期 望数据到达，都可能导致服务程序反应混乱，不过这只是一种可能，事实上很不可能。</p>
<p>　CLOSE_WAIT： 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。</p>
<h3 id="UDP客户端可以CONNECT不，那CONNECT和不CONNECT有啥区别"><a href="#UDP客户端可以CONNECT不，那CONNECT和不CONNECT有啥区别" class="headerlink" title="UDP客户端可以CONNECT不，那CONNECT和不CONNECT有啥区别"></a>UDP客户端可以CONNECT不，那CONNECT和不CONNECT有啥区别</h3><p>在UDP协议中，没有真正的连接（connection）的概念，因此UDP客户端不能像TCP客户端那样通过<code>connect()</code>函数来建立连接。</p>
<p>使用<code>connect()</code>函数的主要目的是为了简化代码和提高安全性。当TCP客户端调用<code>connect()</code>函数时，操作系统会自动为其分配一个socket文件描述符，并将该socket与远程服务器的IP地址和端口号绑定起来。这样，在之后的数据通信中，客户端只需要向该socket发送数据即可，而不必每次都指定远程服务器的IP地址和端口号。另外，<code>connect()</code>函数还可以对发送的数据进行一些验证和过滤，以提高数据传输的安全性。</p>
<p>在UDP协议中，由于不存在真正的连接，因此也就不需要使用<code>connect()</code>函数来建立连接。UDP客户端每次发送数据时，都需要指定远程服务器的IP地址和端口号，这样才能确保数据能够正确地被发送到目标地址。因此，在UDP协议中，没有<code>connect()</code>函数的概念。</p>
<p>总之，UDP客户端没有连接（connection）的概念，因此不能像TCP客户端那样使用<code>connect()</code>函数来建立连接。每次发送数据时，UDP客户端需要显式地指定远程服务器的IP地址和端口号。如果需要简化代码和提高安全性，可以使用其他技术手段，例如使用加密算法和数字证书来保证数据传输的安全性。</p>
<h3 id="5-讲一下HTTP与HTTPS的区别"><a href="#5-讲一下HTTP与HTTPS的区别" class="headerlink" title="5. 讲一下HTTP与HTTPS的区别"></a>5. 讲一下HTTP与HTTPS的区别</h3><p>HTTP和HTTPS的主要区别在于HTTP协议传递的是明文数据，而HTTPS传递的是加密过的数据，也就是说HTTPS更具有安全性。也正由HTTPS需要保证安全性，所以它的性能要比HTTP差一点。</p>
<p>单说安全性肯定是不够的，我打算扩展讲一下HTTPS是怎么解决安全性问题的，通过这些HTTP没有机制，反映出HTTPS与HTTP的区别。下面尝试把HTTPS加密的过程推导出来。推导过程不涉及复杂的实现细节：</p>
<h4 id="如何安全地进行数据传输？"><a href="#如何安全地进行数据传输？" class="headerlink" title="如何安全地进行数据传输？"></a>如何安全地进行数据传输？</h4><p>假设现在A和B要进行安全的通信，那么究竟怎样才算是安全的通信？很自然地会想到：A和B之间传递数据，这些数据只有A和B才看得懂，中间人就算截取了信息但也看不懂，这才算得上安全。</p>
<h4 id="安全通信的处理手段："><a href="#安全通信的处理手段：" class="headerlink" title="安全通信的处理手段："></a>安全通信的处理手段：</h4><p>为了能让A和B才能看懂，就必须要对数据进行加密，而且首先想到的就是对称加密。对称加密的意思是A和B各持有一个相同的密钥，它们传递信息时会用密钥给信息加密，在消息到达端给消息解密，完成安全通信。</p>
<p>在对称加密中又会涉及到加密算法的选择问题。现实世界中，通常是多个客户端面向一个服务器的情况，不可能让每个客户端和服务器之间都采用相同的加密算法，如果是这样那和没加密差不多。所以注定每个客户端和服务器之间都会采用不同的加密方式。</p>
<h4 id="如何让每个客户端与服务器之间都采用不同的加密方式？"><a href="#如何让每个客户端与服务器之间都采用不同的加密方式？" class="headerlink" title="如何让每个客户端与服务器之间都采用不同的加密方式？"></a>如何让每个客户端与服务器之间都采用不同的加密方式？</h4><p>要想对不同的机器使用不同的加密方式，最直接想到的就是使用随机数。也就说客户端和服务器之间每次都基于一个随机数产生加密算法。（具体实现时为了保证随机，用到还不止一个随机数）</p>
<p>这个产生加密算法的过程称之为协商，现在问题是协商的过程是透明的，也就是说中间人可以截获协商的过程，从而知道我们的加密方式。为了解决这个问题，我们需要对协商的过程进行加密。</p>
<h4 id="如何对协商的过程进行加密？"><a href="#如何对协商的过程进行加密？" class="headerlink" title="如何对协商的过程进行加密？"></a>如何对协商的过程进行加密？</h4><p>之所以能来到这一步，是因为我们一开始就选择使用了对称加密，也就说一开始的对称加密导致了现在的问题，所以这时我们不能再使用对称加密了，否则会陷入死循环。</p>
<p>在密码学领域，还有一种加密过程叫非对称加密，它的逻辑是这样的：通信双方一方持有私钥，一方持有公钥，经过私钥加密的信息，都能通过公钥进行解密。但是经过公钥加密的数据，只有私钥可以解密。</p>
<p>按照非对称加密的规则，我们让服务器持有私钥，让客户端持有公钥。这样就能保证客户端给服务器发送消息的时候是安全的（相反，服务器给客户端发送消息就是不安全的），我们可以把协商时重要的逻辑安排在客户端给服务器发送信息的过程中，从而保证了协商过程的安全性。</p>
<h4 id="客户端如何获得公钥？"><a href="#客户端如何获得公钥？" class="headerlink" title="客户端如何获得公钥？"></a>客户端如何获得公钥？</h4><p>现在用非对称加密算法解决了协商的安全问题，但是非对称加密的前提是客户端需要获得公钥，这又是一个问题了，客户端与服务器打交道之前是互不知道双方身份的，怎么才能让客户端获得公钥呢？</p>
<p>也就只有两种办法：</p>
<ol>
<li>客户端向服务器要公钥</li>
<li>客户端向一个远程的公共服务器获取公钥</li>
</ol>
<p>方法2显然是不行的，尚且不说多了一个访问节点，如何找到公共服务器的地址也是一个待解决的问题，所以还是使用方法1。</p>
<p>但是方法1存在一个问题：如果中间人把服务器发送给客户端的公钥调包了怎么办？也就是说客户端无法知道发送公钥的是否是正真的服务器。</p>
<h4 id="引入第三方机构解决问题"><a href="#引入第三方机构解决问题" class="headerlink" title="引入第三方机构解决问题"></a>引入第三方机构解决问题</h4><p>客户端无法辨识服务端和中间人的问题称为“身份验证”问题，也就是说我们需要为服务器向客户端发送公钥的过程进行加密。</p>
<p>这下完了，之前我们因遇到对称加密的瓶颈选择了非对称加密，现在使用非对称加密也遇到了瓶颈。显然这两种加密方式都是不可用的了，否则会再次陷入死循环。</p>
<p>接下来我们只好通过第三方机构的介入，解决这个问题。首先我们自己保存有第三方权威机构的公钥，然后第三方机构使用私钥对服务器将要发送给客户端的公钥进行加密，客户端接收到这个经加密的公钥后（数字证书），就能通过自己保存的第三方机构公钥进行解密。</p>
<blockquote>
<p>到这里为止，我们解释了HTTPS中使用到的对称加密，非对称加密，CA，数字证书的概念，但是还差一个叫数字签名的概念没有解释。</p>
</blockquote>
<p>在现实生活中，CA不单止会给我们正常公司发放证书，还会给中间人的坏公司发放证书，如果中间人把发放的证书调包了怎么办？这时我们仍能用CA的私钥进行解密，但是证书已经被调包了。</p>
<p>那么客户端怎样验证证书的真伪呢？答案是证书本身会告诉客户端如何辨认真伪。比方说证书上面有一个证书编号，还有一个如何计算证书编号的方法，客户端可以根据计算证书编号的方法计算出自己要获得的证书的编号，然后把这个编号和证书上的编号进行比对，如果一样证明没有被调包。</p>
<p>这里的证书编号指的就是数字签名，证书指的就是数字证书。</p>
<p>总结一下HTTPS：HTTPS想要保证客户端与服务器之间的通信安全，就得使用对称加密算法进行加密。协商对称加密算法的过程通过非对称加密算法来保证。在非对称加密算法中，客户端获得公钥的过程需要第三方机构（CA）通过颁发数字证书保证安全性。</p>
<p>总得来说通过这一系列机制协商出了一个对称加密算法后，客户端与服务器之间就能通过该算法进行安全的通信了</p>
<ul>
<li><p>TCP消息和UDP的主要区别</p>
</li>
<li><p>Epoll比起select&#x2F;poll，主要优化点在哪里？</p>
</li>
<li><p>Post和Get有什么区别？</p>
</li>
<li><p>接收时，如何确定一个HTTP消息已经读取完毕</p>
</li>
<li><p>从一个命令行下载一个网页，会涉及哪些网络协议？（DNS，TCP，HTTP，如果有ARP和SSL更好）</p>
</li>
<li><p>HTTP&#x2F;2主要优化点</p>
</li>
<li><p>\1. C++中具体是怎么实现多态的？构造函数可以是虚函数吗？构造函数可以调用虚函数吗？<br>编译器发现一个类中有虚函数，便会立即为此类生成虚函数表 vtable。虚函数表的各表项为指向对应虚函数的指针。<br>构造函数不可以是虚函数，也不能调用虚函数，因为此时虚函数表还未生成。</p>
<p>\2. 操作系统中进程、线程的区别，进程间通信通信的方式？<br>进程： 进程是资源（CPU、内存等）分配的基本单位，具有一定功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。<br>线程：线程是进程的一个实体，是独立运行和独立调度的基本单位（CPU上真正运行的是线程）。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。<br>进程通信的方式：管道，有名管道，信号量，消息队列，信号,共享内存,套接字.</p>
<p>\3. python中的多线程能充分利用多核CPU吗？如果要充分利用的话应该怎么做？<br>python的多线程不能充分利用多CPU，因为python解释器有一个全局锁；<br>要想利用多CPU只能使用多进程模型，或者使用C++</p>
<p>\4. http属于OSI分层协议中的哪一层？TCP&#x2F;UDP是属于哪一层？TCP的三次握手的过程是怎样的？为什么要有三次握手？<br>http属于应用层，TCP&#x2F;UDP属于传输层；</p>
<p>假设 A 为客户端，B 为服务器端。</p>
<p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p>
<p>A 向 B 发送连接请求报文，SYN&#x3D;1，ACK&#x3D;0，选择一个初始的序号 x。</p>
<p>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN&#x3D;1，ACK&#x3D;1，确认号为 x+1，同时也选择一个初始的序号 y。</p>
<p>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</p>
<p>B 收到 A 的确认后，连接建立。</p>
<p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p>
<p>\5. TCP怎么实现可靠传输的？</p>
<p>TCP滑动窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。<br>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。<br>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p>
</li>
</ul>
<h3 id="不同地区的用户的请求怎么打到附近的地区呢？"><a href="#不同地区的用户的请求怎么打到附近的地区呢？" class="headerlink" title="不同地区的用户的请求怎么打到附近的地区呢？"></a>不同地区的用户的请求怎么打到附近的地区呢？</h3><p>答：讲了CDN</p>
<p><strong>补充：</strong></p>
<p>CDN 将内容资源分发到位于多个地理位置机房中的服务器上，这样我们在访问内容资源的时候，不用访问源服务器。而是直接访问离我们最近的 CDN 节点 ，这样一来就省去了长途跋涉的时间成本，从而实现了网络加速。</p>
<p>找到离用户最近的 CDN 节点是由 CDN 的<strong>全局负载均衡器（<em>Global Sever Load Balance，GSLB</em>）</strong>负责的。</p>
<p>那 GSLB 是在什么时候起作用的呢？在回答这个问题前，我们先来看看在没有 CDN 的情况下，访问域名时发生的事情。</p>
<p>在没有 CDN 的情况下，当我们访问域名时，DNS 服务器最终会返回源服务器的地址。</p>
<p>比如，当我们在浏览器输入 <a target="_blank" rel="noopener" href="http://www.xiaolin.com/">www.xiaolin.com</a> 域名后，在本地 host 文件找不到域名时，客户端就会访问本地 DNS 服务器。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfg8KBLwPAE6ktepRPahjT7TyX6BwTp8IcDsOAkGvvWiaUcg2dQZc3ExHZyHr2ngzib5HfeMqvHN35g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>图片</p>
<p>这时候:</p>
<ul>
<li><p>如果本地 DNS 服务器有缓存该网站的地址，则直接返回网站的地址；</p>
</li>
<li><p>如果没有就通过递归查询的方式，先请求根 DNS，根 DNS 返回顶级 DNS（.com）的地址；再请求 .com 顶级 DNS 得到 xiaolin.com 的域名服务器地址，再从 xiaolin.com 的域名服务器中查询到 <a target="_blank" rel="noopener" href="http://www.xiaolin.com/">www.xiaolin.com</a> 对应的 IP 地址，然后返回这个 IP 地址，同时本地 DNS 缓存该 IP 地址，这样下一次的解析同一个域名就不需要做 DNS 的迭代查询了。</p>
</li>
</ul>
<p><strong>但加入 CDN 后就不一样了</strong>。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfg8KBLwPAE6ktepRPahjT7Ve7FiaAianuWiaZic1anXPYAST8dccKtcwJ5uzia8ZqicxiciaWfGOlgyDpVWg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>图片</p>
<p>会在 xiaolin.com 这个 DNS 服务器上，设置一个 CNAME 别名，指向另外一个域名 <a target="_blank" rel="noopener" href="http://www.xiaolin.cdn.com,返回给本地/">www.xiaolin.cdn.com，返回给本地</a> DNS 服务器。</p>
<p>接着继续解析该域名，这个时候访问的就是 xiaolin.cdn.com 这台 CDN 专用的 DNS 服务器，在这个服务器上，又会设置一个 CNAME，指向另外一个域名，这次指向的就是 CDN 的 GSLB。</p>
<p>接着，本地 DNS 服务器去请求 CDN 的 GSLB 的域名，GSLB 就会为用户选择一台合适的 CDN 节点提供服务，选择的依据主要有以下几点：</p>
<ul>
<li><p>看用户的 IP 地址，查表得知地理位置，找相对最近的 CDN 节点；</p>
</li>
<li><p>看用户所在的运营商网络，找相同网络的 CDN 节点；</p>
</li>
<li><p>看用户请求 URL，判断哪一台服务器上有用户所请求的资源；</p>
</li>
<li><p>查询 CDN 节点的负载情况，找负载较轻的节点；</p>
</li>
</ul>
<p>GSLB 会基于以上的条件进行综合分析后，找出一台最合适的 CDN 节点，并返回该 CDN 节点的 IP 地址给本地 DNS 服务器，然后本地 DNS 服务器缓存该 IP 地址，并将 IP 返回给客户端，客户端去访问这个 CDN 节点，下载资源。</p>
<h3 id="TCP的close-wait在哪端，如果我们场景中出现了大量的close-wait，你觉得要怎么排查"><a href="#TCP的close-wait在哪端，如果我们场景中出现了大量的close-wait，你觉得要怎么排查" class="headerlink" title="TCP的close_wait在哪端，如果我们场景中出现了大量的close_wait，你觉得要怎么排查"></a>TCP的close_wait在哪端，如果我们场景中出现了大量的close_wait，你觉得要怎么排查</h3><p>答：被动方，代码逻辑有问题，没close</p>
<p><strong>补充：</strong></p>
<p>CLOSE_WAIT 状态是「被动关闭方」才会有的状态，而且如果「被动关闭方」没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态。</p>
<p>所以，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接</strong>。</p>
<p>那什么情况会导致服务端的程序没有调用 close 函数关闭连接？这时候通常需要排查代码。</p>
<p>我们先来分析一个普通的 TCP 服务端的流程：</p>
<ol>
<li><p>创建服务端 socket，bind 绑定端口、listen 监听端口</p>
</li>
<li><p>将服务端 socket 注册到 epoll</p>
</li>
<li><p>epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket</p>
</li>
<li><p>将已连接的 socket 注册到 epoll</p>
</li>
<li><p>epoll_wait 等待事件发生</p>
</li>
<li><p>对方连接关闭时，我方调用 close</p>
</li>
</ol>
<p>可能导致服务端没有调用 close 函数的原因，如下。</p>
<p><strong>第一个原因</strong>：第 2 步没有做，没有将服务端 socket 注册到 epoll，这样有新连接到来时，服务端没办法感知这个事件，也就无法获取到已连接的 socket，那服务端自然就没机会对 socket 调用 close 函数了。</p>
<p>不过这种原因发生的概率比较小，这种属于明显的代码逻辑 bug，在前期 read view 阶段就能发现的了。</p>
<p><strong>第二个原因</strong>：第 3 步没有做，有新连接到来时没有调用 accpet 获取该连接的 socket，导致当有大量的客户端主动断开了连接，而服务端没机会对这些 socket 调用 close 函数，从而导致服务端出现大量 CLOSE_WAIT 状态的连接。</p>
<p>发生这种情况可能是因为服务端在执行 accpet 函数之前，代码卡在某一个逻辑或者提前抛出了异常。</p>
<p><strong>第三个原因</strong>：第 4 步没有做，通过 accpet 获取已连接的 socket 后，没有将其注册到 epoll，导致后续收到 FIN 报文的时候，服务端没办法感知这个事件，那服务端就没机会调用 close 函数了。</p>
<p>发生这种情况可能是因为服务端在将已连接的 socket 注册到 epoll 之前，代码卡在某一个逻辑或者提前抛出了异常。之前看到过别人解决 close_wait 问题的实践文章，感兴趣的可以看看：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU3Njk0MTc3Ng==&mid=2247486020&idx=1&sn=f7cf41aec28e2e10a46228a64b1c0a5c&scene=21#wechat_redirect">一次 Netty 代码不健壮导致的大量 CLOSE_WAIT 连接原因分析</a></p>
<p><strong>第四个原因</strong>：第 6 步没有做，当发现客户端关闭连接后，服务端没有执行 close 函数，可能是因为代码漏处理，或者是在执行 close 函数之前，代码卡在某一个逻辑，比如发生死锁等等。</p>
<p>可以发现，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，通常都是代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用 close</strong>。</p>
<h3 id="服务端出现大量-TIME-WAIT-状态的原因有哪些？"><a href="#服务端出现大量-TIME-WAIT-状态的原因有哪些？" class="headerlink" title="服务端出现大量 TIME_WAIT 状态的原因有哪些？"></a>服务端出现大量 TIME_WAIT 状态的原因有哪些？</h3><p>我们先来看一下 TCP 四次挥手的流程吧，看看 TIME_WAIT 状态发生在哪一个阶段。</p>
<p>下面这个图，是由「客户端」作为「主动关闭方」的 TCP 四次挥手的流程。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdWrrgBYLP5VsrraBM1qVuzgibl5CZs9FKwxdu2j2In9NPx4W5wC2e91AjbyLlwL7jvEY5NNjuRr5Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>TCP 四次挥手的流程</p>
<p>从上面我们可以知道，<strong>TIME_WAIT 状态是「主动关闭连接方」才会出现的状态</strong>。而且 TIME_WAIT 状态会持续 2MSL 时间才会进入到 close 状态。在 Linux 上 2MSL 的时长是 60 秒，也就是说<strong>停留在 TIME_WAIT 的时间为固定的 60 秒</strong>。</p>
<p>为什么需要 TIME_WAIT 状态？（老八股文了，帮大家复习一波）主要有两个原因：</p>
<ul>
<li><p><strong>保证「被动关闭连接」的一方，能被正确的关闭</strong>。TCP 协议在关闭连接的四次挥手中，在主动关闭方发送的最后一个 ACK 报文，有可能丢失，这时被动方会重新发 FIN 报文, 如果这时主动方处于 CLOSE 状态 ，就会响应 RST 报文而不是 ACK 报文。所以主动方要处于 TIME_WAIT 状态，而不能是 CLOSE。</p>
</li>
<li><p><strong>防止历史连接中的数据，被后面相同四元组的连接错误的接收</strong>。TCP 报文可能由于路由器异常而 “迷路”，在迷途期间，TCP 发送端可能因确认超时而重发这个报文，迷途的报文在路由器修复后也会被送到最终目的地，这个原来的迷途报文就称为 lost duplicate。在关闭一个 TCP 连接后，马上又重新建立起一个相同的 IP 地址和端口之间的 TCP 连接，后一个连接被称为前一个连接的化身，那么有可能出现这种情况，前一个连接的迷途重复报文在前一个连接终止后出现，从而被误解成从属于新的化身。为了避免这个情 况， TIME_WAIT 状态需要持续 2MSL，因为这样就可以保证当成功建立一个 TCP 连接的时候，来自连接先前化身的重复报文已经在网络中消逝。</p>
</li>
</ul>
<p>很多人误解以为只有客户端才会有 TIME_WAIT 状态，这是不对的。TCP 是全双工协议，哪一方都可以先关闭连接，所以哪一方都可能会有 TIME_WAIT 状态。</p>
<p>总之记住，<strong>谁先关闭连接的，它就是主动关闭方，那么 TIME_WAIT 就会出现在主动关闭方</strong>。</p>
<h4 id="什么场景下服务端会主动断开连接呢？"><a href="#什么场景下服务端会主动断开连接呢？" class="headerlink" title="什么场景下服务端会主动断开连接呢？"></a>什么场景下服务端会主动断开连接呢？</h4><p>如果服务端出现大量的 TIME_WAIT 状态的 TCP 连接，就是<strong>说明服务端主动断开了很多 TCP 连接</strong>。</p>
<p>问题来了，<strong>什么场景下服务端会主动断开连接呢？</strong></p>
<ul>
<li><p>第一个场景：HTTP 没有使用长连接</p>
</li>
<li><p>第二个场景：HTTP 长连接超时</p>
</li>
<li><p>第三个场景：HTTP 长连接的请求数量达到上限</p>
</li>
</ul>
<p>接下来，分别介绍下。</p>
<h5 id="第一个场景：HTTP-没有使用长连接"><a href="#第一个场景：HTTP-没有使用长连接" class="headerlink" title="第一个场景：HTTP 没有使用长连接"></a>第一个场景：HTTP 没有使用长连接</h5><p>我们先来看看 HTTP 长连接（Keep-Alive）机制是怎么开启的。</p>
<p>在 HTTP&#x2F;1.0 中默认是关闭的，如果浏览器要开启 Keep-Alive，它必须在请求的 header 中添加：</p>
<p><code>Connection: Keep-Alive   </code></p>
<p>然后当服务器收到请求，作出回应的时候，它也被添加到响应中 header 里：</p>
<p><code>Connection: Keep-Alive   </code></p>
<p>这样做，TCP 连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个 TCP 连接。这一直继续到客户端或服务器端提出断开连接。</p>
<p><strong>从 HTTP&#x2F;1.1 开始， 就默认是开启了 Keep-Alive</strong>，现在大多数浏览器都默认是使用 HTTP&#x2F;1.1，所以 Keep-Alive 都是默认打开的。一旦客户端和服务端达成协议，那么长连接就建立好了。</p>
<p>如果要关闭 HTTP Keep-Alive，需要在 HTTP 请求或者响应的 header 里添加 <code>Connection:close</code> 信息，也就是说，<strong>只要客户端和服务端任意一方的 HTTP header 中有 <code>Connection:close</code> 信息，那么就无法使用 HTTP 长连接的机制</strong>。</p>
<p>关闭 HTTP 长连接机制后，每次请求都要经历这样的过程：建立 TCP -&gt; 请求资源 -&gt; 响应资源 -&gt; 释放连接，那么此方式就是 <strong>HTTP 短连接</strong>，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdWrrgBYLP5VsrraBM1qVuz6Mbyn1OB5sHE3A6HarVbjvNt8Wuoz4bIktXZ4uAQicFlHtVnEibfviaAg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>HTTP 短连接</p>
<p>在前面我们知道，只要任意一方的 HTTP header 中有 <code>Connection:close</code> 信息，就无法使用 HTTP 长连接机制，这样在完成一次 HTTP 请求&#x2F;处理后，就会关闭连接。</p>
<p>问题来了，<strong>这时候是客户端还是服务端主动关闭连接呢？</strong></p>
<p>在 RFC 文档中，并没有明确由谁来关闭连接，<strong>请求和响应的双方都可以主动关闭 TCP 连接。</strong></p>
<p>不过，<strong>根据大多数 Web 服务的实现，不管哪一方禁用了 HTTP Keep-Alive，都是由服务端主动关闭连接</strong>，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p>
<blockquote>
<p>客户端禁用了 HTTP Keep-Alive，服务端开启 HTTP Keep-Alive，谁是主动关闭方？</p>
</blockquote>
<p>当客户端禁用了 HTTP Keep-Alive，这时候 HTTP 请求的 header 就会有 <code>Connection:close</code> 信息，这时服务端在发完 HTTP 响应后，就会主动关闭连接。</p>
<p>为什么要这么设计呢？HTTP 是请求-响应模型，发起方一直是客户端，HTTP Keep-Alive 的初衷是<strong>为客户端后续的请求重用连接</strong>，如果我们<strong>在某次 HTTP 请求-响应模型中，请求的 header 定义了 <code>connection：close</code> 信息，那不再重用这个连接的时机就只有在服务端了</strong>，所以我们在 HTTP 请求-响应这个周期的「末端」关闭连接是合理的。</p>
<blockquote>
<p>客户端开启了 HTTP Keep-Alive，服务端禁用了 HTTP Keep-Alive，谁是主动关闭方？</p>
</blockquote>
<p>当客户端开启了 HTTP Keep-Alive，而服务端禁用了 HTTP Keep-Alive，这时服务端在发完 HTTP 响应后，服务端也会主动关闭连接。</p>
<p>为什么要这么设计呢？在服务端主动关闭连接的情况下，只要调用一次 close() 就可以释放连接，剩下的工作由内核 TCP 栈直接进行了处理，整个过程只有一次 syscall；如果是要求 客户端关闭，则服务端在写完最后一个 response 之后需要把这个 socket 放入 readable 队列，调用 select &#x2F; epoll 去等待事件；然后调用一次 read() 才能知道连接已经被关闭，这其中是两次 syscall，多一次用户态程序被激活执行，而且 socket 保持时间也会更长。</p>
<p>因此，<strong>当服务端出现大量的 TIME_WAIT 状态连接的时候，可以排查下是否客户端和服务端都开启了 HTTP Keep-Alive</strong>，因为任意一方没有开启  HTTP Keep-Alive，都会导致服务端在处理完一个 HTTP 请求后，就主动关闭连接，此时服务端上就会出现大量的 TIME_WAIT 状态的连接。</p>
<p>针对这个场景下，解决的方式也很简单，让客户端和服务端都开启 HTTP Keep-Alive 机制。</p>
<h5 id="第二个场景：HTTP-长连接超时"><a href="#第二个场景：HTTP-长连接超时" class="headerlink" title="第二个场景：HTTP 长连接超时"></a>第二个场景：HTTP 长连接超时</h5><p>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p>
<p>HTTP 长连接可以在同一个 TCP 连接上接收和发送多个 HTTP 请求&#x2F;应答，避免了连接建立和释放的开销。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdWrrgBYLP5VsrraBM1qVuzJOMM2YOyn0hibsGmKnTveXVtdAueyHib140mgZgFCN1kX8LRF4VXexpA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>可能有的同学会问，如果使用了 HTTP 长连接，如果客户端完成一个 HTTP 请求后，就不再发起新的请求，此时这个 TCP 连接一直占用着不是挺浪费资源的吗？</p>
<p>对没错，所以为了避免资源浪费的情况，web 服务软件一般都会提供一个参数，用来指定 HTTP 长连接的超时时间，比如 nginx 提供的 keepalive_timeout 参数。</p>
<p>假设设置了 HTTP 长连接的超时时间是 60 秒，nginx 就会启动一个「定时器」，<strong>如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，定时器的时间一到，nginx 就会触发回调函数来关闭该连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接</strong>。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdWrrgBYLP5VsrraBM1qVuz5pHQCUACibMOoaNEuB6JqQHEST9cpyZutary8DxnB1joDHybV0ibWBOw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>HTTP 长连接超时</p>
<p>当服务端出现大量 TIME_WAIT 状态的连接时，如果现象是有大量的客户端建立完 TCP 连接后，很长一段时间没有发送数据，那么大概率就是因为 HTTP 长连接超时，导致服务端主动关闭连接，产生大量处于 TIME_WAIT 状态的连接。</p>
<p>可以往网络问题的方向排查，比如是否是因为网络问题，导致客户端发送的数据一直没有被服务端接收到，以至于 HTTP 长连接超时。</p>
<h5 id="第三个场景：HTTP-长连接的请求数量达到上限"><a href="#第三个场景：HTTP-长连接的请求数量达到上限" class="headerlink" title="第三个场景：HTTP 长连接的请求数量达到上限"></a>第三个场景：HTTP 长连接的请求数量达到上限</h5><p>Web 服务端通常会有个参数，来定义一条 HTTP 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接。</p>
<p>比如 nginx 的 keepalive_requests 这个参数，这个参数是指一个 HTTP 长连接建立之后，nginx 就会为这个连接设置一个计数器，记录这个 HTTP 长连接上已经接收并处理的客户端请求的数量。<strong>如果达到这个参数设置的最大值时，则 nginx 会主动关闭这个长连接</strong>，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p>
<p>keepalive_requests 参数的默认值是 100 ，意味着每个 HTTP 长连接最多只能跑 100  次请求，这个参数往往被大多数人忽略，因为当 QPS (每秒请求数) 不是很高时，默认值 100 凑合够用。</p>
<p>但是，<strong>对于一些 QPS 比较高的场景，比如超过 10000 QPS，甚至达到 30000 , 50000 甚至更高，如果 keepalive_requests 参数值是 100，这时候就 nginx 就会很频繁地关闭连接，那么此时服务端上就会出大量的 TIME_WAIT 状态</strong>。</p>
<p>针对这个场景下，解决的方式也很简单，调大 nginx 的 keepalive_requests 参数就行。</p>
<h4 id="TIME-WAIT-状态过多有什么危害？"><a href="#TIME-WAIT-状态过多有什么危害？" class="headerlink" title="TIME_WAIT 状态过多有什么危害？"></a>TIME_WAIT 状态过多有什么危害？</h4><p>过多的 TIME-WAIT 状态主要的危害有两种：</p>
<ul>
<li><p>第一是占用系统资源，比如文件描述符、内存资源、CPU 资源等；</p>
</li>
<li><p>第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为 <code>32768～61000</code>，也可以通过 <code>net.ipv4.ip_local_port_range</code>参数指定范围。</p>
</li>
</ul>
<p>客户端和服务端 TIME_WAIT 过多，造成的影响是不同的。</p>
<p><strong>如果客户端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT」都一样的服务端发起连接了，但是被使用的端口，还是可以继续对另外一个服务端发起连接的。具体可以看我这篇文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247517946&idx=1&sn=a3d88d7ac73792c5031ccf8422066f7c&scene=21#wechat_redirect">客户端的端口可以重复使用吗？</a></p>
<p>因此，客户端（发起连接方）都是和「目的 IP+ 目的 PORT 」都一样的服务端建立连接的话，当客户端的 TIME_WAIT 状态连接过多的话，就会受端口资源限制，如果占满了所有端口资源，那么就无法再跟「目的 IP+ 目的 PORT」都一样的服务端建立连接了。</p>
<p>不过，即使是在这种场景下，只要连接的是不同的服务端，端口是可以重复使用的，所以客户端还是可以向其他服务端发起连接的，这是因为内核在定位一个连接的时候，是通过四元组（源IP、源端口、目的IP、目的端口）信息来定位的，并不会因为客户端的端口一样，而导致连接冲突。</p>
<p><strong>如果服务端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接，但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源等。</p>
<h4 id="如何优化-TIME-WAIT-状态？"><a href="#如何优化-TIME-WAIT-状态？" class="headerlink" title="如何优化 TIME_WAIT 状态？"></a>如何优化 TIME_WAIT 状态？</h4><p>这里给出优化 TIME-WAIT 的几个方式，都是有利有弊：</p>
<ul>
<li><p>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；</p>
</li>
<li><p>net.ipv4.tcp_max_tw_buckets</p>
</li>
<li><p>程序中使用 SO_LINGER ，应用强制使用 RST 关闭。</p>
</li>
</ul>
<p><em>方式一：net.ipv4.tcp_tw_reuse 和 tcp_timestamps</em></p>
<p>开启 tcp_tw_reuse，则可以<strong>复用处于 TIME_WAIT 的 socket 为新的连接所用</strong>。</p>
<p>有一点需要注意的是，<strong>tcp_tw_reuse 功能只能用客户端（连接发起方），因为开启了该功能，在调用 connect() 函数时，内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复用。</strong></p>
<p><code>net.ipv4.tcp_tw_reuse = 1   </code></p>
<p>使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持，即</p>
<p><code>net.ipv4.tcp_timestamps=1（默认即为 1）   </code></p>
<p>这个时间戳的字段是在 TCP 头部的「选项」里，它由一共 8 个字节表示时间戳，其中第一个 4 字节字段用来保存发送该数据包的时间，第二个 4 字节字段用来保存最近一次接收对方发送到达数据的时间。</p>
<p>由于引入了时间戳，可以使得重复的数据包会因为时间戳过期被自然丢弃，因此 TIME_WAIT 状态才可以被复用。</p>
<p><em>方式二：net.ipv4.tcp_max_tw_buckets</em></p>
<p>这个值默认为 18000，<strong>当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接状态重置</strong>，这个方法比较暴力。</p>
<p><code>net.ipv4.tcp_max_tw_buckets = 18000   </code></p>
<p><em>方式三：程序中使用 SO_LINGER</em></p>
<p>我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。</p>
<p><code>struct linger so_linger;   so_linger.l_onoff = 1;   so_linger.l_linger = 0;   setsockopt(s, SOL_SOCKET, SO_LINGER, &amp;so_linger,sizeof(so_linger));   </code></p>
<p>如果<code>l_onoff</code>为非 0， 且<code>l_linger</code>值为 0，那么调用<code>close</code>后，会立该发送一个<code>RST</code>标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了<code>TIME_WAIT</code>状态，直接关闭。</p>
<p>但这为跨越<code>TIME_WAIT</code>状态提供了一个可能，不过是一个非常危险的行为，不值得提倡。</p>
<p>前面介绍的方法都是试图越过 <code>TIME_WAIT</code>状态的，这样其实不太好。虽然 TIME_WAIT 状态持续的时间是有一点长，显得很不友好，但是它被设计来就是用来避免发生乱七八糟的事情。</p>
<p>《UNIX网络编程》一书中却说道：<strong>TIME_WAIT 是我们的朋友，它是有助于我们的，不要试图避免这个状态，而是应该弄清楚它</strong>。</p>
<p><strong>如果服务端要避免过多的 TIME_WAIT 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT</strong>。</p>
<h3 id="服务端出现大量-CLOSE-WAIT-状态的原因有哪些？"><a href="#服务端出现大量-CLOSE-WAIT-状态的原因有哪些？" class="headerlink" title="服务端出现大量 CLOSE_WAIT 状态的原因有哪些？"></a>服务端出现大量 CLOSE_WAIT 状态的原因有哪些？</h3><p>还是拿这张图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdWrrgBYLP5VsrraBM1qVuzgibl5CZs9FKwxdu2j2In9NPx4W5wC2e91AjbyLlwL7jvEY5NNjuRr5Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>TCP 四次挥手的流程</p>
<p>从上面这张图我们可以得知，CLOSE_WAIT 状态是「被动关闭方」才会有的状态，而且如果「被动关闭方」没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态。</p>
<p>所以，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接</strong>。</p>
<p>那什么情况会导致服务端的程序没有调用 close 函数关闭连接？这时候通常需要排查代码。</p>
<p>我们先来分析一个普通的 TCP 服务端的流程：</p>
<ol>
<li><p>创建服务端 socket，bind 绑定端口、listen 监听端口</p>
</li>
<li><p>将服务端 socket 注册到 epoll</p>
</li>
<li><p>epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket</p>
</li>
<li><p>将已连接的 socket 注册到 epoll</p>
</li>
<li><p>epoll_wait 等待事件发生</p>
</li>
<li><p>对方连接关闭时，我方调用 close</p>
</li>
</ol>
<p>可能导致服务端没有调用 close 函数的原因，如下。</p>
<p><strong>第一个原因</strong>：第 2 步没有做，没有将服务端 socket 注册到 epoll，这样有新连接到来时，服务端没办法感知这个事件，也就无法获取到已连接的 socket，那服务端自然就没机会对 socket 调用 close 函数了。</p>
<p>不过这种原因发生的概率比较小，这种属于明显的代码逻辑 bug，在前期 read view 阶段就能发现的了。</p>
<p><strong>第二个原因</strong>：第 3 步没有做，有新连接到来时没有调用 accpet 获取该连接的 socket，导致当有大量的客户端主动断开了连接，而服务端没机会对这些 socket 调用 close 函数，从而导致服务端出现大量 CLOSE_WAIT 状态的连接。</p>
<p>发生这种情况可能是因为服务端在执行 accpet  函数之前，代码卡在某一个逻辑或者提前抛出了异常。</p>
<p><strong>第三个原因</strong>：第 4 步没有做，通过 accpet 获取已连接的 socket 后，没有将其注册到 epoll，导致后续收到 FIN 报文的时候，服务端没办法感知这个事件，那服务端就没机会调用 close 函数了。</p>
<p>发生这种情况可能是因为服务端在将已连接的 socket 注册到 epoll 之前，代码卡在某一个逻辑或者提前抛出了异常。之前看到过别人解决 close_wait 问题的实践文章，感兴趣的可以看看：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU3Njk0MTc3Ng==&mid=2247486020&idx=1&sn=f7cf41aec28e2e10a46228a64b1c0a5c&scene=21#wechat_redirect">一次 Netty 代码不健壮导致的大量 CLOSE_WAIT 连接原因分析</a></p>
<p><strong>第四个原因</strong>：第 6 步没有做，当发现客户端关闭连接后，服务端没有执行 close 函数，可能是因为代码漏处理，或者是在执行 close 函数之前，代码卡在某一个逻辑，比如发生死锁等等。</p>
<p>可以发现，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，通常都是代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用 close</strong>。<br>面试问题</p>
<p>1）TCP&#x2F;IP协议<br>    1）三次握手&#x2F;四次挥手过程<br>    2）TIME_WAIT状态<br>        1）主动关闭&#x2F;被动关闭<br>        2）需要的原因<br>        3）缓解措施<br>        4）有没有方式不出现TIME_WAIT状态<br>    3）RST出现的场景<br>    4）滑动窗口<br>2）网络编程<br>    1）EPOLL&#x2F;SELECT的区别<br>    2）边沿触发&#x2F;水平触发<br>    3）事件触发的场景<br>        1）读事件 有哪些场景<br>        2）写事件 有哪些场景<br>    4）READ调用返回值场景<br>        1）0<br>        2）-1<br>        3）&gt;0<br>    5）UDP客户端可以CONNECT不，那CONNECT和不CONNECT有啥区别<br>3）后台编程<br>    1）FORK的用途，FORK区分父子进程方式<br>    2）进程间通信方式<br>    3）僵尸进程<br>    4）内存模型，有哪些段构成<br>    5）进程&#x2F;线程&#x2F;协程的区别<br>4）常见中间件<br>    1）MYSQL<br>        1）为啥不建议SELECT *<br>        2）覆盖索引<br>        3）分页优化<br>    2）ZOOKEEPER<br>        1）有哪些WATCH以及对应唤醒事件<br>    3）KAFKA<br>        1）分区分服<br>        2）生产者<br>        3）消费者<br>5）语言<br>    1）JAVA语言<br>        1）内存管理<br>6）设计模式<br>    1）单例模式<br>7）项目中的难点、挑战点</p>
<p>22989-腾讯云网络后台开发工程师(CSIG全资子公司)（西安）</p>
<p>建议用online ddl（网上可以查）修改，就是逗号后面的参数<br>另外，添加字段要加上after，根据表结构看看fromWanIp适合在哪个字段后<br>ALTER TABLE cEip ALTER COLUMN ispId SET DEFAULT -1, ALGORITHM&#x3D;INPLACE, LOCK&#x3D;NONE;</p>
<h3 id="HTTP-长连接和-TCP-长连接有什么区别？"><a href="#HTTP-长连接和-TCP-长连接有什么区别？" class="headerlink" title="HTTP 长连接和 TCP 长连接有什么区别？"></a>HTTP 长连接和 TCP 长连接有什么区别？</h3><p>其实就是HTTP 的 Keep-Alive 和 TCP 的 Keepalive 有什么区别？<br>事实上，<strong>这两个完全是两样不同东西</strong>，实现的层面也不同：</p>
<ul>
<li><p>HTTP 的 Keep-Alive，是由<strong>应用层（用户态）</strong> 实现的，称为 HTTP 长连接；</p>
</li>
<li><p>TCP 的 Keepalive，是由 <strong>TCP 层（内核态）</strong> 实现的，称为 TCP 保活机制；</p>
</li>
</ul>
<p>接下来，分别说说它们。</p>
<h4 id="HTTP-的-Keep-Alive"><a href="#HTTP-的-Keep-Alive" class="headerlink" title="HTTP 的 Keep-Alive"></a>HTTP 的 Keep-Alive</h4><p>HTTP 协议采用的是「请求-应答」的模式，也就是客户端发起了请求，服务端才会返回响应，一来一回这样子。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcicwmSuxnPJ1qyiaohMl86ibZhnSbPF3JPicyAmYmy8jQZb5zFKD8tGSDQGkCsrbPD7jJLicqRVet6vrA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>请求-应答</p>
<p>由于 HTTP 是基于 TCP 传输协议实现的，客户端与服务端要进行 HTTP 通信前，需要先建立 TCP 连接，然后客户端发送 HTTP  请求，服务端收到后就返回响应，至此「请求-应答」的模式就完成了，随后就会释放 TCP 连接。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcicwmSuxnPJ1qyiaohMl86ibZcOoBjt1XmlEoAWTf4V6musIJQE5nxsRRe5gjciaDLPJUZbhZowzibMibQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>一个 HTTP 请求</p>
<p>如果每次请求都要经历这样的过程：建立 TCP -&gt; 请求资源 -&gt; 响应资源 -&gt; 释放连接，那么此方式就是 <strong>HTTP 短连接</strong>，如下图：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcicwmSuxnPJ1qyiaohMl86ibZ3ulicF0AUhTNPjyHE5Dur1sI8cda110PRsPmYEenOIBHpZnayHUFkow/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>HTTP 短连接</p>
<p>这样实在太累人了，一次连接只能请求一次资源。</p>
<p>能不能在第一个 HTTP 请求完后，先不断开 TCP 连接，让后续的 HTTP 请求继续使用此连接？</p>
<p>当然可以，HTTP 的 Keep-Alive 就是实现了这个功能，可以使用同一个 TCP 连接来发送和接收多个 HTTP 请求&#x2F;应答，避免了连接建立和释放的开销，这个方法称为 <strong>HTTP 长连接</strong>。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcicwmSuxnPJ1qyiaohMl86ibZAJAJPbK9xMB5j9nTzs87SwRibAU52mG4ILuB3XvpXNll4gKYazoYUaw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>HTTP 长连接</p>
<p>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p>
<p>怎么才能使用 HTTP 的 Keep-Alive 功能？</p>
<p>在 HTTP 1.0 中默认是关闭的，如果浏览器要开启 Keep-Alive，它必须在请求的包头中添加：</p>
<p><code>Connection: Keep-Alive   </code></p>
<p>然后当服务器收到请求，作出回应的时候，它也添加一个头在响应中：</p>
<p><code>Connection: Keep-Alive   </code></p>
<p>这样做，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接。这一直继续到客户端或服务器端提出断开连接。</p>
<p><strong>从 HTTP 1.1 开始， 就默认是开启了 Keep-Alive</strong>，如果要关闭 Keep-Alive，需要在 HTTP 请求的包头里添加：</p>
<p><code>Connection:close   </code></p>
<p>现在大多数浏览器都默认是使用 HTTP&#x2F;1.1，所以 Keep-Alive 都是默认打开的。一旦客户端和服务端达成协议，那么长连接就建立好了。</p>
<p>HTTP 长连接不仅仅减少了 TCP 连接资源的开销，而且这给 <strong>HTTP 流水线</strong>技术提供了可实现的基础。</p>
<p>所谓的 HTTP 流水线，是<strong>客户端可以先一次性发送多个请求，而在发送过程中不需先等待服务器的回应</strong>，可以减少整体的响应时间。</p>
<p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。HTTP 流水线机制则允许客户端同时发出 A 请求和 B 请求。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcicwmSuxnPJ1qyiaohMl86ibZy8Ha8LtNZHu3672NVwlpK4iaf9TibSkhbPfHKZHeruKPYdZ87utlcIIw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>右边为 HTTP 流水线机制</p>
<p>但是<strong>服务器还是按照顺序响应</strong>，先回应 A 请求，完成后再回应 B 请求。</p>
<p>而且要等服务器响应完客户端第一批发送的请求后，客户端才能发出下一批的请求，也就说如果服务器响应的过程发生了阻塞，那么客户端就无法发出下一批的请求，此时就造成了「队头阻塞」的问题。</p>
<p>可能有的同学会问，如果使用了 HTTP 长连接，如果客户端完成一个 HTTP 请求后，就不再发起新的请求，此时这个 TCP 连接一直占用着不是挺浪费资源的吗？</p>
<p>对没错，所以为了避免资源浪费的情况，web 服务软件一般都会提供 <code>keepalive_timeout</code> 参数，用来指定 HTTP 长连接的超时时间。</p>
<p>比如设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会<strong>启动一个定时器</strong>，如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，<strong>定时器的时间一到，就会触发回调函数来释放该连接。</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcicwmSuxnPJ1qyiaohMl86ibZlTIRFic7L5E39WAIhnL2EibUTRwYIqCReFq4J6RKfcmozBP9agZCundA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>HTTP 长连接超时</p>
<h4 id="TCP-的-Keepalive"><a href="#TCP-的-Keepalive" class="headerlink" title="TCP 的 Keepalive"></a>TCP 的 Keepalive</h4><p>TCP 的 Keepalive 这东西其实就是 <strong>TCP 的保活机制</strong>，它的工作原理我之前的文章写过，这里就直接贴下以前的内容。</p>
<p>如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。</p>
<ul>
<li><p>如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</p>
</li>
<li><p>如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</p>
</li>
</ul>
<p>所以，TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活，这个工作是在内核完成的。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcicwmSuxnPJ1qyiaohMl86ibZHmAI3j2722ibjS7IibNtaiaZibbDpMpBPC8OWbfHsEHwcacE0ZRjgc8pibg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>TCP 保活机制</p>
<p>注意，应用程序若想使用 TCP 保活机制需要通过 socket 接口设置 <code>SO_KEEPALIVE</code> 选项才能够生效，如果没有设置，那么就无法使用 TCP 保活机制。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>HTTP 的 Keep-Alive 也叫 HTTP 长连接，该功能是由「应用程序」实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求&#x2F;应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销。</p>
<p>TCP 的 Keepalive 也叫 TCP 保活机制，该功能是由「内核」实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。</p>
<h3 id="HTTPS-一定安全可靠吗？"><a href="#HTTPS-一定安全可靠吗？" class="headerlink" title="HTTPS 一定安全可靠吗？"></a>HTTPS 一定安全可靠吗？</h3><p>客户端通过浏览器向服务端发起 HTTPS 请求时，被「假基站」转发到了一个「中间人服务器」，于是客户端是和「中间人服务器」完成了 TLS 握手，然后这个「中间人服务器」再与真正的服务端完成 TLS 握手。</p>
<p>具体过程如下：<br>![[Pasted image 20230517164728.png]]</p>
<ul>
<li><p>客户端向服务端发起 HTTPS 建立连接请求时，然后被「假基站」转发到了一个「中间人服务器」，接着中间人向服务端发起 HTTPS 建立连接请求，此时客户端与中间人进行 TLS 握手，中间人与服务端进行 TLS 握手；</p>
</li>
<li><p>在客户端与中间人进行 TLS 握手过程中，中间人会发送自己的公钥证书给客户端，<strong>客户端验证证书的真伪</strong>，然后从证书拿到公钥，并生成一个随机数，用公钥加密随机数发送给中间人，中间人使用私钥解密，得到随机数，此时双方都有随机数，然后通过算法生成对称加密密钥（A），后续客户端与中间人通信就用这个对称加密密钥来加密数据了。</p>
</li>
<li><p>在中间人与服务端进行 TLS 握手过程中，服务端会发送从 CA 机构签发的公钥证书给中间人，从证书拿到公钥，并生成一个随机数，用公钥加密随机数发送给服务端，服务端使用私钥解密，得到随机数，此时双方都有随机数，然后通过算法生成对称加密密钥（B），后续中间人与服务端通信就用这个对称加密密钥来加密数据了。</p>
</li>
<li><p>后续的通信过程中，中间人用对称加密密钥（A）解密客户端的 HTTPS 请求的数据，然后用对称加密密钥（B）加密 HTTPS 请求后，转发给服务端，接着服务端发送 HTTPS 响应数据给中间人，中间人用对称加密密钥（B）解密 HTTPS 响应数据，然后再用对称加密密钥（A）加密后，转发给客户端。</p>
</li>
</ul>
<p>从客户端的角度看，其实并不知道网络中存在中间人服务器这个角色。</p>
<p>那么中间人就可以解开浏览器发起的 HTTPS 请求里的数据，也可以解开服务端响应给浏览器的 HTTPS 响应数据。相当于，中间人能够 “偷看” 浏览器与服务端之间的 HTTPS 请求和响应的数据。</p>
<p>但是要发生这种场景是有前提的，<strong>前提是用户点击接受了中间人服务器的证书。</strong></p>
<p>中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0Dm1SNmvUayxCflHTROibNzricwiaRlwzuc1CUqXYTYEapwDNUybxhiaWfofHt7LSuzC4cFdYvwcJoA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>如果用户执意点击「继续浏览此网站」，相当于用户接受了中间人伪造的证书，那么后续整个 HTTPS 通信都能被中间人监听了。</p>
<p>所以，这其实并不能说 HTTPS 不够安全，毕竟浏览器都已经提示证书有问题了，如果用户坚决要访问，那<strong>不能怪 HTTPS ，得怪自己手贱</strong>。</p>
<h4 id="客户端是如何验证证书的？"><a href="#客户端是如何验证证书的？" class="headerlink" title="客户端是如何验证证书的？"></a>客户端是如何验证证书的？</h4><p>接下来，详细说一下实际中数字证书签发和验证流程。</p>
<p>如下图图所示，为数字证书签发和验证流程：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0Dm1SNmvUayxCflHTROibNMxlSGIfI1kiav1TwxTK6ZtGiaCiaygM3g0fFnPYo3n9atZlbhvpkWt77Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">当服务端向 CA 机构申请证书的时候，CA 签发证书的过程，如上图左边部分：</p>
<ul>
<li><p>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</p>
</li>
<li><p>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</p>
</li>
<li><p>最后将 Certificate Signature 添加在文件证书上，形成数字证书；</p>
</li>
</ul>
<p>客户端校验服务端的数字证书的过程，如上图右边部分：</p>
<ul>
<li><p>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</p>
</li>
<li><p>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</p>
</li>
<li><p>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</p>
</li>
</ul>
<p>但事实上，证书的验证过程中<strong>还存在一个证书信任链的问题</strong>，因为我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的，比如百度的证书，从下图你可以看到，证书的层级有三级：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0Dm1SNmvUayxCflHTROibNVINCkWDhqk7OiaibpvuUnYAt2GXtShM9z5bWCG1TSZH6LzzylakSk83w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>对于这种三级层级关系的证书的验证过程如下：</p>
<ul>
<li><p>客户端收到 baidu.com 的证书后，发现这个证书的签发者不是根证书，就无法根据本地已有的根证书中的公钥去验证 baidu.com 证书是否可信。于是，客户端根据 baidu.com 证书中的签发者，找到该证书的颁发机构是 “GlobalSign Organization Validation CA - SHA256 - G2”，然后向 CA 请求该中间证书。</p>
</li>
<li><p>请求到证书后发现 “GlobalSign Organization Validation CA - SHA256 - G2” 证书是由 “GlobalSign Root CA” 签发的，由于 “GlobalSign Root CA” 没有再上级签发机构，说明它是根证书，也就是自签证书。应用软件会检查此证书有否已预载于根证书清单上，如果有，则可以利用根证书中的公钥去验证 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，如果发现验证通过，就认为该中间证书是可信的。</p>
</li>
<li><p>“GlobalSign Organization Validation CA - SHA256 - G2” 证书被信任后，可以使用 “GlobalSign Organization Validation CA - SHA256 - G2” 证书中的公钥去验证 baidu.com 证书的可信性，如果验证通过，就可以信任 baidu.com 证书。</p>
</li>
</ul>
<p>在这四个步骤中，最开始客户端只信任根证书 GlobalSign Root CA 证书的，然后 “GlobalSign Root CA” 证书信任 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，而 “GlobalSign Organization Validation CA - SHA256 - G2” 证书又信任 baidu.com 证书，于是客户端也信任 baidu.com 证书。总括来说，由于用户信任 GlobalSign，所以由 GlobalSign 所担保的 baidu.com 可以被信任，另外由于用户信任操作系统或浏览器的软件商，所以由软件商预载了根证书的 GlobalSign 都可被信任。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0Dm1SNmvUayxCflHTROibNIPhXyF7S1WDIbuUbGwgLjwr47iau48ape1H3GYg8B0hDEKeqdz7xZgg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>操作系统里一般都会内置一些根证书，比如我的 MAC 电脑里内置的根证书有这么多：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0Dm1SNmvUayxCflHTROibNloHzrlsep6vZgNvz8sA8LDBHnAWyErqcpicRM6kovSB5L3IQcjdD5aw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这样的一层层地验证就构成了一条信任链路，整个证书信任链验证流程如下图所示：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0Dm1SNmvUayxCflHTROibNFruFDENMpzLgnfRH9T8uN0TAOItwoqia9mXLNLsE7UErltjyBu2zicNQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>如果你的电脑中毒了，被恶意导入了中间人的根证书，那么在验证中间人的证书的时候，由于你操作系统信任了中间人的根证书，那么等同于中间人的证书是合法的。</p>
<p>这种情况下，浏览器是不会弹出证书存在问题的风险提醒的。</p>
<p>这其实也不关 HTTPS 的事情，是你电脑中毒了才导致 HTTPS 数据被中间人劫持的。</p>
<p>所以，<strong>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全。</strong></p>
<h4 id="为什么抓包工具能截取-HTTPS-数据？"><a href="#为什么抓包工具能截取-HTTPS-数据？" class="headerlink" title="为什么抓包工具能截取 HTTPS 数据？"></a>为什么抓包工具能截取 HTTPS 数据？</h4><p>抓包工具 Fiddler 之所以可以明文看到 HTTPS 数据，工作原理与中间人一致的。</p>
<p>对于 HTTPS 连接来说，中间人要满足以下两点，才能实现真正的明文代理:</p>
<ol>
<li><p>中间人，作为客户端与真实服务端建立连接这一步不会有问题，因为服务端不会校验客户端的身份；</p>
</li>
<li><p>中间人，作为服务端与真实客户端建立连接，这里会有客户端信任服务端的问题，也就是服务端必须有对应域名的私钥；</p>
</li>
</ol>
<p>中间人要拿到私钥只能通过如下方式：</p>
<ol>
<li><p>去网站服务端拿到私钥；</p>
</li>
<li><p>去CA处拿域名签发私钥；</p>
</li>
<li><p>自己签发证书，且被浏览器信任；</p>
</li>
</ol>
<p>不用解释，抓包工具只能使用第三种方式取得中间人的身份。</p>
<p>使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装 Fiddler 的根证书，这里实际上起认证中心（CA）的作用。</p>
<p>Fiddler 能够抓包的关键是客户端会往系统受信任的根证书列表中导入 Fiddler 生成的证书，而这个证书会被浏览器信任，也就是 Fiddler 给自己创建了一个认证中心 CA。</p>
<p>客户端拿着中间人签发的证书去中间人自己的 CA 去认证，当然认为这个证书是有效的。</p>
<h4 id="如何避免被中间人抓取数据？"><a href="#如何避免被中间人抓取数据？" class="headerlink" title="如何避免被中间人抓取数据？"></a>如何避免被中间人抓取数据？</h4><p>我们要保证自己电脑的安全，不要被病毒乘虚而入，而且也不要点击任何证书非法的网站，这样 HTTPS 数据就不会被中间人截取到了。</p>
<p>当然，我们还可以通过 HTTPS 双向认证来避免这种问题。</p>
<p>一般我们的 HTTPS 是单向认证，客户端只会验证了服务端的身份，但是服务端并不会验证客户端的身份。</p>
<p>如果用了双向认证方式，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0Dm1SNmvUayxCflHTROibNccBibe4MEf260dWmCfGnvHgz7iaZza3s1Sq6UwibbuGickDfMIcwAlGBGQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。</p>
<h3 id="客户端连接一个不存在的-IP-地址，会发生什么？客户端连接一个存在的-IP-地址但是端口不存在，会发生什么？"><a href="#客户端连接一个不存在的-IP-地址，会发生什么？客户端连接一个存在的-IP-地址但是端口不存在，会发生什么？" class="headerlink" title="客户端连接一个不存在的 IP 地址，会发生什么？客户端连接一个存在的 IP 地址但是端口不存在，会发生什么？"></a>客户端连接一个不存在的 IP 地址，会发生什么？客户端连接一个存在的 IP 地址但是端口不存在，会发生什么？</h3><p>PS：这里的「连接」指的是 TCP 连接。</p>
<blockquote>
<p>Q1：客户端连接一个不存在的 IP 地址，会发生什么？</p>
</blockquote>
<p>这个问题要分两种情况来思考，不同的情况得到的结论是不同的。</p>
<p><em>第一个情况：目标 IP 地址和客户端的 IP 地址是同一个局域网（网络号相同）。</em></p>
<p>第一种情况，客户端无法发出 SYN 报文，主要卡在数据链路层。</p>
<p>因为目标地址不存在 IP 地址，客户端的内核在发 arp 请求的时候，广播询问这个目标 IP 地址是谁的，由于网络中不存在该目标 IP 地址，所以没有设备应答客户端的 arp 请求。</p>
<p>由于<strong>客户端无法拿到目标设备的 MAC，这样就没办法组装 MAC 头的信息，所以 SYN 报文无法发送出去</strong>。</p>
<p><em>第二个情况：目标 IP 地址和客户端的 IP 地址不在同一个局域网（网络号不同）。</em></p>
<p>第二种情况，客户端会先将 SYN 报文发给路由器，然后路由器会继续转发。</p>
<p>由于目标 IP 地址是不存在的，该 SYN 报文会在网络中消亡，因此客户端是不会收到对 SYN 报文的确认报文的，接着<strong>客户端会触发超时重传，重传 SYN 报文，直到重传的次数达到最大次数后，客户端的连接就会被释放</strong>。</p>
<p>可能有的同学好奇，为什么这种情况客户端的 SYN 报文可以发出来？</p>
<p>因为当目标 IP 地址和客户端 IP 地址不在同一个局域网时，客户端客通过路由表的判断，判断到下一步是要将网络报文发送给路由器。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfm4PfB688v0rxFhJb6z15lQyA1upkFc3DxHn6sJ50fuyvdBMNTQUZ1FK1d5qM2C9ibWQP0eOKpcaw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这时候数据链路层的 arp 请求，会广播询问 IP 地址（路由器 IP 地址）是谁的，路由器发现是自己的 IP 地址，于是就会将自己的 MAC 地址告诉客户端。</p>
<p>然后客户端的网络报文中 MAC 头的「目标 MAC 地址」填入的就是路由器的 MAC 地址，于是 SYN 报文就可以发送出去了。</p>
<p>由于目标 MAC 地址是路由器的，所以就会被路由器接收，然后路由器继续通过路由表的判断，转发给下一个路由器，直到找到目标设备。</p>
<blockquote>
<p>Q2：客户端连接一个存在的 IP 地址但是端口不存在，会发生什么？</p>
</blockquote>
<p>客户端连接的目标 IP 地址是存在的，那么 SYN 报文就能正确的抵达到目标设备。</p>
<p>目标设备收到 SYN 报文后，发现端口号并没有被进程监听，这时候目标设备的内核就会回 RST 报文。</p>
<p>客户端收到 RST 报文后，就会释放连接。</p>
<p>…….</p>
<p>至此，结论已说完。</p>
<p>不知道你们会不会觉得信息量很大，如果你觉得信息量大，那么你该补补网络知识啦。</p>
<p>第二题不难，难在的是第一题，如果你没有把两台电脑之间是怎么通信的搞清楚，那么你是无从下手回答的，所以建立好体系化的网络知识，面对这类的场景题目，就能做到举一反三了。</p>
<p>最近比较忙，偷懒了，没有画图，如果哪里没理解的，可以先看我以前写的这篇文章：<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247483989&idx=1&sn=7e2ed852770743d3955ef9d5561fcef3&chksm=f98e46ffcef9cfe98e6c753afac86125b0d5891ca5e63968b5f3a8da4905d14274088f40c34e&scene=21#wechat_redirect">探究！一个数据包在网络中的心路历程</a>，有详细讲解每一层是怎么封装头部的，以及路由表是怎么判断的。</p>
<p><strong>最后再提一个问题：****客户端发送了一个目标 IP 地址存在但是</strong>端口不存在的 UDP 报文<strong>，UDP 没有像 TCP 那样的 RST 报文，此时会发生什么？</strong></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-26T09:35:22.714Z" title="1/26/2024, 5:35:22 PM">2024-01-26</time>发表</span><span class="level-item"><time dateTime="2024-01-31T07:48:49.725Z" title="1/31/2024, 3:48:49 PM">2024-01-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/100-CoderSkills/">100_CoderSkills</a><span> / </span><a class="link-muted" href="/categories/100-CoderSkills/103-DesignMode/">103_DesignMode</a></span><span class="level-item">1 小时读完 (大约12877个字)</span></div></div><div class="content"><hr>
<p>00_DesignModeInterview<br>aliases:<br>tags: #cs#interview #design<br>date: 2023-10-08 15:29</p>
<hr>
<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><ul>
<li><p>1.全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？<br>  <code>  可以，在不同的C文件中以static形式来声明同名全局变量。可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错.  </code></p>
</li>
<li><p>2.static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？Static函数与普通函数有什么区别？<br>  <code>  (1)把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。    全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。(2)把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。(3)static函数与普通函数作用域不同,仅在本文件。    综上所述:     static全局变量与普通的全局变量有什么区别：    static全局变量只初使化一次，防止在其他文件单元中被引用;    static局部变量和普通局部变量有什么区别：    static局部变量只被初始化一次，下一次依据上一次结果值；    static函数与普通函数有什么区别：    static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝  </code></p>
</li>
<li><p>3.以下代码存在的问题？<br>  <code>  char string[] = “Linux C”;   char *p = “Linux C”;   string[0] = &#39;a&#39;;   p[0] = &#39;a&#39;;   注：”Linux C”是一个字符串常量。C语言对于字符串常量通常是这样处理的：在内存中开辟一个字符数组来存储该字符串常量，并把开辟出的字符数组的首地址赋给p.   注：string[0] = ‘a’是可以的，而p[0] = ‘a’是非法的，因为p指向的是字符串常量，常量的内容不可改变。把p指向一个字符串常量或字符数组时合法的，例如：p = “Hello World!”; p= string;</code></p>
</li>
<li><ol start="4">
<li>写一个实现字符串拷贝的函数。给定字符串拷贝函数strcpy的原型：<br>char *strcpy(char *dest,const char *src); 要求：（1）不调用任何库函数。（2）说明函数为什么返回char *.<br>  <code>  char *strcpy(char *dest,char *src) &#123;   if( (dest == NULL) || (src == NULL) )   &#123;   return NULL;   &#125;   char *ret_string = dest;   while( *dest ++ = *src++)!=’\0′);   return ret_string;   &#125;  </code></li>
</ol>
</li>
</ul>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><ul>
<li>可变类型与不可变类型，如何判断一个变量是可变还是不可变</li>
<li>逻辑表达式中，哪些值是假？（0，空串，空容器，False，None）</li>
<li>列表和元组有什么不同？</li>
<li>range和xrange有什么区别？</li>
<li>for循环如何同时遍历索引和值</li>
<li>什么是静态方法，如何定义</li>
<li>静态方法和类方法的区别是什么？</li>
<li>list如何去重？</li>
<li>如何判断字符串是否含有某个字串（in比str.find好）为什么？</li>
<li>is None和&#x3D;&#x3D; None有什么区别？</li>
<li>什么是GIL</li>
<li>type isinstance区别</li>
<li>字符串拼接用 join和+的区别</li>
<li>python实现单例</li>
<li></li>
</ul>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h2 id="上机编程"><a href="#上机编程" class="headerlink" title="上机编程"></a>上机编程</h2><p>编程题本身不考察算法掌握程度，但是考察基本的逻辑思维，把算法转换为代码的能力，以及基本的错误处理。现场面试用纸笔，白板，电脑都可以，远程面试可以用在线代码平台，比如<a target="_blank" rel="noopener" href="http://collabedit.com/">collabedit</a>，<a target="_blank" rel="noopener" href="https://codeshare.io/">codeshare.io</a>，<a target="_blank" rel="noopener" href="https://codeinterview.io/">codeinterview.io</a><br>复杂的算法不太容易验证，二十行内能解决的不太复杂的算法题为宜，速度越快越好，代码不能有明显的语法错误和低级错误，例如：</p>
<h3 id="1-纯算法"><a href="#1-纯算法" class="headerlink" title="1. 纯算法"></a>1. 纯算法</h3><ul>
<li>链表逆序</li>
<li>二叉树求宽度&#x2F;深度</li>
<li>字符串处理：Split, Trim，逆序</li>
<li>编码：UTF8编解码，Varint编解码，十六进制编解码</li>
<li>数组去重，保持顺序 [1, 2, 3, 1, 2] -&gt; [1, 2, 3]</li>
<li>数组去重，保持顺序，后面的出现后，前面的去掉，[1, 2, 3, 2, 1] -&gt; [3, 2, 1]</li>
<li>位图中查找第一个设置&#x2F;未设置的位的偏移量</li>
</ul>
<h3 id="2-接口设计"><a href="#2-接口设计" class="headerlink" title="2. 接口设计"></a>2. 接口设计</h3><ul>
<li>比如String类的接口设计（构造函数，拷贝，赋值，拼接等），用数组实现循环队列</li>
<li>可以考察一些函数的实现，比如String类+&#x3D;的实现，主要关注正确性和内存泄漏和越界</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h2 id="人员本身"><a href="#人员本身" class="headerlink" title="人员本身"></a>人员本身</h2><ul>
<li>自我介绍</li>
<li>项目亮点难点</li>
<li>项目的领域模型可以画一下吗？</li>
</ul>
<h2 id="JD"><a href="#JD" class="headerlink" title="JD"></a>JD</h2><p>腾讯云后端开发工程师（西安）</p>
<p>职责：<br>负责腾讯云网络产品的研发与设计工作，打造更稳定、安全、高效和可靠的专业后台支撑体系， 保障海量网络业务的稳定运行。</p>
<p>必须具备的：<br>1、本科及以上学历，计算机相关专业，三年以上后台开发工作经验；<br>2、熟悉Linux操作系统下C++、python(或php)开发，能运用常见工具定位和调试问题代码；<br>3、熟悉http、tcp&#x2F;ip协议， 进程间通讯编程，多线程编程等，熟悉Linux常见网络服务器模型；<br>4、具有扎实的软件开发基础知识，包括算法、操作系统、软件工程、设计模式、数据结构、数据库系统、网络安全等；<br>5、具有良好的团队合作、沟通与口头、书面表达能力， 严谨的工作态度与高质量意识；<br>6、对新技术敏感，求知欲强，能快速学习并具备较强的技术领悟能力。</p>
<p>有一定了解的：<br>1、Shell 、 Perl 等脚本语言；<br>2、MySQL及 SQL 语言、编程；<br>3、Docker、K8s、Nginx等常用技术组件；<br>4、常见的网络协议，包括但不限于arp、ip、vpn、gre等。</p>
<p>可以加分的：<br>1、具备分布式系统设计与开发、负载均衡技术、系统容灾设计、高可用系统等知识；<br>2、通过腾讯云从业资格证认证或同等资格认证。</p>
<p>注：此岗位为腾讯集团旗下全资子公司编制岗位  base 西安 雁塔区</p>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p><em>*<em>*10、什么函数不能声明为虚函数？*</em>**<br>*</em>*<em>**答：**constructor*</em>**</p>
<p><em>*<em>*12、不能做switch()的参数类型*</em>**<br>*</em>*<em>**答** **：**switch的参数不能为实型。*</em>**</p>
<p><em>*<em>*14、如何引用一个已经定义过的全局变量？*</em>**<br>*</em>*<em>**答** **、可以用引用头文件的方式，也可以用**extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变量，假定你将那个变量写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。*</em>**</p>
<p>虚函数： 实现类的多态性</p>
<p>关键字：虚函数；虚函数的作用；多态性；多态公有继承；动态联编</p>
<p>C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数；在派生类中对基类定义的虚函数进行重写时，需要再派生类中声明该方法为虚方法。</p>
<p>当子类重新定义了父类的虚函数后，当父类的指针指向子类对象的地址时，[即B b; A a &#x3D; &amp;b;] 父类指针根据赋给它的不同子类指针，动态的调用子类的该函数，而不是父类的函数（如果不使用virtual方法，请看后面★*），且这样的函数调用发生在运行阶段，而不是发生在编译阶段，称为动态联编。而函数的重载可以认为是多态，只不过是静态的。注意，非虚函数静态联编，效率要比虚函数高，但是不具备动态联编能力。</p>
<p>★如果使用了virtual关键字，程序将根据引用或指针指向的 对 象 类 型 来选择方法，否则使用引用类型或指针类型来选择方法。</p>
<p>下面的例子解释动态联编性：</p>
<p>————————————————<br>版权声明：本文为CSDN博主「BigoSprite」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/iFuMI/article/details/51088091">https://blog.csdn.net/iFuMI/article/details/51088091</a></p>
<p>实现原理：虚函数表+虚表指针</p>
<p>关键字：虚函数底层实现机制；虚函数表；虚表指针</p>
<p>编译器处理虚函数的方法是：为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，称为虚表指针（vptr），这种数组成为虚函数表（virtual function table, vtbl），即，每个类使用一个虚函数表，每个类对象用一个虚表指针。</p>
<p>举个例子：基类对象包含一个虚表指针，指向基类中所有虚函数的地址表。派生类对象也将包含一个虚表指针，指向派生类虚函数表。看下面两种情况：</p>
<p>如果派生类重写了基类的虚方法，该派生类虚函数表将保存重写的虚函数的地址，而不是基类的虚函数地址。</p>
<p>如果基类中的虚方法没有在派生类中重写，那么派生类将继承基类中的虚方法，而且派生类中虚函数表将保存基类中未被重写的虚函数的地址。注意，如果派生类中定义了新的虚方法，则该虚函数的地址也将被添加到派生类虚函数表中。<br>————————————————<br>版权声明：本文为CSDN博主「BigoSprite」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/iFuMI/article/details/51088091">https://blog.csdn.net/iFuMI/article/details/51088091</a></p>
<p>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/4ef1d67edee049c78aa597067c519246">https://www.nowcoder.com/questionTerminal/4ef1d67edee049c78aa597067c519246</a><br>来源：牛客网</p>
<p>参见《Effective C++》 条款09：绝不在构造函数或析构函数中调用虚函数。</p>
<p>  这个链接有电子档：<a target="_blank" rel="noopener" href="http://blog.csdn.net/hxz_qlh/article/details/14089895">http://blog.csdn.net/hxz_qlh/article/details/14089895</a></p>
<p>  简要结论：</p>
<p>  １.　从语法上讲，调用完全没有问题。</p>
<p>  ２.　但是从效果上看，往往不能达到需要的目的。</p>
<p>  Effective 的解释是：</p>
<p>  派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。</p>
<p>  同样，进入基类析构函数时，对象也是基类类型。</p>
<p>  所以，虚函数始终仅仅调用基类的虚函数（如果是基类调用虚函数），不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果。</p>
<h3 id="2-3-依赖倒置原则"><a href="#2-3-依赖倒置原则" class="headerlink" title="2.3 依赖倒置原则"></a>2.3 依赖倒置原则</h3><blockquote>
<p>抽象不应该依赖于具体类，具体类应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</p>
</blockquote>
<p>依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。</p>
<p>在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。</p>
<p><strong>优点：通过抽象来搭建框架，建立类和类的关联，以减少类间的耦合性。而且以抽象搭建的系统要比以具体实现搭建的系统更加稳定，扩展性更高，同时也便于维护。</strong></p>
<p>作者：xietao3<br>链接：<a target="_blank" rel="noopener" href="https://juejin.im/post/5c8756e6e51d456cda2e7ff1">https://juejin.im/post/5c8756e6e51d456cda2e7ff1</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>单例模式（Singleton Pattern）</p>
<p>观察者模式(Observer Pattern)：定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式的别名包括发布-订阅（Publish&#x2F;Subscribe）模式、模型-视图（Model&#x2F;View）模式、源-监听器（Source&#x2F;Listener）模式或从属者（Dependents）模式。观察者模式是一种对象行为型模式。</p>
<p>作者：xietao3<br>链接：<a target="_blank" rel="noopener" href="https://juejin.im/post/5c8756e6e51d456cda2e7ff1">https://juejin.im/post/5c8756e6e51d456cda2e7ff1</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="3-详细介绍一下TCP的四次挥手机制，为什么要有TIME-WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE-WAIT状态如何解决"><a href="#3-详细介绍一下TCP的四次挥手机制，为什么要有TIME-WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE-WAIT状态如何解决" class="headerlink" title="3. 详细介绍一下TCP的四次挥手机制，为什么要有TIME_WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE_WAIT状态如何解决"></a>3. 详细介绍一下TCP的四次挥手机制，为什么要有TIME_WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE_WAIT状态如何解决</h3><p>当客户端要服务器断开连接时，客户端 TCP 会向服务器发送一个特殊的报文段，该报文段的 FIN 标志位会被置1，接着服务器会向客户端发送一个确认报文段。然后服务器也会客户端发送一个 FIN 标志位为1的终止报文段，随后客户端回送一个确认报文段，服务器立即断开连接。客户端等待一段时间后也断开连接。</p>
<p>其实四次挥手的过程是很容易理解的，由于 TCP 协议是全双工的，也就是说客户端和服务端都可以发起断开连接。两边各发起一次断开连接的申请，加上各自的两次确认，看起来就像执行了四次挥手。</p>
<p>为什么要有 TIME_WAIT 状态？因为客户端最后向服务器发送的确认 ACK 是有可能丢失的，当出现超时，服务端会再次发送 FIN 报文段，如果客户端已经关闭了就收不到了。还有一点是避免新旧连接混杂。</p>
<p>大量 CLOSE_WAIT 表示程序出现了问题，对方的 socket 已经关闭连接，而我方忙于读或写没有及时关闭连接，需要检查代码，特别是释放资源的代码，或者是处理请求的线程配置</p>
<p>\3. TIME_WAIT状态<br>    经过前面的铺垫，终于要讲到与本文主题相关的内容了。 ^_^<br>    从TCP状态迁移图可知，只有首先调用close()发起主动关闭的一方才会进入TIME_WAIT状态，而且是必须进入（图中左下角所示的3条状态迁移线最终均要进入该状态才能回到初始的CLOSED状态）。<br>    从图中还可看到，进入TIME_WAIT状态的TCP连接需要经过2MSL才能回到初始状态，其中，MSL是指Max<br>Segment Lifetime，即数据包在网络中的最大生存时间。每种TCP协议的实现方法均要指定一个合适的MSL值，如RFC1122给出的建议值为2分钟，又如Berkeley体系的TCP实现通常选择30秒作为MSL值。这意味着TIME_WAIT的典型持续时间为1-4分钟。<br>    TIME_WAIT状态存在的原因主要有两点：<br>    1）为实现TCP这种全双工（full-duplex）连接的可靠释放<br>    参考本文前面给出的TCP释放连接4次挥手示意图，假设发起active close的一方（图中为client）发送的ACK（4次交互的最后一个包）在网络中丢失，那么由于TCP的重传机制，执行passiveclose的一方（图中为server）需要重发其FIN，在该FIN到达client（client是active close发起方）之前，client必须维护这条连接的状态（尽管它已调用过close），具体而言，就是这条TCP连接对应的（local_ip, local_port）资源不能被立即释放或重新分配。直到romete peer重发的FIN达到，client也重发ACK后，该TCP连接才能恢复初始的CLOSED状态。如果activeclose方不进入TIME_WAIT以维护其连接状态，则当passive close方重发的FIN达到时，active close方的TCP传输层会以RST包响应对方，这会被对方认为有错误发生（而事实上，这是正常的关闭连接过程，并非异常）。<br>    2）为使旧的数据包在网络因过期而消失<br>    为说明这个问题，我们先假设TCP协议中不存在TIME_WAIT状态的限制，再假设当前有一条TCP连接：(local_ip, local_port, remote_ip,remote_port)，因某些原因，我们先关闭，接着很快以相同的四元组建立一条新连接。本文前面介绍过，TCP连接由四元组唯一标识，因此，在我们假设的情况中，TCP协议栈是无法区分前后两条TCP连接的不同的，在它看来，这根本就是同一条连接，中间先释放再建立的过程对其来说是“感知”不到的。这样就可能发生这样的情况：前一条TCP连接由local peer发送的数据到达remote peer后，会被该remot peer的TCP传输层当做当前TCP连接的正常数据接收并向上传递至应用层（而事实上，在我们假设的场景下，这些旧数据到达remote peer前，旧连接已断开且一条由相同四元组构成的新TCP连接已建立，因此，这些旧数据是不应该被向上传递至应用层的），从而引起数据错乱进而导致各种无法预知的诡异现象。作为一种可靠的传输协议，TCP必须在协议层面考虑并避免这种情况的发生，这正是TIME_WAIT状态存在的第2个原因。<br>    具体而言，local peer主动调用close后，此时的TCP连接进入TIME_WAIT状态，处于该状态下的TCP连接不能立即以同样的四元组建立新连接，即发起active close的那方占用的local port在TIME_WAIT期间不能再被重新分配。由于TIME_WAIT状态持续时间为2MSL，这样保证了旧TCP连接双工链路中的旧数据包均因过期（超过MSL）而消失，此后，就可以用相同的四元组建立一条新连接而不会发生前后两次连接数据错乱的情况。</p>
<p>另一比较深入的说法</p>
<p>TIME_WAIT状态的存在有两个理由：（1）让4次握手关闭流程更加可靠；4次握手的最后一个ACK是是由主动关闭方发送出去的，若这个ACK丢失，被动关闭方会再次发一个FIN过来。若主动关闭方能够保持一个2MSL的TIME_WAIT状态，则有更大的机会让丢失的ACK被再次发送出去。（2）防止lost duplicate对后续新建正常链接的传输造成破坏。lost duplicate在实际的网络中非常常见，经常是由于路由器产生故障，路径无法收敛，导致一个packet在路由器A，B，C之间做类似死循环的跳转。IP头部有个TTL，限制了一个包在网络中的最大跳数，因此这个包有两种命运，要么最后TTL变为0，在网络中消失；要么TTL在变为0之前路由器路径收敛，它凭借剩余的TTL跳数终于到达目的地。但非常可惜的是TCP通过超时重传机制在早些时候发送了一个跟它一模一样的包，并先于它达到了目的地，因此它的命运也就注定被TCP协议栈抛弃。另外一个概念叫做incarnation connection，指跟上次的socket pair一摸一样的新连接，叫做incarnation of previous connection。lost duplicate加上incarnation connection，则会对我们的传输造成致命的错误。大家都知道TCP是流式的，所有包到达的顺序是不一致的，依靠序列号由TCP协议栈做顺序的拼接；假设一个incarnation connection这时收到的seq&#x3D;1000, 来了一个lost duplicate为seq&#x3D;1000, len&#x3D;1000, 则tcp认为这个lost duplicate合法，并存放入了receive buffer，导致传输出现错误。通过一个2MSL TIME_WAIT状态，确保所有的lost duplicate都会消失掉，避免对新连接造成错误。</p>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>从上面的图可以看到滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。</p>
<p>可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。</p>
<p>接着就讲讲什么是流量控制窗口，什么是拥塞控制窗口。</p>
<p>先讲流量控制：</p>
<p>TCP 是全双工的，客户端和服务器均可作为发送方或接收方，我们现在假设一个发送方向接收方发送数据的场景来讲解流量控制。首先我们的接收方有一块接收缓存，当数据来到时会先把数据放到缓存中，上层应用等缓存中有数据时就会到缓存中取数据。假如发送方没有限制地不断地向接收方发送数据，接收方的应用程序又没有及时把接收缓存中的数据读走，就会出现缓存溢出，数据丢失的现象，为了解决这个问题，我们引入流量控制窗口。</p>
<p>假设应用程序最后读走的数据序号是 lastByteRead，接收缓存中接收到的最后一个数据序号是 lastByteRcv，接收缓存的大小为 RcvSize，那么必须要满足 lastByteRcv - lastByteRead &lt;&#x3D; RcvSize 才能保证接收缓存不会溢出，所以我们定义流量窗口为接收缓存剩余的空间，也就是Rcv &#x3D; RcvSize - (lastByteRcv - lastByteRead)。只要接收方在响应 ACK 的时候把这个窗口的值带给发送方，发送方就能知道接收方的接收缓存还有多大的空间，进而设置滑动窗口的大小。</p>
<p>接着讲解拥塞控制：</p>
<p>拥塞控制是指发送方先设置一个小的窗口值作为发送速率，当成功发包并接收到ACK时，便以指数速率增大发送窗口的大小，直到遇到丢包（超时&#x2F;三个冗余ACK），才停止并调整窗口的大小。这么做能最大限度地利用带宽，又不至于让网络环境变得太过拥挤。</p>
<p>最终滑动窗口的值将设置为流量控制窗口和拥塞控制窗口中的较小值。</p>
<p>Q: 编写 TCP&#x2F;SOCK_STREAM 服务程序时，SO_REUSEADDR到底什么意思？</p>
<p>A: 这个套接字选项通知内核，如果端口忙，但TCP状态位于 TIME_WAIT ，可以重用端口。如果端口忙，而TCP状态位于其他状态，重用端口时依旧得到一个错误信息， 指明”地址已经使用中”。如果你的服务程序停止后想立即重启，而新套接字依旧 使用同一端口，此时 SO_REUSEADDR 选项非常有用。必须意识到，此时任何非期 望数据到达，都可能导致服务程序反应混乱，不过这只是一种可能，事实上很不可能。</p>
<p>　CLOSE_WAIT： 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。</p>
<h3 id="5-讲一下HTTP与HTTPS的区别"><a href="#5-讲一下HTTP与HTTPS的区别" class="headerlink" title="5. 讲一下HTTP与HTTPS的区别"></a>5. 讲一下HTTP与HTTPS的区别</h3><p>HTTP和HTTPS的主要区别在于HTTP协议传递的是明文数据，而HTTPS传递的是加密过的数据，也就是说HTTPS更具有安全性。也正由HTTPS需要保证安全性，所以它的性能要比HTTP差一点。</p>
<p>单说安全性肯定是不够的，我打算扩展讲一下HTTPS是怎么解决安全性问题的，通过这些HTTP没有机制，反映出HTTPS与HTTP的区别。下面尝试把HTTPS加密的过程推导出来。推导过程不涉及复杂的实现细节：</p>
<h4 id="如何安全地进行数据传输？"><a href="#如何安全地进行数据传输？" class="headerlink" title="如何安全地进行数据传输？"></a>如何安全地进行数据传输？</h4><p>假设现在A和B要进行安全的通信，那么究竟怎样才算是安全的通信？很自然地会想到：A和B之间传递数据，这些数据只有A和B才看得懂，中间人就算截取了信息但也看不懂，这才算得上安全。</p>
<h4 id="安全通信的处理手段："><a href="#安全通信的处理手段：" class="headerlink" title="安全通信的处理手段："></a>安全通信的处理手段：</h4><p>为了能让A和B才能看懂，就必须要对数据进行加密，而且首先想到的就是对称加密。对称加密的意思是A和B各持有一个相同的密钥，它们传递信息时会用密钥给信息加密，在消息到达端给消息解密，完成安全通信。</p>
<p>在对称加密中又会涉及到加密算法的选择问题。现实世界中，通常是多个客户端面向一个服务器的情况，不可能让每个客户端和服务器之间都采用相同的加密算法，如果是这样那和没加密差不多。所以注定每个客户端和服务器之间都会采用不同的加密方式。</p>
<h4 id="如何让每个客户端与服务器之间都采用不同的加密方式？"><a href="#如何让每个客户端与服务器之间都采用不同的加密方式？" class="headerlink" title="如何让每个客户端与服务器之间都采用不同的加密方式？"></a>如何让每个客户端与服务器之间都采用不同的加密方式？</h4><p>要想对不同的机器使用不同的加密方式，最直接想到的就是使用随机数。也就说客户端和服务器之间每次都基于一个随机数产生加密算法。（具体实现时为了保证随机，用到还不止一个随机数）</p>
<p>这个产生加密算法的过程称之为协商，现在问题是协商的过程是透明的，也就是说中间人可以截获协商的过程，从而知道我们的加密方式。为了解决这个问题，我们需要对协商的过程进行加密。</p>
<h4 id="如何对协商的过程进行加密？"><a href="#如何对协商的过程进行加密？" class="headerlink" title="如何对协商的过程进行加密？"></a>如何对协商的过程进行加密？</h4><p>之所以能来到这一步，是因为我们一开始就选择使用了对称加密，也就说一开始的对称加密导致了现在的问题，所以这时我们不能再使用对称加密了，否则会陷入死循环。</p>
<p>在密码学领域，还有一种加密过程叫非对称加密，它的逻辑是这样的：通信双方一方持有私钥，一方持有公钥，经过私钥加密的信息，都能通过公钥进行解密。但是经过公钥加密的数据，只有私钥可以解密。</p>
<p>按照非对称加密的规则，我们让服务器持有私钥，让客户端持有公钥。这样就能保证客户端给服务器发送消息的时候是安全的（相反，服务器给客户端发送消息就是不安全的），我们可以把协商时重要的逻辑安排在客户端给服务器发送信息的过程中，从而保证了协商过程的安全性。</p>
<h4 id="客户端如何获得公钥？"><a href="#客户端如何获得公钥？" class="headerlink" title="客户端如何获得公钥？"></a>客户端如何获得公钥？</h4><p>现在用非对称加密算法解决了协商的安全问题，但是非对称加密的前提是客户端需要获得公钥，这又是一个问题了，客户端与服务器打交道之前是互不知道双方身份的，怎么才能让客户端获得公钥呢？</p>
<p>也就只有两种办法：</p>
<ol>
<li>客户端向服务器要公钥</li>
<li>客户端向一个远程的公共服务器获取公钥</li>
</ol>
<p>方法2显然是不行的，尚且不说多了一个访问节点，如何找到公共服务器的地址也是一个待解决的问题，所以还是使用方法1。</p>
<p>但是方法1存在一个问题：如果中间人把服务器发送给客户端的公钥调包了怎么办？也就是说客户端无法知道发送公钥的是否是正真的服务器。</p>
<h4 id="引入第三方机构解决问题"><a href="#引入第三方机构解决问题" class="headerlink" title="引入第三方机构解决问题"></a>引入第三方机构解决问题</h4><p>客户端无法辨识服务端和中间人的问题称为“身份验证”问题，也就是说我们需要为服务器向客户端发送公钥的过程进行加密。</p>
<p>这下完了，之前我们因遇到对称加密的瓶颈选择了非对称加密，现在使用非对称加密也遇到了瓶颈。显然这两种加密方式都是不可用的了，否则会再次陷入死循环。</p>
<p>接下来我们只好通过第三方机构的介入，解决这个问题。首先我们自己保存有第三方权威机构的公钥，然后第三方机构使用私钥对服务器将要发送给客户端的公钥进行加密，客户端接收到这个经加密的公钥后（数字证书），就能通过自己保存的第三方机构公钥进行解密。</p>
<blockquote>
<p>到这里为止，我们解释了HTTPS中使用到的对称加密，非对称加密，CA，数字证书的概念，但是还差一个叫数字签名的概念没有解释。</p>
</blockquote>
<p>在现实生活中，CA不单止会给我们正常公司发放证书，还会给中间人的坏公司发放证书，如果中间人把发放的证书调包了怎么办？这时我们仍能用CA的私钥进行解密，但是证书已经被调包了。</p>
<p>那么客户端怎样验证证书的真伪呢？答案是证书本身会告诉客户端如何辨认真伪。比方说证书上面有一个证书编号，还有一个如何计算证书编号的方法，客户端可以根据计算证书编号的方法计算出自己要获得的证书的编号，然后把这个编号和证书上的编号进行比对，如果一样证明没有被调包。</p>
<p>这里的证书编号指的就是数字签名，证书指的就是数字证书。</p>
<p>总结一下HTTPS：HTTPS想要保证客户端与服务器之间的通信安全，就得使用对称加密算法进行加密。协商对称加密算法的过程通过非对称加密算法来保证。在非对称加密算法中，客户端获得公钥的过程需要第三方机构（CA）通过颁发数字证书保证安全性。</p>
<p>总得来说通过这一系列机制协商出了一个对称加密算法后，客户端与服务器之间就能通过该算法进行安全的通信了</p>
<h2 id="进程、线程、协程概念性区别"><a href="#进程、线程、协程概念性区别" class="headerlink" title="进程、线程、协程概念性区别"></a>进程、线程、协程概念性区别</h2><p>对于进程、线程，都是有内核进行调度，有CPU时间片的概念，进行抢占式调度（有多种调度算法）。</p>
<p>对于协程(用户级线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户的程序自己调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的CPU控制权切换到其他进程&#x2F;线程，通常只能进行协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。</p>
<ol>
<li><p>goroutine 和协程区别</p>
<p>本质上，goroutine 就是协程。 不同的是，Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的CPU (P) 转让出去，让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程。</p>
</li>
<li><p>其他方面不同</p>
<p>3.1 内存消耗方面</p>
<p>每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少。<br>goroutine: 2KB<br>线程: 8MB</p>
<p>3.2 线程&#x2F;goroutine 切换(调度)开销方面</p>
<p>线程&#x2F;goroutine 切换开销方面，goroutine 远比线程小<br>线程: 涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP…等寄存器的刷新等。<br>goroutine: 只有三个寄存器的值修改 - PC &#x2F; SP &#x2F; DX.</p>
</li>
<li><p>进程是程序执行的一个实例, 担当分担系统资源的实体.</p>
</li>
<li><p>进程是分配资源的基本单位，也是我们说的隔离。线程作为独立运行和独立调度的基本单位</p>
</li>
<li><p>进程切换只发生在内核态</p>
</li>
</ol>
<h2 id="线程-用户级线程-x2F-内核级线程"><a href="#线程-用户级线程-x2F-内核级线程" class="headerlink" title="线程(用户级线程&#x2F;内核级线程)"></a>线程(用户级线程&#x2F;内核级线程)</h2><ul>
<li>线程是进程的一个执行流, 线程是操作系统能够进行运算调度的最小单位</li>
<li>对于进程和线程,都是有内核进行调度,有 CPU 时间片的概念, 进行抢占式调度</li>
<li>线程可以在启动前设置栈的大小,启动后,线程的栈大小就固定了</li>
<li>内核由系统内核进行调度, 系统为了实现并发,会不断地切换线程执行, 由此会带来线程的上下文切换.</li>
</ul>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><ul>
<li>Goroutine 是协程的go语言实现</li>
<li>协程(用户态线程)是对内核透明的, 也就是系统完全不知道有协程的存在, 完全由用户自己的程序进行调度</li>
<li>在栈大小分配方便,且每个协程占用的默认占用内存很小,只有 <code>2kb</code> ,而线程需要 <code>8mb</code>,相较于线程,因为协程是对内核透明的,所以栈空间大小可以按需增大减小</li>
<li>在调度方面, 相较于线程,go 有自己的一套运行时调度系统,go的调度器类似于内核调度器, 而他不需要进行内核的上下文切换, 所以重新调度一个 Goroutine 的开销会小于重新调度线程的开销</li>
</ul>
<p><strong>协程与线程主要区别是它将不再被内核调度，而是交给了程序自己而线程是将自己交给内核调度，所以也不难理解golang中调度器的存在</strong></p>
<h3 id="网络-1"><a href="#网络-1" class="headerlink" title="网络"></a>网络</h3><ul>
<li><p>TCP消息和UDP的主要区别</p>
</li>
<li><p>Epoll比起select&#x2F;poll，主要优化点在哪里？</p>
</li>
<li><p>Post和Get有什么区别？</p>
</li>
<li><p>接收时，如何确定一个HTTP消息已经读取完毕</p>
</li>
<li><p>从一个命令行下载一个网页，会涉及哪些网络协议？（DNS，TCP，HTTP，如果有ARP和SSL更好）</p>
</li>
<li><p>HTTP&#x2F;2主要优化点</p>
</li>
<li><p>\1. C++中具体是怎么实现多态的？构造函数可以是虚函数吗？构造函数可以调用虚函数吗？<br>编译器发现一个类中有虚函数，便会立即为此类生成虚函数表 vtable。虚函数表的各表项为指向对应虚函数的指针。<br>构造函数不可以是虚函数，也不能调用虚函数，因为此时虚函数表还未生成。</p>
<p>\2. 操作系统中进程、线程的区别，进程间通信通信的方式？<br>进程： 进程是资源（CPU、内存等）分配的基本单位，具有一定功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。<br>线程：线程是进程的一个实体，是独立运行和独立调度的基本单位（CPU上真正运行的是线程）。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。<br>进程通信的方式：管道，有名管道，信号量，消息队列，信号,共享内存,套接字.</p>
<p>\3. python中的多线程能充分利用多核CPU吗？如果要充分利用的话应该怎么做？<br>python的多线程不能充分利用多CPU，因为python解释器有一个全局锁；<br>要想利用多CPU只能使用多进程模型，或者使用C++</p>
<p>\4. http属于OSI分层协议中的哪一层？TCP&#x2F;UDP是属于哪一层？TCP的三次握手的过程是怎样的？为什么要有三次握手？<br>http属于应用层，TCP&#x2F;UDP属于传输层；</p>
<p>假设 A 为客户端，B 为服务器端。</p>
<p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p>
<p>A 向 B 发送连接请求报文，SYN&#x3D;1，ACK&#x3D;0，选择一个初始的序号 x。</p>
<p>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN&#x3D;1，ACK&#x3D;1，确认号为 x+1，同时也选择一个初始的序号 y。</p>
<p>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</p>
<p>B 收到 A 的确认后，连接建立。</p>
<p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p>
<p>\5. TCP怎么实现可靠传输的？</p>
<p>TCP滑动窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。<br>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。<br>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p>
</li>
</ul>
<h3 id="cpp"><a href="#cpp" class="headerlink" title="cpp"></a>cpp</h3><ul>
<li>一个C++对象的大小由哪些因素决定？基类，成员，内存对齐，虚函数。</li>
<li>C++对象的成员函数对对象大小有什么影响？是否有虚函数，虚函数的个数多少对对象大小有什么影响？</li>
<li>一个C++对象的初始化顺序是什么？</li>
<li>虚析构函数有什么用途？</li>
<li>new operator和operator new什么区别和联系？</li>
<li>什么是placement new？</li>
<li>STL迭代器按照支持的操作分为哪几类？</li>
<li>Map和UnorderedMap的主要区别是什么？如何选择？</li>
<li>UnorderedMap如何解决Hash冲突？</li>
<li>Deque和Vector有什么区别？</li>
<li>什么是RAII机制？</li>
<li>在C++中，如何避免内存泄漏？</li>
<li>智能指针有哪些？什么用途？</li>
</ul>
<h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><ul>
<li>个进程的多个线程之间，那些资源是共享的，哪些是私有的？</li>
<li>多个线程之间，线程同步和通讯的原语主要有哪些？</li>
<li>进程间通讯的方式有哪些？（共享内存，消息队列，管道，信号量，信号等）</li>
<li>程序崩溃了，如何定位崩溃点？</li>
<li>程序崩溃时，常见的主要有那些信号？</li>
<li>内存泄漏如何调试？如何预防？</li>
<li>SSD和机械硬盘的主要区别是什么？</li>
<li>SSD的写放大是什么意思？</li>
</ul>
<p>不懂Linux的，Linux相关的问题可以不知道。</p>
<p>\6. 数据库的事务的4个特性是什么？并发事务会带来什么问题？</p>
<ol>
<li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
<li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<p>并发事务的问题：</p>
<ul>
<li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>
<li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A&#x3D;20，事务2也读取A&#x3D;20，事务1修改A&#x3D;A-1，事务2也修改A&#x3D;A-1，最终结果A&#x3D;19，事务1的修改被丢失。</li>
<li><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>
<li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<p>事务隔离的级别：</p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>
<li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>
<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。（MySQL默认）</li>
<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>
</ul>
<h3 id="上机"><a href="#上机" class="headerlink" title="上机"></a>上机</h3><p>面试问题</p>
<p>1）TCP&#x2F;IP协议<br>    1）三次握手&#x2F;四次挥手过程<br>    2）TIME_WAIT状态<br>        1）主动关闭&#x2F;被动关闭<br>        2）需要的原因<br>        3）缓解措施<br>        4）有没有方式不出现TIME_WAIT状态<br>    3）RST出现的场景<br>    4）滑动窗口<br>2）网络编程<br>    1）EPOLL&#x2F;SELECT的区别<br>    2）边沿触发&#x2F;水平触发<br>    3）事件触发的场景<br>        1）读事件 有哪些场景<br>        2）写事件 有哪些场景<br>    4）READ调用返回值场景<br>        1）0<br>        2）-1<br>        3）&gt;0<br>    5）UDP客户端可以CONNECT不，那CONNECT和不CONNECT有啥区别<br>3）后台编程<br>    1）FORK的用途，FORK区分父子进程方式<br>    2）进程间通信方式<br>    3）僵尸进程<br>    4）内存模型，有哪些段构成<br>    5）进程&#x2F;线程&#x2F;协程的区别<br>4）常见中间件<br>    1）MYSQL<br>        1）为啥不建议SELECT *<br>        2）覆盖索引<br>        3）分页优化<br>    2）ZOOKEEPER<br>        1）有哪些WATCH以及对应唤醒事件<br>    3）KAFKA<br>        1）分区分服<br>        2）生产者<br>        3）消费者<br>5）语言<br>    1）JAVA语言<br>        1）内存管理<br>6）设计模式<br>    1）单例模式<br>7）项目中的难点、挑战点</p>
<p>22989-腾讯云网络后台开发工程师(CSIG全资子公司)（西安）</p>
<p>建议用online ddl（网上可以查）修改，就是逗号后面的参数<br>另外，添加字段要加上after，根据表结构看看fromWanIp适合在哪个字段后<br>ALTER TABLE cEip ALTER COLUMN ispId SET DEFAULT -1, ALGORITHM&#x3D;INPLACE, LOCK&#x3D;NONE;</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-26T09:35:22.714Z" title="1/26/2024, 5:35:22 PM">2024-01-26</time>发表</span><span class="level-item"><time dateTime="2024-01-31T07:48:49.725Z" title="1/31/2024, 3:48:49 PM">2024-01-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/100-CoderSkills/">100_CoderSkills</a><span> / </span><a class="link-muted" href="/categories/100-CoderSkills/104-Coding/">104_Coding</a></span><span class="level-item">8 分钟读完 (大约1186个字)</span></div></div><div class="content"><hr>
<p>00_CodingInterview<br>aliases:<br>tags: #cs#interview #coding<br>date: 2023-10-08 15:29</p>
<hr>
<p>编程题本身不考察算法掌握程度，但是考察基本的逻辑思维，把算法转换为代码的能力，以及基本的错误处理。现场面试用纸笔，白板，电脑都可以，远程面试可以用在线代码平台，比如<a target="_blank" rel="noopener" href="http://collabedit.com/">collabedit</a>，<a target="_blank" rel="noopener" href="https://codeshare.io/">codeshare.io</a>，<a target="_blank" rel="noopener" href="https://codeinterview.io/">codeinterview.io</a><br>复杂的算法不太容易验证，二十行内能解决的不太复杂的算法题为宜，速度越快越好，代码不能有明显的语法错误和低级错误</p>
<h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h2><h3 id="关于快速排序"><a href="#关于快速排序" class="headerlink" title="关于快速排序"></a>关于快速排序</h3><ul>
<li>cpp sort函数内部是什么</li>
</ul>
<p>sort函数内部使用快速排序算法实现，它的时间复杂度为O(nlogn)，是一种非常高效的排序算法。</p>
<ul>
<li><p>快排的原理</p>
<ul>
<li>选择一个基准元素。</li>
<li>将小于等于基准元素的元素移动到数组左边，大于基准元素的元素移动到数组右边，这个过程称为划分。</li>
<li>递归地对划分后的左右两个子序列进行排序。</li>
</ul>
</li>
<li><p>在实际实现中，sort函数还有一些优化，例如：</p>
<ul>
<li>当排序的元素个数小于一定阈值时，使用插入排序算法。</li>
<li>当出现大量重复元素时，使用三向划分快速排序算法。</li>
</ul>
</li>
<li><p>为什么选快排<br>  默认它的分布是比较随机的那种分布，然后快排在比较随机的分布上，表现的比较好，速度比较快</p>
</li>
<li></li>
<li></li>
<li><p>栈的简单实现 push pop功能</p>
</li>
<li><p>栈、队列区别，用数组实现栈</p>
</li>
<li><p>二叉树深度、广度遍历</p>
</li>
</ul>
<h2 id="2-上机"><a href="#2-上机" class="headerlink" title="2. 上机"></a>2. 上机</h2><h3 id="2-1-算法与数据结构"><a href="#2-1-算法与数据结构" class="headerlink" title="2.1 算法与数据结构"></a>2.1 算法与数据结构</h3><ul>
<li><p>c++反转单链表。</p>
</li>
<li><p>非递归实现二叉树</p>
</li>
<li><p>写一个实现字符串拷贝的函数。给定字符串拷贝函数strcpy的原型：<br>char *strcpy(char *dest,const char *src); 要求：（1）不调用任何库函数。（2）说明函数为什么返回char *.<br> <code> char *strcpy(char *dest,char *src) &#123;  if( (dest == NULL) || (src == NULL) )  &#123;  return NULL;  &#125;  char *ret_string = dest;  while( *dest ++ = *src++)!=’\0′);  return ret_string;  &#125; </code></p>
</li>
<li><p>链表逆序</p>
</li>
<li><p>二叉树求宽度&#x2F;深度</p>
</li>
<li><p>字符串处理：Split, Trim，逆序</p>
</li>
<li><p>编码：UTF8编解码，Varint编解码，十六进制编解码</p>
</li>
<li><p>数组去重，保持顺序 [1, 2, 3, 1, 2] -&gt; [1, 2, 3]</p>
</li>
<li><p>数组去重，保持顺序，后面的出现后，前面的去掉，[1, 2, 3, 2, 1] -&gt; [3, 2, 1]</p>
</li>
<li><p>位图中查找第一个设置&#x2F;未设置的位的偏移量</p>
</li>
<li><p>手写 LRU</p>
</li>
</ul>
<h3 id="2-2-接口设计"><a href="#2-2-接口设计" class="headerlink" title="2.2  接口设计"></a>2.2  接口设计</h3><h4 id="比如String类的接口设计（构造函数，拷贝，赋值，拼接等）"><a href="#比如String类的接口设计（构造函数，拷贝，赋值，拼接等）" class="headerlink" title="比如String类的接口设计（构造函数，拷贝，赋值，拼接等）"></a>比如String类的接口设计（构造函数，拷贝，赋值，拼接等）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">String</span>();</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* str);</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">String</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span>* str);</span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(<span class="type">const</span> String&amp; other);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接运算符</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span>* str);</span><br><span class="line">    String&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> String&amp; other);</span><br><span class="line">    <span class="keyword">friend</span> String <span class="keyword">operator</span>+(<span class="type">const</span> String&amp; lhs, <span class="type">const</span> String&amp; rhs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问字符</span></span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取长度</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为C风格字符串</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_data;</span><br><span class="line">    <span class="type">size_t</span> m_length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line">String::<span class="built_in">String</span>() : <span class="built_in">m_data</span>(<span class="literal">nullptr</span>), <span class="built_in">m_length</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">String::<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* str) &#123;</span><br><span class="line">    m_length = <span class="built_in">strlen</span>(str);</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[m_length + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">String::<span class="built_in">String</span>(<span class="type">const</span> String&amp; other) &#123;</span><br><span class="line">    m_length = other.m_length;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[m_length + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">String::~<span class="built_in">String</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值运算符</span></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span>* str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (m_data != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    &#125;</span><br><span class="line">    m_length = <span class="built_in">strlen</span>(str);</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[m_length + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, str);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="type">const</span> String&amp; other) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_data != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        &#125;</span><br><span class="line">        m_length = other.m_length;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span>[m_length + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接运算符</span></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span>* str) &#123;</span><br><span class="line">    <span class="type">size_t</span> old_length = m_length;</span><br><span class="line">    m_length += <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="type">char</span>* tmp = <span class="keyword">new</span> <span class="type">char</span>[m_length + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmp, m_data);</span><br><span class="line">    <span class="built_in">strcat</span>(tmp, str);</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    m_data = tmp;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>+=(<span class="type">const</span> String&amp; other) &#123;</span><br><span class="line">    <span class="type">size_t</span> old_length = m_length;</span><br><span class="line">    m_length += other.m_length;</span><br><span class="line">    <span class="type">char</span>* tmp = <span class="keyword">new</span> <span class="type">char</span>[m_length + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmp, m_data);</span><br><span class="line">    <span class="built_in">strcat</span>(tmp, other.m_data);</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    m_data = tmp;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String <span class="keyword">operator</span>+(<span class="type">const</span> String&amp; lhs, <span class="type">const</span> String&amp; rhs) &#123;</span><br><span class="line">    <span class="function">String <span class="title">result</span><span class="params">(lhs)</span></span>;</span><br><span class="line">    result += rhs;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问字符</span></span><br><span class="line"><span class="type">char</span>&amp; String::<span class="keyword">operator</span>[](<span class="type">size_t</span> index) &#123;</span><br><span class="line">    <span class="keyword">return</span> m_data[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>&amp; String::<span class="keyword">operator</span>[](<span class="type">size_t</span> index) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m_data[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取长度</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">String::length</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为C风格字符串</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">String::c_str</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;String.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">str1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str1: &quot;</span> &lt;&lt; str1.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    String str2 = str1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str2: &quot;</span> &lt;&lt; str2.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    str2 += <span class="string">&quot;, world!&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str2 after concatenation: &quot;</span> &lt;&lt; str2.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    String str3 = str1 + str2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str3 after concatenation: &quot;</span> &lt;&lt; str3.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>用数组实现循环队列</li>
<li>可以考察一些函数的实现，比如String类+&#x3D;的实现，主要关注正确性和内存泄漏和越界</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-26T09:35:22.713Z" title="1/26/2024, 5:35:22 PM">2024-01-26</time>发表</span><span class="level-item"><time dateTime="2024-01-31T07:48:49.725Z" title="1/31/2024, 3:48:49 PM">2024-01-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/100-CoderSkills/">100_CoderSkills</a><span> / </span><a class="link-muted" href="/categories/100-CoderSkills/102-Python/">102_Python</a></span><span class="level-item">3 分钟读完 (大约465个字)</span></div></div><div class="content"><h1 id="关于Python闭包（Closures）的那点事"><a href="#关于Python闭包（Closures）的那点事" class="headerlink" title="关于Python闭包（Closures）的那点事"></a>关于Python闭包（Closures）的那点事</h1><hr>
<h2 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h2><p>类比一下对象，对象是封装了方法的数据，闭包是封装了数据的方法。</p>
<h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def outer(x):</span><br><span class="line">  # 1</span><br><span class="line">  def inner(y):</span><br><span class="line">    print(x)</span><br><span class="line">    return x+y</span><br><span class="line">  return inner  # 2</span><br><span class="line">g = outer(5)  # 3</span><br><span class="line">print(g.__closure__)  # 4</span><br><span class="line">print(g(6))   # 5</span><br></pre></td></tr></table></figure>
<p>请问上面的代码能够顺利执行吗？</p>
<p>上面的代码执行没有任何问题。<br>但我相信第一次接触闭包的同学肯定会对x的作用域有疑问，在这段代码中x是一个outer函数内部的<br>局部变量， 生命周期应该从入参到 # 1到 # 2才对， 所以当#3执行完后x已经被释放了， 当执行#5时<br>innner函数被触发，但此时应该访问不到x，应该会抛出一个x未定义的异常才对，但是这一些都没有发生，<br>inner函数依旧正常执行，打印了x。</p>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&lt;cell at 0x7efd66558108: int object at 0xa67b40&gt;,)</span><br><span class="line">5</span><br><span class="line">11</span><br></pre></td></tr></table></figure>
<h2 id="分析一下"><a href="#分析一下" class="headerlink" title="分析一下"></a>分析一下</h2><p><strong>Python支持一种特性叫做函数闭包（function closures）：在非全局（global）作用域中定义inner函数（即嵌套函数）时，会记录下它的嵌套函数namespaces（嵌套函数作用域的locals），可以称作：定义时状态，可以通过__closure__ 这个属性来获得inner函数的外层嵌套函数的namespaces。(如上例中#5，打印了func_closure ，里面保存了一个int对象，这个int对象就是x)</strong></p>
<p>在这个例子中，我们能看到闭包实际上是记录了外层嵌套函数作用域中的local变量</p>
<h2 id="闭包的应用场景"><a href="#闭包的应用场景" class="headerlink" title="闭包的应用场景"></a>闭包的应用场景</h2><ul>
<li>替换硬编码常量</li>
<li>终结全局</li>
<li>提供一致的功能签名</li>
<li>实现面向对象</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a target="_blank" rel="noopener" href="http://ynniv.com/blog/2007/08/closures-in-python.html">http://ynniv.com/blog/2007/08/closures-in-python.html</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-26T09:35:22.713Z" title="1/26/2024, 5:35:22 PM">2024-01-26</time>发表</span><span class="level-item"><time dateTime="2024-01-31T07:48:49.725Z" title="1/31/2024, 3:48:49 PM">2024-01-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/100-CoderSkills/">100_CoderSkills</a><span> / </span><a class="link-muted" href="/categories/100-CoderSkills/102-Python/">102_Python</a></span><span class="level-item">几秒读完 (大约17个字)</span></div></div><div class="content"><h1 id="Python-基础篇"><a href="#Python-基础篇" class="headerlink" title="Python 基础篇"></a>Python 基础篇</h1><h1 id="Python-进阶"><a href="#Python-进阶" class="headerlink" title="Python 进阶"></a>Python 进阶</h1><h1 id="Python-Web"><a href="#Python-Web" class="headerlink" title="Python Web"></a>Python Web</h1><h1 id="Python-爬虫"><a href="#Python-爬虫" class="headerlink" title="Python 爬虫"></a>Python 爬虫</h1><h1 id="Python-数据分析"><a href="#Python-数据分析" class="headerlink" title="Python 数据分析"></a>Python 数据分析</h1></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-26T09:35:22.713Z" title="1/26/2024, 5:35:22 PM">2024-01-26</time>发表</span><span class="level-item"><time dateTime="2024-01-31T07:48:49.725Z" title="1/31/2024, 3:48:49 PM">2024-01-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/100-CoderSkills/">100_CoderSkills</a><span> / </span><a class="link-muted" href="/categories/100-CoderSkills/102-Python/">102_Python</a></span><span class="level-item">1 小时读完 (大约12045个字)</span></div></div><div class="content"><h2 id="1-岗位信息"><a href="#1-岗位信息" class="headerlink" title="1 岗位信息"></a>1 岗位信息</h2><p><a target="_blank" rel="noopener" href="http://bole.oa.com/BoLe/PostAdmin/PostDetail?postId=82793">http://bole.oa.com/BoLe/PostAdmin/PostDetail?postId=82793</a> </p>
<p><a target="_blank" rel="noopener" href="http://bole.oa.com/BoLe/PostAdmin/PostDetail?postId=80555">http://bole.oa.com/BoLe/PostAdmin/PostDetail?postId=80555</a></p>
<p>1、计算机、机器学习、统计等相关专业，本科及以上学历，3年以上相关工作经验。<br>2、有较强的算法基础和编码能力，熟练掌握Python、SQL、Java、Scala等至少一门语言。<br>3、熟练掌握常见的特征处理方法和机器学习算法，熟练使用各类常见的机器学习算法库，例如sklearn、tensorflow、pytorch、spark mllib等。<br>4、熟悉金融领域（银行、券商、保险等）的常见业务流程与业务问题，有相关建模经验者优先。 5、善于沟通，工作积极主动，责任心强，具备良好的团队协作能力。 通过腾讯云从业资格证或同等资格认证的优先录取<br>1、针对客户实际业务问题，负责大规模数据场景下的数据分析和建模工作。<br>2、针对各类常见的具体业务问题，负责相关案例和应用在产品侧的沉淀与积累。 </p>
<h3 id="岗位要求"><a href="#岗位要求" class="headerlink" title="岗位要求"></a>岗位要求</h3><p>1、计算机或者相关专业本科以上学历，硕士三年，本科五年以上工作经验；</p>
<p>2、具有扎实的数据结构和算法功底，能熟练应用各类机器学习模型（逻辑回归、聚类、树模型、图网络等）； </p>
<p>3、对数据分析和数据挖掘有深入理解，有相关项目经验； </p>
<p>4、能够运用hadoop、spark等大数据计算平台进行数据分析挖掘，熟练掌握python、hivesql、sparkscala，有相关项目经验；</p>
<p> 5、有较强学习能力和逻辑思维能力，具备良好的问题分析与解决能力；</p>
<p> 6、善于沟通，工作积极主动，责任心强，具备良好的团队协作能力；</p>
<p>7、有toB+toC业务数据分析经验者优先。 通过腾讯云从业资格证或同等资格认证的优先录取。 备注：此岗位为腾讯集团旗下全资子公司编制岗位  </p>
<h3 id="岗位职责"><a href="#岗位职责" class="headerlink" title="岗位职责"></a>岗位职责</h3><p>1、负责腾讯会议的数据仓库、数据建模、数据分析、数据可视化开发工作； </p>
<p>2、负责优化现有业务数据分析工具，通过科学方法持续优化数据分析效能； </p>
<p>3、负责提升产品&amp;运营团队基于数据驱动决策的效率和准确性，针对各行业数据的指标进行体系化梳理和建设； </p>
<p>4、负责腾讯会议数据治理，通过数据入库、校验、清洗，保证数据质量； </p>
<p>5、负责腾讯会议的数据标签挖掘、运营模型搭建工作； </p>
<p>6、持续产出行业洞察，跟踪分析竞争对手、行业趋势等，形成商业分析并洞察其中的商业机会。</p>
<h2 id="2-技术能力点整理"><a href="#2-技术能力点整理" class="headerlink" title="2 技术能力点整理"></a>2 技术能力点整理</h2><ul>
<li>数据仓库， 数据建模，数据分析，数据可视化， 数据标签挖掘， 运营模型搭建，行业趋势，商业机会</li>
<li>大数据：spark, hadoop, Sql, hivesql, python, sparkscala, </li>
<li>统计学：AB test</li>
<li>机器学习：逻辑回归、聚类、树模型、图网络， 决策树， 随机森林， xgboost</li>
<li>数据预处理：缺失、重复、冲突， 清洗</li>
<li>数据入库</li>
<li>数据挖掘：tensoflow, keras, pytorch, </li>
<li>模型搭建</li>
<li>可视化：tableau, power_bi</li>
<li>网页抓取</li>
<li>数仓工具Hive、MR、Flink、Mysql</li>
<li>数仓建模理论，数仓分层、星形模型、雪花模型等，有大规模业务数仓实践经验优</li>
<li>握数据etl过程，熟悉spark&#x2F;hadoop&#x2F;Hbase&#x2F;es等大数据处理框架；</li>
<li>探索和抽象通用的数据分析方法，如流失预测，归因分析，路径分析，用户分群</li>
<li>从事过机器学习平台研发或参加kaggle等比赛获得优异成绩者优先</li>
</ul>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul>
<li>做版本规划的时候，如何设立指标来进行功能验证？</li>
<li>功能上线后，如何做数据复盘？</li>
<li>如何通过数据来快速定位问题？</li>
<li>在众多的数据中如何识别哪些是需要呈现的重要数据</li>
<li>通过数据仅能让你找到局部最大值，而更高的山峰只会建立在你更广阔的视野与深厚的认知上。</li>
</ul>
<h2 id="3-技术学习"><a href="#3-技术学习" class="headerlink" title="3 技术学习"></a>3 技术学习</h2><h3 id="3-1数据分析流程梳理"><a href="#3-1数据分析流程梳理" class="headerlink" title="3.1数据分析流程梳理"></a>3.1数据分析流程梳理</h3><p>数据分析：用适当的统计方法对收集来的数据进行分析，以求最大化的开发数据资料的功能， 发挥数据的作用， 是为了提取有用的信息和形成结论而对数据加以详细研究和概括总结的过程。<br>数据挖掘：从海量的数据库中选择、探索、识别出有效的、新颖的、具有潜在效用的乃至最终可理解的模式以获取商业利益的非平凡的过程</p>
<h4 id="定义挖掘目标：问题和想达到的效果，-明确分析的目的和思路"><a href="#定义挖掘目标：问题和想达到的效果，-明确分析的目的和思路" class="headerlink" title="定义挖掘目标：问题和想达到的效果， 明确分析的目的和思路"></a>定义挖掘目标：问题和想达到的效果， 明确分析的目的和思路</h4><ul>
<li>为什么展开数据分析，遇到什么问题，有没有其他更好的办法</li>
<li>方法：逻辑树分析法， 5w2h, 4p营销理论， PEST分析法</li>
<li>想多一点点</li>
</ul>
<p>####数据取样：相关性， 可靠性，有效性</p>
<ul>
<li>来自：数据库，问卷，互联网，公开出版物</li>
</ul>
<p>####数据探索：异常值分析， 缺失值分析， 相关性分析，周期分析</p>
<p>####数据预处理：筛选， 变量转换， 缺失值处理，坏数据处理，数据标准化， 主成分分析，属性选择， 数据规约</p>
<ul>
<li>数据清洗–》数据加工</li>
<li>从业务角度检查数据：不完整性， 噪音数据， 类型冲突， 单位冲突</li>
<li>从技术角度检查数据：统计描述， 箱体图，直方图， 散点图——》 数据预分析过程</li>
<li>数据分析方法： 对比分析， 交叉分析， 漏斗图分析， 矩阵关联分析，综合评价分析，杜邦分析<ul>
<li>对比分析：将两个或两个以上的数据进行比较， 分析他们的差异， 从而揭示这些数据所代表的事务发展变化情况和规律性。 特地昂是非常直观的看出事务某方面的变化和差距， 并且可以准确、量化的表示出这种变化或者差距是多少。 例如列出国内各省的人均消费金额，对比差异</li>
<li>交叉分析：通常用于分析两个变量之间的关系，即同时将两个有一定联系的变量及其值交叉排列在一张表格内，是各个变量值成为不同变量的交叉节点， 形成交叉表， 从而分析交叉表中变量之间的关系。比如每月星巴克卖出的咖啡中白咖啡和黑咖啡的占比</li>
<li>漏斗分析：漏斗图是一个适合业务流程比较规范、周期比较长、各流程环节涉及复杂业务过程比较多的管理分析工具。是对业务流程最直观的一种表现形式， 可以快速发现业务流程中存在问题的环节。比如浏览商品-》放入购物车-》生成订单-》支付订单-》完成交易，每一步的转换率怎样</li>
<li>矩阵关联分析：是指根据事务的两个重要属性作为横纵轴， 组成一个坐标系， 在两坐标轴上分辨按某一标准进行刻度划分，构成四个象限， 将要分析的每个事务对应投身至这四个象限内， 直观的将两个属性的关联性表现出来， 进而分析每一个事务在这两个属性上的表现， 为决策者提供重要的参考依据。</li>
</ul>
</li>
</ul>
<p>####挖掘建模：根据哪类问题（分类，聚类，关联规则， 时序模式， 智能推荐），选择合适的算法</p>
<ul>
<li>常用的数据挖掘的方法：回归分析，关联分析，决策树，聚类分析， 因子分析，神经网络<ul>
<li>回归分析：线性回归， 非线性回归， logistic回归</li>
<li>关联分析：推荐系统常用</li>
<li>决策树：决策树中最顶部的结点称为根结点， 是整个决策树的开始。 每个决策结点代表一个问题或者决策，结点连线代表某个属性满足的条件， 每个叶结点代表一种分类结果。</li>
<li>聚类分析：根据研究对象多个变量取值情况利用分类算法将研究对象划分到相对同质的多个群组， 使得群组内对象之间具有较高相似度，不通群组间对象之间差异较大——层次聚类法， k-means均值聚类法：随机选择k个对象，每个对象初试的代表一个类的平均值或者中心， 对剩余每个对象，根据其到各类中心的欧式距离，被划分到最近的类；然后重新计算每个类的中心值。不断重复这个过程，直到所有的样本都不能再分到任何一类为止。</li>
</ul>
</li>
</ul>
<p>####模型评价：对比</p>
<p>####模型发布</p>
<h4 id="数据展示"><a href="#数据展示" class="headerlink" title="数据展示"></a>数据展示</h4><ul>
<li>a picture is worth a thousand words;</li>
<li>表格、图表（成分图、排序（直方图），频率分布（直方图、折线图）， 相关性（矩阵、散点）， 多位图（多重数据比较））、词云图、 地域分布图、艺术图</li>
<li>Excel, spss, sas, matlab, stata,  T</li>
</ul>
<h4 id="撰写报告"><a href="#撰写报告" class="headerlink" title="撰写报告"></a>撰写报告</h4><ul>
<li>分析的目的和背景：目的，数据来源</li>
<li>主要分析结果：1，2， x</li>
<li>总结与建议：</li>
<li>详细分析：1XXXX，图表，结果， 2xxxx, 图表，结果</li>
<li>附录：参考数据，模型说明等</li>
</ul>
<h4 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h4><ul>
<li>分析的关键在于从起伏跌宕中发现规律和信息</li>
<li>宁缺毋滥，切记过度推理</li>
</ul>
<h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><ul>
<li>Hadoop, sqlserver, mysql, TDW(腾讯大数据平台)</li>
<li><a target="_blank" rel="noopener" href="http://www.199it.com/">http://www.199it.com/</a> 中文互联网数据咨询</li>
</ul>
<h3 id="3-2-常见的数据分析、挖掘模型"><a href="#3-2-常见的数据分析、挖掘模型" class="headerlink" title="3.2 常见的数据分析、挖掘模型"></a>3.2 常见的数据分析、挖掘模型</h3><p>分类模型：解决的是事务自动学习，然后进行类别判定的问题</p>
<p>聚类模型：解决的是将数据对象自动组成对象划定为不同类族</p>
<p>预测模型：解决根据已有实测规律，预测下一周期数据的问题</p>
<p>关联模型：解决大规模数据集中，寻找有关联关系的数据的问题</p>
<p>推荐模型：解决基于现有数据进行有效推荐</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gu5s2bkoh3j60u00vc79o02.jpg" alt="image-20210905152118574"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gu5s25ck0qj60u00w978t02.jpg" alt="image-20210905152046493"></p>
<h3 id="3-3-机器学习"><a href="#3-3-机器学习" class="headerlink" title="3.3 机器学习"></a>3.3 机器学习</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gu5ryxbfsuj616q0gcabo02.jpg" alt="image-20210905151807121"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gu5s039ve8j615q0l8whp02.jpg" alt="image-20210905151911506"></p>
<h4 id="有监督学习"><a href="#有监督学习" class="headerlink" title="有监督学习"></a>有监督学习</h4><p>K-近邻算法</p>
<p>决策树</p>
<p>逻辑回归</p>
<p>svm</p>
<p>朴素贝叶斯</p>
<h4 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h4><p>K-means, </p>
<p>PCA</p>
<p>FP-growth</p>
<p>关联规则</p>
<p>PageRank</p>
<h4 id="分类模型常用算法"><a href="#分类模型常用算法" class="headerlink" title="分类模型常用算法"></a>分类模型常用算法</h4><p>朴素贝叶斯</p>
<p>svm</p>
<p>k-近邻</p>
<p>逻辑回归</p>
<p>决策树</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gu5sayuwk5j60u30u0wj702.jpg" alt="image-20210905152920275"></p>
<h4 id="聚类模型常用算法"><a href="#聚类模型常用算法" class="headerlink" title="聚类模型常用算法"></a>聚类模型常用算法</h4><p>对大量未标注的数据集进行特征处理–》按照数据内在相似性将数据集划分为多个类别–》使类别内的数据相似度较大，而类别间的数据相似度较小</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gu5sfrzjz6j612u0lgn0r02.jpg" alt="image-20210905153257764"></p>
<h3 id="3-4-spark"><a href="#3-4-spark" class="headerlink" title="3.4 spark"></a>3.4 spark</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gu5he7me2kj60qe0eawfh02.jpg" alt="image-20210905091213160"></p>
<p><img src="http://ntsapps.oa.com/note/api/web/attachment!getImageByUrl?url=a1df78b3-499e-4a11-9596-2856f317e4d6.png" alt="img"></p>
<p><strong>4.分析方法</strong><br>1）拆解<br>①树形拆解<br>适合构成类数据分析，每一个数据由多个子项构成<br>下一层是上一层的支撑和论据</p>
<p>②线性拆解<br>适合流程分析，挖掘用户操作流程中的问题点<br>关注相邻项间的转化和用户流失情况<br>优化方向：去掉过程步骤等</p>
<h3 id="3-3数据分析技术点梳理"><a href="#3-3数据分析技术点梳理" class="headerlink" title="3.3数据分析技术点梳理"></a>3.3数据分析技术点梳理</h3><h4 id="数据清洗和特征处理"><a href="#数据清洗和特征处理" class="headerlink" title="数据清洗和特征处理"></a>数据清洗和特征处理</h4><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2015/02/10/machinelearning-data-feature-process.html">https://tech.meituan.com/2015/02/10/machinelearning-data-feature-process.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jasonfreak/p/5448385.html">https://www.cnblogs.com/jasonfreak/p/5448385.html</a></p>
<p>其本质是一项工程活动，目的是最大限度地从原始数据中提取特征以供算法和模型使用</p>
<p>数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已</p>
<p>数据清洗&#x3D;&gt;特征</p>
<p>标注数据生成&#x3D;&gt;模型学习&#x3D;&gt;模型应用</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu71kd0dz7j61cu0oa40e02.jpg" alt="image-20210906173529837"></p>
<p>蓝色–离线</p>
<p>绿色-在线</p>
<p>主要的区别在于1.不需要清洗标注数据，只需要处理得到特征数据，在线模型使用特征数据预测出样本可能的标签。2.最终生成数据的用处，最终生成的数据主要用于模型的预测，而不是训练。 在离线的处理部分，可以进行较多的实验和迭代，尝试不同的样本采样、样本权重、特征处理方法、特征组合方法等，最终得到一个最优的方法，在离线评估得到好的结果后，最终将确定的方案在线上使用。 另外，由于在线和离线环境不同，存储数据、获取数据的方法存在较大的差异。例如离线数据获取可以将数据存储在Hadoop，批量地进行分析处理等操作，并且容忍一定的失败。而在线服务获取数据需要稳定、延时小等，可以将数据建入索引、存入KV存储系统等。</p>
<p>离线我们用常用的衡量排序结果的AUC指标，在线的我们通过ABTest来测试算法对下单率、用户转化率等指标的影响。</p>
<ul>
<li><p>模型评价: 离线AUC, 在线ABTest</p>
<ul>
<li>AUC:AUC值为ROC曲线下的面积，是一个概率值，越大越好。简单来说这个指标的含义其实就是随机抽出一对样本（一个正样本，一个负样本），然后用训练得到的分类器来对这两个样本进行预测，预测得到正样本的概率大于负样本概率的概率。AUC是一个二分类模型的评价指标，还有很多其他指标比如logloss，accuracy，precision。在数据挖掘比赛中，AUC和logloss比accuracy更常用。因为很多机器学习的模型对分类问题的预测结果都是概率，如果要计算accuracy，需要先把概率转化成类别，这就需要手动设置一个阈值，如果对一个样本的预测概率高于阈值，那该样本就被预测为正样本，低于这个阈值，则为负样本。所以这个阈值很大程度上影响了accuracy的计算。然而，使用AUC和logloss可以避免把预测概率转换成类别。</li>
<li>Logloss: logloss越小越好，物理意义为：衡量预估ctr与实际ctr的拟合程度。</li>
</ul>
</li>
<li><p>数据获取：准确性， 难度、数据量大小</p>
<ul>
<li>数据采样：随机采样，固定比例采样<ul>
<li>1.结合业务情况进行数据的过滤，例如去除crawler抓取，spam，作弊等数据。 </li>
<li>2.异常点检测，采用异常点检测算法对样本进行分析，常用的异常点检测算法包括 - 偏差检测，例如聚类，最近邻等。 - 基于统计的异常点检测算法 例如极差，四分位数间距，均差，标准差等，这种方法适合于挖掘单变量的数值型数据。全距(Range)，又称极差，是用来表示统计资料中的变异量数(measures of variation) ，其最大值与最小值之间的差距；四分位距通常是用来构建箱形图，以及对概率分布的简要图表概述。 - 基于距离的异常点检测算法，主要通过距离方法来检测异常点，将数据集中与大多数点之间距离大于某个阈值的点视为异常点，主要使用的距离度量方法有绝对距离 ( 曼哈顿距离 ) 、欧氏距离和马氏距离等方法。 - 基于密度的异常点检测算法，考察当前点周围密度，可以发现局部异常点，例如LOF算法</li>
</ul>
</li>
</ul>
</li>
<li><p>特征分类</p>
<ul>
<li>离线特征获取方案 离线可以使用海量的数据，借助于分布式文件存储平台，例如HDFS等，使用例如MapReduce，Spark等处理工具来处理海量的数据等</li>
<li>在线特征获取方案 在线特征比较注重获取数据的延时，由于是在线服务，需要在非常短的时间内获取到相应的数据，对查找性能要求非常高，可以将数据存储在索引、kv存储等。而查找性能与数据的数据量会有矛盾，需要折衷处理，我们使用了<strong>特征分层获取方案</strong></li>
<li>特征数据只有在和标注数据合并之后，才能用来做为模型的训练</li>
<li>可以将特征分为(1)Low level特征和High level特征。(2)稳定特征与动态特征。(3)二值特征、连续特征、枚举特征。<ul>
<li>Low level特征是较低级别的特征，主要是原始特征，不需要或者需要非常少的人工处理和干预，例如文本特征中的词向量特征，图像特征中的像素点，用户id，商品id等。Low level特征一般维度比较高，不能用过于复杂的模型。High level特征是经过较复杂的处理，结合部分业务逻辑或者规则、模型得到的特征，例如人工打分，模型打分等特征，可以用于较复杂的非线性模型。Low level 比较针对性，覆盖面小。长尾样本的预测值主要受high level特征影响。 高频样本的预测值主要受low level特征影响。</li>
<li>稳定特征是变化频率(更新频率)较少的特征，例如评价平均分，团购单价格等，在较长的时间段内都不会发生变化。动态特征是更新变化比较频繁的特征，有些甚至是实时计算得到的特征，例如距离特征，2小时销量等特征。或者叫做实时特征和非实时特征。针对两类特征的不同可以针对性地设计特征存储和更新方式，例如对于稳定特征，可以建入索引，较长时间更新一次，如果做缓存的话，缓存的时间可以较长。对于动态特征，需要实时计算或者准实时地更新数据，如果做缓存的话，缓存过期时间需要设置的较短。</li>
<li>二值特征主要是0&#x2F;1特征，即特征只取两种值：0或者1，例如用户id特征：目前的id是否是某个特定的id，词向量特征：某个特定的词是否在文章中出现等等。连续值特征是取值为有理数的特征，特征取值个数不定，例如距离特征，特征取值为是0~正无穷。枚举值特征主要是特征有固定个数个可能值，例如今天周几，只有7个可能值：周1，周2，…，周日。在实际的使用中，我们可能对不同类型的特征进行转换，例如将枚举特征或者连续特征处理为二值特征。枚举特征处理为二值特征技巧：将枚举特征映射为多个特征，每个特征对应一个特定枚举值，例如今天周几，可以把它转换成7个二元特征：今天是否是周一，今天是否是周二，…，今天是否是周日。连续值处理为二值特征方法：先将连续值离散化（后面会介绍如何离散化)，再将离散化后的特征切分为N个二元特征，每个特征代表是否在这个区间内。</li>
</ul>
</li>
</ul>
</li>
<li><p>特征选择</p>
<p>特征选择的目标是寻找最优特征子集。特征选择能剔除不相关(irrelevant)或冗余(redundant )的特征，从而达到减少特征个数，提高模型精确度，减少运行时间的目的。另一方面，选取出真正相关的特征简化模型，协助理解数据产生的过程。 特征选择的一般过程如下图所示：主要分为产生过程，评估过程，停止条件和验证过程</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu75c9l5jij60m8090t8v02.jpg" alt="image-20210906194618468"></p>
<ul>
<li><p>特征抽取和归一化之后，如果发现特征太多，导致模型无法训练，或很容易导致模型过拟合，则需要对特征进行选择，挑选有价值的特征。</p>
<ul>
<li>Filter：</li>
</ul>
<p>假设特征子集对模型预估的影响互相独立，选择一个特征子集，分析该子集和数据Label的关系，如果存在某种正相关，则认为该特征子集有效。衡量特征子集和数据Label关系的算法有很多，如Chi-square，Information Gain。</p>
<ul>
<li>Wrapper：</li>
</ul>
<p>选择一个特征子集加入原有特征集合，用模型进行训练，比较子集加入前后的效果，如果效果变好，则认为该特征子集有效，否则认为无效。</p>
<ul>
<li>Embedded：</li>
</ul>
<p>将特征选择和模型训练结合起来，如在损失函数中加入L1 Norm ，L2 Norm。</p>
</li>
<li><p>完全搜索(Complete)</p>
<ul>
<li>广度优先搜索( Breadth First Search ) 广度优先遍历特征子空间。枚举所有组合，穷举搜索，实用性不高。</li>
<li>分支限界搜索( Branch and Bound ) 穷举基础上加入分支限界。例如：剪掉某些不可能搜索出比当前最优解更优的分支。 其他，如定向搜索 (Beam Search )，最优优先搜索 ( Best First Search )等</li>
</ul>
</li>
<li><p>启发式搜索(Heuristic)</p>
<ul>
<li>序列前向选择( SFS ， Sequential Forward Selection ) 从空集开始，每次加入一个选最优。</li>
<li>序列后向选择( SBS ， Sequential Backward Selection ) 从全集开始，每次减少一个选最优。</li>
<li>增L去R选择算法 ( LRS ， Plus-L Minus-R Selection ) 从空集开始，每次加入L个，减去R个，选最优（L&gt;R)或者从全集开始，每次减去R个，增加L个，选最优(L&lt;R)。</li>
</ul>
<p>其他如双向搜索( BDS ， Bidirectional Search )，序列浮动选择( Sequential Floating Selection )等</p>
</li>
<li><p>随机搜索(Random)</p>
<ul>
<li>随机产生序列选择算法(RGSS， Random Generation plus Sequential Selection) 随机产生一个特征子集，然后在该子集上执行SFS与SBS算法。</li>
<li>模拟退火算法( SA， Simulated Annealing ) 以一定的概率来接受一个比当前解要差的解，而且这个概率随着时间推移逐渐降低</li>
<li>遗传算法( GA， Genetic Algorithms ) 通过交叉、突变等操作繁殖出下一代特征子集，并且评分越高的特征子集被选中参加繁殖的概率越高。</li>
</ul>
</li>
</ul>
<p>随机算法共同缺点:依赖随机因素，有实验结果难重现。</p>
<ul>
<li><p>特征选择—相关性</p>
<ul>
<li><p>对特征的有效性进行分析，得到各个特征的特征权重，根据是否与模型有关可以分为1.与模型相关特征权重，使用所有的特征数据训练出来模型，看在模型中各个特征的权重，由于需要训练出模型，模型相关的权重与此次学习所用的模型比较相关。不同的模型有不同的模型权重衡量方法。例如线性模型中，特征的权重系数等。2.与模型无关特征权重。主要分析特征与label的相关性，这样的分析是与这次学习所使用的模型无关的。与模型无关特征权重分析方法包括(1)交叉熵，(2)Information Gain，(3)Odds ratio，(4)互信息，(5)KL散度等</p>
</li>
<li><p>于重要的特征进行监控与有效性分析，了解模型所用的特征是否存在问题，当某个特别重要的特征出问题时，需要做好备案，防止灾难性结果</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu87fcjo1qj60cz05ljre02.jpg" alt="image-20210907174359312"></p>
</li>
</ul>
</li>
<li><p>特征选择–距离</p>
<ul>
<li>运用距离度量进行特征选择是基于这样的假设：好的特征子集应该使得属于同一类的样本距离尽可能小，属于不同类的样本之间的距离尽可能远。常用的距离度量（相似性度量）包括欧氏距离、标准化欧氏距离、马氏距离等。</li>
</ul>
</li>
<li><p>特征选择–一致性</p>
<ul>
<li>若样本1与样本2属于不同的分类，但在特征A、 B上的取值完全一样，那么特征子集{A，B}不应该选作最终的特征集</li>
</ul>
</li>
</ul>
</li>
<li><p>特征处理</p>
<ul>
<li><p>无量纲化</p>
<ul>
<li><p>标准化：标准化需要计算特征的均值和标准差，公式表达为， 代码from sklearn.preprocessing import StandardScaler</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu7xd85n2zj60c204ggle02.jpg" alt="image-20210907115558235"></p>
</li>
<li><p>区间缩放法：区间缩放法的思路有多种，常见的一种为利用两个最值进行缩放，公式表达为,代码	from sklearn.preprocessing import MinMaxScaler</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu7xehjni2j60ls06s74502.jpg" alt="image-20210907115709789"></p>
</li>
<li><p>特征归一化： Normalizer</p>
<ul>
<li>主要用于单个特征的处理。 - 归一化 不同的特征有不同的取值范围，在有些算法中，例如线性模型或者距离相关的模型像聚类模型、knn模型等，特征的取值范围会对最终的结果产生较大影响，例如二元特征的取值范围为[0，1]，而距离特征取值可能是[0，正无穷)，在实际使用中会对距离进行截断，例如[0，3000000]，但是这两个特征由于取值范围不一致导致了模型可能会更偏向于取值范围较大的特征，为了平衡取值范围不一致的特征，需要对特征进行归一化处理，将特征取值归一化到［0，1］区间。常用的归一化方法包括1.函数归一化，通过映射函数将特征取值映射到［0，1］区间，例如最大最小值归一化方法，是一种线性的映射。还有通过非线性函数的映射，例如log函数等。</li>
<li>2.分维度归一化，可以使用最大最小归一化方法，但是最大最小值选取的是所属类别的最大最小值，即使用的是局部最大最小值，不是全局的最大最小值。</li>
<li>3.排序归一化，不管原来的特征取值是什么样的，将特征按大小排序，根据特征所对应的序给予一个新的值。</li>
</ul>
</li>
<li><p>标准化和归一化的区别：简单来说，标准化是依照特征矩阵的列处理数据，其通过求z-score（标准分数）的方法，将样本的特征值转换到同一量纲下。归一化是依照特征矩阵的行处理数据，其目的在于样本向量在点乘运算或其他核函数计算相似性时，拥有统一的标准，也就是说都转化为“单位向量”。规则为l2的归一化公式如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu7xm5diasj60am05kjr702.jpg" alt="image-20210907120434906"></p>
</li>
</ul>
</li>
<li><p>对定量特征二值化：定量特征二值化的核心在于设定一个阈值，大于阈值的赋值为1，小于等于阈值的赋值为0</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Binarizer</span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> <span class="comment">#二值化，阈值设置为3，返回值为二值化后的数据</span></span><br><span class="line"><span class="number">4</span> Binarizer(threshold=<span class="number">3</span>).fit_transform(iris.data)</span><br></pre></td></tr></table></figure>
</li>
<li><p>对定性特征亚编码</p>
<ul>
<li><p>one-hot独热编码介绍 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41853758/article/details/81252174">https://blog.csdn.net/qq_41853758/article/details/81252174</a></p>
<p> 独热码，在英文文献中称做 one-hot code, 又称独热编码、一位有效编码,直观来说就是有多少个状态就有多少比特，而且只有一个比特为1，其他全为0的一种码制。其方法是使用N位状态寄存器来对N个状态进行编码，每个状态都有它独立的寄存器位，并且在任意时候，其中只有一位有效。</p>
<pre><code>自然状态码为：000,001,010,011,100,101

独热编码为：000001,000010,000100,001000,010000,100000
</code></pre>
</li>
</ul>
</li>
<li><p>离散化–等值划分，等量划分</p>
<ul>
<li><p>离散化 在上面介绍过连续值的取值空间可能是无穷的，为了便于表示和在模型中处理，需要对连续值特征进行离散化处理。常用的离散化方法包括等值划分和等量划分。等值划分是将特征按照值域进行均分，每一段内的取值等同处理。例如某个特征的取值范围为[0，10]，我们可以将其划分为10段，[0，1)，[1，2)，…，[9，10)。等量划分是根据样本总数进行均分，每段等量个样本划分为1段。例如距离特征，取值范围［0，3000000］，现在需要切分成10段，如果按照等比例划分的话，会发现绝大部分样本都在第1段中。使用等量划分就会避免这种问题，最终可能的切分是[0，100)，[100，300)，[300，500)，..，[10000，3000000]，前面的区间划分比较密，后面的比较稀疏。正如上文所言，独热编码（哑变量 dummy variable）是因为大部分算法是基于向量空间中的度量来进行计算的，为了使非偏序关系的变量取值不具有偏序性，并且到圆点是等距的。使用one-hot编码，将离散特征的取值扩展到了欧式空间，离散特征的某个取值就对应欧式空间的某个点。将离散型特征使用one-hot编码，会让特征之间的距离计算更加合理。离散特征进行one-hot编码后，编码后的特征，其实每一维度的特征都可以看做是连续的特征。就可以跟对连续型特征的归一化方法一样，对每一维特征进行归一化。比如归一化到[-1,1]或归一化到均值为0,方差为1。       </p>
<pre><code>为什么特征向量要映射到欧式空间？

将离散特征通过one-hot编码映射到欧式空间，是因为，在回归，分类，聚类等机器学习算法中，特征之间距离的计算或相似度的计算是非常重要的，而我们常用的距离或相似度的计算都是在欧式空间的相似度计算，计算余弦相似性，基于的就是欧式空间。
</code></pre>
</li>
</ul>
</li>
<li><p>缺省值处理 from sklearn.preprocessing import Imputer</p>
<ul>
<li>有些特征可能因为无法采样或者没有观测值而缺失，例如距离特征，用户可能禁止获取地理位置或者获取地理位置失败，此时需要对这些特征做特殊的处理，赋予一个缺省值。缺省值如何赋予，也有很多种方法。例如单独表示，众数，平均值等</li>
</ul>
</li>
<li><p>数据变换：常见的数据变换有基于多项式的、基于指数函数的、基于对数函数的</p>
</li>
<li><p>特征降维</p>
<ul>
<li><p>在介绍特征降维之前，先介绍下特征升维。在机器学习中，有一个VC维理论。根据VC维理论，VC维越高，打散能力越强，可容许的模型复杂度越高。在低维不可分的数据，映射到高维是可分。可以想想，给你一堆物品，人脑是如何对这些物品进行分类，依然是找出这些物品的一些特征，例如：颜色，形状，大小，触感等等，然后根据这些特征对物品做以归类，这其实就是一个先升维，后划分的过程。比如我们人脑识别香蕉。可能首先我们发现香蕉是黄色的。这是在颜色这个维度的一个切分。但是很多东西都是黄色的啊，例如哈密瓜。那么怎么区分香蕉和哈密瓜呢？我们发现香蕉形状是弯曲的。而哈密瓜是圆形的，那么我们就可以用形状来把香蕉和哈密瓜划分开了，即引入一个新维度：形状，来区分。这就是一个从“颜色”一维特征升维到二维特征的例子。</p>
</li>
<li><p>那问题来了，既然升维后模型能力能变强，那么是不是特征维度越高越好呢？为什么要进行特征降维&amp;特征选择？主要是出于如下考虑：1. 特征维数越高，模型越容易过拟合，此时更复杂的模型就不好用。2. 相互独立的特征维数越高，在模型不变的情况下，在测试集上达到相同的效果表现所需要的训练样本的数目就越大。 3. 特征数量增加带来的训练、测试以及存储的开销都会增大。4.在某些模型中，例如基于距离计算的模型KMeans，KNN等模型，在进行距离计算时，维度过高会影响精度和性能。5.可视化分析的需要。在低维的情况下，例如二维，三维，我们可以把数据绘制出来，可视化地看到数据。当维度增高时，就难以绘制出来了。在机器学习中，有一个非常经典的维度灾难的概念。用来描述当空间维度增加时，分析和组织高维空间，因体积指数增加而遇到各种问题场景。例如，100个平均分布的点能把一个单位区间以每个点距离不超过0.01采样；而当维度增加到10后，如果以相邻点距离不超过0.01小方格采样单位超一单位超正方体，则需要10^20 个采样点。</p>
</li>
<li><p>正是由于高维特征有如上描述的各种各样的问题，所以我们需要进行特征降维和特征选择等工作。特征降维常用的算法有PCA，LDA等。特征降维的目标是将高维空间中的数据集映射到低维空间数据，同时尽可能少地丢失信息，或者降维后的数据点尽可能地容易被区分 .是对数据在高维空间下的一个投影转换，通过一定的投影规则将原来从一个角度看到的多个维度映射成较少的维度</p>
<ul>
<li><p>PCA算法 (主成分分析)通过协方差矩阵的特征值分解能够得到数据的主成分，以二维特征为例，两个特征之间可能存在线性关系（例如运动的时速和秒速度），这样就造成了第二维信息是冗余的。PCA的目标是发现这种特征之间的线性关系，并去除。</p>
<p>出发思想不同。PCA主要是从特征的协方差角度，去找到比较好的投影方式，即选择样本点投影具有最大方差的方向.在信号处理中认为信号具有较大的方差，噪声有较小的方差，信噪比就是信号与噪声的方差比，越大越好</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu765xm3u3j61aw0u0wic02.jpg" alt="image-20210906201409411"></p>
</li>
<li><p>LDA算法(线性判别分析) 考虑label，降维后的数据点尽可能地容易被区分. LDA则更多的是考虑了分类标签信息，寻求投影后不同类别之间数据点距离更大化以及同一类别数据点距离最小化，即选择分类性能最好的方向.  LDA的思想可以用一句话概括，就是“投影后类内方差最小，类间方差最大”</p>
</li>
<li><p>降维后可用维度数量不同。LDA降维后最多可生成C-1维子空间（分类标签数-1），因此LDA与原始维度N数量无关，只有数据标签分类数量有关；而PCA最多有n维度可用，即最大可以选择全部可用维度。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu76732bgwj61dg0j075d02.jpg" alt="image-20210906201553629"></p>
</li>
</ul>
</li>
</ul>
<p>  上图左侧是PCA的降维思想，它所作的只是将整组数据整体映射到最方便表示这组数据的坐标轴上，映射时没有利用任何数据内部的分类信息。因此，虽然PCA后的数据在表示上更加方便（降低了维数并能最大限度的保持原有信息），但在分类上也许会变得更加困难；上图右侧是LDA的降维思想，可以看到LDA充分利用了数据的分类信息，将两组数据映射到了另外一个坐标轴上，使得数据更易区分了（在低维上就可以区分，减少了运算量）。</p>
</li>
</ul>
</li>
</ul>
<p>线性判别分析LDA算法由于其简单有效性在多个领域都得到了广泛地应用，是目前机器学习、数据挖掘领域经典且热门的一个算法；但是算法本身仍然存在一些局限性：</p>
<p>​			当样本数量远小于样本的特征维数，样本与样本之间的距离变大使得距离度量失效，使LDA算法中的类内、类间离散度矩阵奇异，不能得到最优的投影方向，在人脸识别领域中表现得尤为突出</p>
<p>​				LDA不适合对非高斯分布的样本进行降维</p>
<p>​				LDA在样本分类信息依赖方差而不是均值时，效果不好</p>
<p>​				LDA可能过度拟合数据</p>
<p>LDA用于降维，和PCA有很多相同，也有很多不同的地方，因此值得好好的比较一下两者的降维异同点。<br>首先我们看看相同点：<br>　　1）两者均可以对数据进行降维。<br>　　2）两者在降维时均使用了矩阵特征分解的思想。<br>　　3）两者都假设数据符合高斯分布。<br>我们接着看看不同点：<br>　　1）LDA是有监督的降维方法，而PCA是无监督的降维方法<br>　　2）LDA降维最多降到类别数k-1的维数，而PCA没有这个限制。<br>　　3）LDA除了可以用于降维，还可以用于分类。<br>　　4）LDA选择分类性能最好的投影方向，而PCA选择样本点投影具有最大方差的方向。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当特征选择完成后，可以直接训练模型了，但是可能由于特征矩阵过大，导致计算量大，训练时间长的问题，因此降低特征矩阵维度也是必不可少的。常见的降维方法除了以上提到的基于L1惩罚项的模型以外，另外还有主成分分析法（PCA）和线性判别分析（LDA），线性判别分析本身也是一个分类模型。PCA和LDA有很多的相似点，其本质是要将原始的样本映射到维度更低的样本空间中，但是PCA和LDA的映射目标不一样：</span><br><span class="line"></span><br><span class="line">PCA是为了让映射后的样本具有最大的发散性；</span><br><span class="line">而LDA是为了让映射后的样本有最好的分类性能。</span><br><span class="line">所以说PCA是一种无监督的降维方法，而LDA是一种有监督的降维方法。</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu76d0evyej612m0q6jtl02.jpg" alt="image-20210906202056458"></p>
<h4 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h4><p>当数据预处理完成后，我们需要选择有意义的特征输入机器学习的算法和模型进行训练。通常来说，从两个方面考虑来选择特征：</p>
<ul>
<li>特征是否发散：如果一个特征不发散，例如方差接近于0，也就是说样本在这个特征上基本上没有差异，这个特征对于样本的区分并没有什么用。</li>
<li>特征与目标的相关性：这点比较显见，与目标相关性高的特征，应当优选选择。除方差法外，本文介绍的其他方法均从相关性考虑。</li>
</ul>
<p>　　根据特征选择的形式又可以将特征选择方法分为3种：</p>
<ul>
<li>Filter：过滤法，按照发散性或者相关性对各个特征进行评分，设定阈值或者待选择阈值的个数，选择特征。</li>
<li>Wrapper：包装法，根据目标函数（通常是预测效果评分），每次选择若干特征，或者排除若干特征。</li>
<li>Embedded：嵌入法，先使用某些机器学习的算法和模型进行训练，得到各个特征的权值系数，根据系数从大到小选择特征。类似于Filter方法，但是是通过训练来确定特征的优劣。</li>
</ul>
<p>　　我们使用sklearn中的feature_selection库来进行特征选择。</p>
<h5 id="方差选择法"><a href="#方差选择法" class="headerlink" title="方差选择法"></a>方差选择法</h5><p>用方差选择法，先要计算各个特征的方差，然后根据阈值，选择方差大于阈值的特征。使用feature_selection库的VarianceThreshold类来选择特征的代码如下：</p>
<h3 id="sklearn进行数据挖掘"><a href="#sklearn进行数据挖掘" class="headerlink" title="sklearn进行数据挖掘"></a>sklearn进行数据挖掘</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jasonfreak/p/5448462.html">https://www.cnblogs.com/jasonfreak/p/5448462.html</a></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu87lsl5g2j61d40ikac002.jpg" alt="image-20210907175015539"></p>
<h4 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h4><p>　　并行处理，流水线处理，自动化调参，持久化是使用sklearn优雅地进行数据挖掘的核心。并行处理和流水线处理将多个特征处理工作，甚至包括模型训练工作组合成一个工作（从代码的角度来说，即将多个对象组合成了一个对象）。在组合的前提下，自动化调参技术帮我们省去了人工调参的反锁。训练好的模型是贮存在内存中的数据，持久化能够将这些数据保存在文件系统中，之后使用时无需再进行训练，直接从文件系统中加载即可</p>
<ul>
<li>并行处理：并行处理使得多个特征处理工作能够并行地进行。根据对特征矩阵的读取方式不同，可分为整体并行处理和部分并行处理。整体并行处理，即并行处理的每个工作的输入都是特征矩阵的整体；部分并行处理，即可定义每个工作需要输入的特征矩阵的列</li>
<li>部分并行处理： 整体并行处理有其缺陷，在一些场景下，我们只需要对特征矩阵的某些列进行转换，而不是所有列。pipeline并没有提供相应的类（仅OneHotEncoder类实现了该功能），需要我们在FeatureUnion的基础上进行优化</li>
<li>流水线处理：　　pipeline包提供了Pipeline类来进行流水线处理。流水线上除最后一个工作以外，其他都要执行fit_transform方法，且上一个工作输出作为下一个工作的输入。最后一个工作必须实现fit方法，输入为上一个工作的输出；但是不限定一定有transform方法，因为流水线的最后一个工作可能是训练！</li>
<li>自动化调参：网格搜索为自动化调参的常见技术之一，grid_search包提供了自动化调参的工具，包括GridSearchCV类。<strong>穷举搜索</strong>：在所有候选的参数选择中，通过循环遍历，尝试每一种可能性，表现最好的参数就是最终的结果。其原理就像是在数组里找最大值。<ul>
<li>存在问题：原始数据集划分成训练集和测试集以后，其中测试集除了用作调整参数，也用来测量模型的好坏；这样做导致最终的评分结果比实际效果要好。 耗时</li>
<li>对训练集再进行一次划分，分成训练集和验证集，这样划分的结果就是：原始数据划分为3份，分别为：训练集、验证集和测试集；其中训练集用来模型训练，验证集用来调整参数，而测试集用来衡量模型表现好坏。</li>
</ul>
</li>
<li>持久化：　externals.joblib包提供了dump和load方法来持久化和加载内存数据：</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-26T09:35:22.713Z" title="1/26/2024, 5:35:22 PM">2024-01-26</time>发表</span><span class="level-item"><time dateTime="2024-01-31T07:48:49.725Z" title="1/31/2024, 3:48:49 PM">2024-01-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/100-CoderSkills/">100_CoderSkills</a><span> / </span><a class="link-muted" href="/categories/100-CoderSkills/102-Python/">102_Python</a></span><span class="level-item">6 分钟读完 (大约887个字)</span></div></div><div class="content"><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu9gripz4oj61cv0u0wld02.jpg" alt="image-20210908195234323"></p>
<h1 id="四大块"><a href="#四大块" class="headerlink" title="四大块"></a>四大块</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44623752/article/details/118975075">https://blog.csdn.net/weixin_44623752/article/details/118975075</a></p>
<p>1，给定一个样本特征 , 我们希望预测其对应的属性值 , 如果 是离散的, 那么这就是一个分类问题，反之，如果 是连续的实数, 这就是一个回归问题。<br>2，如果给定一组样本特征 , 我们没有对应的属性值 , 而是想发掘这组样本在 二维空间的分布, 比如分析哪些样本靠的更近，哪些样本之间离得很远, 这就是属于聚类问题。<br>3，如果我们想用维数更低的子空间来表示原来高维的特征空间, 那么这就是降维问题。</p>
<p>无论是分类还是回归，都是想建立一个预测模型 ，给定一个输入 , 可以得到一个输出，<strong>不同的只是在分类问题中,</strong> <strong>是离散的; 而在回归问题中</strong> <strong>是连续的</strong></p>
<h2 id="分类-classification"><a href="#分类-classification" class="headerlink" title="分类 classification"></a>分类 classification</h2><p>有监督学习的两大应用之一，产生离散的结果</p>
<p><strong>分类问题最常用的学习算法包括 SVM (支持向量机) , SGD (随机梯度下降算法), Bayes (贝叶斯估计), Ensemble, KNN 等。</strong>而<strong>回归问题也能使用 SVR, SGD, Ensemble 等算</strong>法，以及其它线性回归算法。</p>
<p>例如向模型输入人的各种数据的训练样本，产生“输入一个人的数据，判断是否患有癌症”的结果，结果必定是离散的，只有“是”或“否”。（即有目标和标签，能判断目标特征是属于哪一个类型）</p>
<h2 id="回归-regression"><a href="#回归-regression" class="headerlink" title="回归 regression"></a>回归 regression</h2><p>有监督学习的两大应用之一，产生连续的结果。</p>
<p>例如向模型输入人的各种数据的训练样本，产生“输入一个人的数据，判断此人20年后今后的经济能力”的结果，结果是连续的，往往得到一条回归曲线。当输入自变量不同时，输出的因变量非离散分布（不仅仅是一条线性直线，多项曲线也是回归曲线）。<br>classification &amp; regression：分类与回归</p>
<h2 id="聚类-clustering"><a href="#聚类-clustering" class="headerlink" title="聚类 clustering"></a>聚类 clustering</h2><p>聚类也是分析样本的属性, 有点类似classification, 不同的就是classification 在预测之前是知道  的范围, 或者说知道到底有几个类别, 而聚类是不知道属性的范围的。所以 classification 也常常被称为 supervised learning, 而clustering就被称为unsupervised learning。<br>clustering 事先不知道样本的属性范围，只能凭借样本在特征空间的分布来分析样本的属性。这种问题一般更复杂。而常用的算法包括 k-means (K-均值), GMM (高斯混合模型) 等。</p>
<p>无监督学习的结果。聚类的结果将产生一组集合，集合中的对象与同集合中的对象彼此相似，与其他集合中的对象相异。</p>
<h2 id="降维-dimensionality-reduction"><a href="#降维-dimensionality-reduction" class="headerlink" title="降维 dimensionality reduction"></a>降维 dimensionality reduction</h2><p>降维是机器学习另一个重要的领域, 降维有很多重要的应用, **特征的维数过高, 会增加训练的负担与存储空间, 降维就是希望去除特征的冗余, 用更加少的维数来表示特征.**降维算法最基础的就是PCA了, 后面的很多算法都是以PCA为基础演化而来。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-26T09:35:22.713Z" title="1/26/2024, 5:35:22 PM">2024-01-26</time>发表</span><span class="level-item"><time dateTime="2024-01-31T07:48:49.725Z" title="1/31/2024, 3:48:49 PM">2024-01-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/100-CoderSkills/">100_CoderSkills</a><span> / </span><a class="link-muted" href="/categories/100-CoderSkills/106-Cpp/">106_Cpp</a></span><span class="level-item">38 分钟读完 (大约5651个字)</span></div></div><div class="content"><hr>
<p>00_CppInterview<br>aliases:<br>tags: #cs#interview #cpp<br>date: 2023-10-08 15:29</p>
<hr>
<h2 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h2><h3 id="对new和malloc的理解"><a href="#对new和malloc的理解" class="headerlink" title="对new和malloc的理解"></a>对new和malloc的理解</h3><p>new和malloc都是动态内存分配函数。其中，new是C++中的操作符，malloc是C语言中的函数。new会调用对象的构造函数，而malloc不会。使用new可以简化代码，并且更加类型安全。<br><strong>new和malloc区别：</strong></p>
<ul>
<li><p><strong>分配内存的位置</strong>：malloc是从堆上动态分配内存，new是从自由存储区为对象动态分配内存。自由存储区的位置取决于operator new的实现。自由存储区不仅可以为堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。</p>
</li>
<li><p><strong>返回类型安全性</strong>：malloc内存分配成功后返回void*，然后再强制类型转换为需要的类型；new操作符分配内存成功后返回与对象类型相匹配的指针类型；因此new是符合类型安全的操作符。</p>
</li>
<li><p><strong>内存分配失败返回值</strong>：malloc内存分配失败后返回NULL。new分配内存失败则会抛异常（bac_alloc）。</p>
</li>
<li><p><strong>分配内存的大小的计算</strong>：使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。</p>
</li>
<li><p><strong>是否可以被重载</strong>：opeartor new &#x2F;operator delete可以被重载。而malloc&#x2F;free则不能重载。</p>
</li>
</ul>
<p><strong>new是在内存上哪一块去分配的内存</strong></p>
<p>堆</p>
<p><strong>补充：</strong></p>
<p>new所申请的内存区域在C++中称为自由存储区。很多编译器的new&#x2F;delete都是以malloc&#x2F;free为基础来实现的，所以通常都是借由堆实现来实现自由存储，这时候就可以说new所申请的内存区域在堆上。</p>
<p><strong>如果new内存失败了会是怎么样？</strong></p>
<p>会抛出std::bad_alloc异常。</p>
<p><strong>补充：</strong></p>
<p>如果加上std::nothrow关键字，A* p &#x3D; new (std::nothrow) A;，new 就不会抛出异常而是会返回空指针。</p>
<h3 id="析构函数为什么通常是会做成一个虚函数呢"><a href="#析构函数为什么通常是会做成一个虚函数呢" class="headerlink" title="析构函数为什么通常是会做成一个虚函数呢"></a>析构函数为什么通常是会做成一个虚函数呢</h3><p>如果一个类有虚函数，就应该为其定义一个虚析构函数。这是因为在使用delete操作符释放一个指向派生类对象的基类指针时，如果基类的析构函数不是虚函数，那么只会调用基类的析构函数，而不会调用派生类的析构函数，这样就会导致内存泄漏和未定义行为的问题。通过将析构函数定义为虚函数，可以确保在释放派生类对象时，先调用派生类的析构函数，再调用基类的析构函数，从而避免内存泄漏和未定义行为的问题。</p>
<h3 id="右值引用有什么作用"><a href="#右值引用有什么作用" class="headerlink" title="右值引用有什么作用"></a>右值引用有什么作用</h3><p>右值引用是C++11引入的特性，它是指对右值进行引用的一种方式。右值引用的作用主要有两个：</p>
<ul>
<li>在传递一个对象时，如果使用的是左值引用，那么会调用对象的拷贝构造函数。但是如果该对象只需要被移动而不需要进行复制，就会浪费时间和内存。右值引用可以通过std::move将一个左值转换为右值，从而调用对象的移动构造函数，实现了移动语义，避免了不必要的拷贝操作，提高了程序的效率。</li>
<li>右值引用还可以用于完美转发。在函数模板中，通过使用右值引用类型的形参来接收参数，可以实现完美转发，即保持原参数的值类别（左值还是右值），将参数传递给另一个函数。</li>
</ul>
<h3 id="智能指针相关"><a href="#智能指针相关" class="headerlink" title="智能指针相关"></a>智能指针相关</h3><p><strong>定义</strong><br>智能指针是C++中的一种特殊指针，它是一个对象，用来管理另一个指针所指向的对象的生命周期。智能指针可以自动地分配和释放内存，避免手动管理内存的麻烦和出错风险。</p>
<p>C++标准库提供了三种智能指针：</p>
<ul>
<li>shared_ptr：多个智能指针可以共享同一个对象，当最后一个指针被销毁时，它会释放对象的内存。</li>
<li>unique_ptr：独占式智能指针，不能共享同一个对象，当智能指针被销毁时，它会释放对象的内存。</li>
<li>weak_ptr：弱引用智能指针，不会增加对象的引用计数，用于避免shared_ptr循环引用时的内存泄漏问题。</li>
</ul>
<p><strong>在哪些场景下会应用智能指针</strong></p>
<p>我自己是在在动态内存管理中，使用智能指针可以避免手动管理内存的麻烦和出错风险。</p>
<h3 id="如果遇到内存泄漏这种问题，你一般是怎么去解决"><a href="#如果遇到内存泄漏这种问题，你一般是怎么去解决" class="headerlink" title="如果遇到内存泄漏这种问题，你一般是怎么去解决"></a>如果遇到内存泄漏这种问题，你一般是怎么去解决</h3><ul>
<li>在程序中加入必要的错误处理代码，避免程序因为异常情况而导致内存泄漏。</li>
<li>使用智能指针等RAII机制，自动管理内存，避免手动管理内存的麻烦和出错风险。</li>
<li>使用内存分析工具，检测程序中的内存泄漏，并进行相应的修复</li>
</ul>
<h3 id="shared-ptr的原理"><a href="#shared-ptr的原理" class="headerlink" title="shared_ptr的原理"></a>shared_ptr的原理</h3><p>答：内部的共享数据和引用计数实现</p>
<p><strong>补充：</strong></p>
<p>shared_ptr多个指针指向相同的对象。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。</p>
<p>shared_ptr的一个最大的陷阱是循环引用，循环引用会导致堆内存无法正确释放，导致内存泄漏，可以通过 weak_ptr 来解决这个问题。</p>
<h3 id="多线程怎么保证引用计数的安全的"><a href="#多线程怎么保证引用计数的安全的" class="headerlink" title="多线程怎么保证引用计数的安全的"></a>多线程怎么保证引用计数的安全的</h3><p>答：引用计数这个变量是std::atomic，操作时自带锁</p>
<h3 id="常见的锁有哪些"><a href="#常见的锁有哪些" class="headerlink" title="常见的锁有哪些"></a>常见的锁有哪些</h3><p>答：读写锁、互斥锁这些，再就是一些锁思想，比如乐观锁、悲观锁、自旋锁</p>
<h3 id="valotile关键字的用处"><a href="#valotile关键字的用处" class="headerlink" title="valotile关键字的用处"></a>valotile关键字的用处</h3><p><code>volatile</code>是C和C++中的一个关键字，用于告诉编译器，所修饰的变量在程序执行期间可能会被意外地改变，因此不能进行优化。下面是几个<code>volatile</code>关键字的用处：</p>
<ol>
<li>防止编译器进行优化 当使用<code>volatile</code>关键字修饰变量时，编译器就不会对这个变量进行优化，因为这个变量可能会在程序运行期间被其他程序或者硬件进行修改。例如：</li>
</ol>
<p><code>volatile int* ptr = ...; int a = *ptr;</code></p>
<p>如果<code>ptr</code>所指向的内存是由硬件设备直接控制，则编译器不能对其进行优化。</p>
<ol start="2">
<li><p>多线程访问同一个变量 在多线程编程中，如果多个线程都需要访问同一个变量，并且该变量可能会被其他线程修改，则应该使用<code>volatile</code>来修饰这个变量，以确保每个线程都能正确读取变量的最新值。</p>
</li>
<li><p>访问硬件寄存器 当程序需要访问硬件寄存器时，应该使用<code>volatile</code>来修饰寄存器，因为寄存器的值可能会被其他程序或者硬件进行修改。</p>
</li>
</ol>
<p>总之，<code>volatile</code>关键字用于告诉编译器，所修饰的变量在程序执行期间可能会被意外地改变，因此不能进行优化。在多线程编程和访问硬件寄存器时，应该使用<code>volatile</code>来修饰变量，以确保程序能够正确地读取最新的值。</p>
<ul>
<li>数组、指针和引用的区别</li>
<li>类成员和方法，说出方法匹配顺序、默认参数</li>
<li>继承 构造函数和析构函数 调用顺序</li>
<li>const、static的使用场景</li>
<li>多态的实现、虚表实现多态机制</li>
<li>虚函数、纯虚函数、抽象类概念，抽象类为什么不能实例化</li>
</ul>
<h3 id="vector和list区别，-内存分别，-不同的使用场景，"><a href="#vector和list区别，-内存分别，-不同的使用场景，" class="headerlink" title="vector和list区别， 内存分别， 不同的使用场景，"></a>vector和list区别， 内存分别， 不同的使用场景，</h3><p><code>vector</code>和<code>list</code>都是C++ STL（Standard Template Library）中的容器。它们在存储数据时的内存分配方式不同，具有以下几点区别：</p>
<ol>
<li><p>存储方式 <code>vector</code>采用连续的动态数组存储元素，因此在访问元素时可以随机访问，速度较快。而<code>list</code>采用双向链表存储元素，因此在访问元素时只能顺序访问，速度相对较慢。</p>
</li>
<li><p>内存分配 由于<code>vector</code>采用连续的动态数组存储元素，因此需要预分配一块连续的内存空间。当插入元素时，如果当前内存空间不足，则需要重新分配一块更大的内存空间，并将原有元素复制到新的内存空间中。而<code>list</code>则是通过链表进行存储，每个节点存储一个元素，因此在插入或者删除元素时，只需要修改相应的链表指针即可。</p>
</li>
<li><p>内存占用 由于<code>vector</code>需要预分配一段连续的内存空间，因此在存储大量元素时可能会浪费一定的内存空间。而<code>list</code>则是通过链表进行存储，每个节点只存储一个元素和两个指针，因此在存储大量元素时占用的内存空间相对较小。</p>
</li>
<li><p>插入、删除操作 由于<code>vector</code>采用连续的动态数组存储元素，因此在插入或者删除元素时需要移动其它元素，并且可能需要重新分配内存空间。而<code>list</code>则是通过链表进行存储，每个节点只需要修改指针即可进行插入或者删除操作。</p>
</li>
</ol>
<p>总之，<code>vector</code>和<code>list</code>是C++ STL中的常用容器，它们在存储数据时的内存分配方式不同，具有各自的优缺点。在使用时需要根据具体情况选择合适的容器，并结合实际场景进行性能分析和测试，以确保程序的高效运行。</p>
<h3 id="swap实现快速删除"><a href="#swap实现快速删除" class="headerlink" title="swap实现快速删除"></a>swap实现快速删除</h3><h3 id="vector和list区别"><a href="#vector和list区别" class="headerlink" title="vector和list区别"></a><code>vector</code>和list区别</h3><p>都是C++ STL（Standard Template Library）中的容器。它们在存储数据时的内存分配方式不同，具有以下几点区别：</p>
<ol>
<li><p>存储方式 <code>vector</code>采用连续的动态数组存储元素，因此在访问元素时可以随机访问，速度较快。而<code>list</code>采用双向链表存储元素，因此在访问元素时只能顺序访问，速度相对较慢。</p>
</li>
<li><p>内存分配 由于<code>vector</code>采用连续的动态数组存储元素，因此需要预分配一块连续的内存空间。当插入元素时，如果当前内存空间不足，则需要重新分配一块更大的内存空间，并将原有元素复制到新的内存空间中。而<code>list</code>则是通过链表进行存储，每个节点存储一个元素，因此在插入或者删除元素时，只需要修改相应的链表指针即可。</p>
</li>
<li><p>内存占用 由于<code>vector</code>需要预分配一段连续的内存空间，因此在存储大量元素时可能会浪费一定的内存空间。而<code>list</code>则是通过链表进行存储，每个节点只存储一个元素和两个指针，因此在存储大量元素时占用的内存空间相对较小。</p>
</li>
<li><p>插入、删除操作 由于<code>vector</code>采用连续的动态数组存储元素，因此在插入或者删除元素时需要移动其它元素，并且可能需要重新分配内存空间。而<code>list</code>则是通过链表进行存储，每个节点只需要修改指针即可进行插入或者删除操作。</p>
</li>
</ol>
<p>总之，<code>vector</code>和<code>list</code>是C++ STL中的常用容器，它们在存储数据时的内存分配方式不同，具有各自的优缺点。在使用时需要根据具体情况选择合适的容器，并结合实际场景进行性能分析和测试，以确保程序的高效运行。</p>
<ul>
<li><p>map实现，map.find时间复杂度</p>
</li>
<li><p>gdb的使用， 如何调试多线程</p>
</li>
<li><p>浅拷贝、深拷贝，如何通过自定义拷贝构造函数实现深拷贝</p>
</li>
<li><p>map、unorder_map区别，了解使用场景</p>
</li>
<li><p>new、delete过程，继承情况下调用顺序</p>
</li>
<li><p>全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？<br>  <code>  可以，在不同的C文件中以static形式来声明同名全局变量。可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错.  </code></p>
</li>
<li><p>static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？Static函数与普通函数有什么区别？<br>  <code>  (1)把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。    全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。(2)把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。(3)static函数与普通函数作用域不同,仅在本文件。    综上所述:     static全局变量与普通的全局变量有什么区别：    static全局变量只初使化一次，防止在其他文件单元中被引用;    static局部变量和普通局部变量有什么区别：    static局部变量只被初始化一次，下一次依据上一次结果值；    static函数与普通函数有什么区别：    static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝  </code></p>
</li>
<li><p>以下代码存在的问题？<br>  <code>  char string[] = “Linux C”;   char *p = “Linux C”;   string[0] = &#39;a&#39;;   p[0] = &#39;a&#39;;   注：”Linux C”是一个字符串常量。C语言对于字符串常量通常是这样处理的：在内存中开辟一个字符数组来存储该字符串常量，并把开辟出的字符数组的首地址赋给p.   注：string[0] = ‘a’是可以的，而p[0] = ‘a’是非法的，因为p指向的是字符串常量，常量的内容不可改变。把p指向一个字符串常量或字符数组时合法的，例如：p = “Hello World!”; p= string;</code></p>
</li>
<li><p>什么函数不能声明为虚函数？<br>  <code>构造函数</code></p>
</li>
<li><p>不能做switch()的参数类型<br>  <code>switch的参数不能为实型。</code></p>
</li>
<li><p>如何引用一个已经定义过的全局变量？<br>  <code>可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变量，假定你将那个变量写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。</code></p>
</li>
<li><p>C++中虚函数的意义<br>  &#96;&#96;<br>  C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数；在派生类中对基类定义的虚函数进行重写时，需要再派生类中声明该方法为虚方法。当子类重新定义了父类的虚函数后，当父类的指针指向子类对象的地址时，[即B b; A a &#x3D; &amp;b;] 父类指针根据赋给它的不同子类指针，动态的调用子类的该函数，而不是父类的函数（如果不使用virtual方法，请看后面★*），且这样的函数调用发生在运行阶段，而不是发生在编译阶段，称为动态联编。而函数的重载可以认为是多态，只不过是静态的。注意，非虚函数静态联编，效率要比虚函数高，但是不具备动态联编能力。</p>
<p>  如果使用了virtual关键字，程序将根据引用或指针指向的 对 象 类 型 来选择方法，否则使用引用类型或指针类型来选择方法。<br>  编译器处理虚函数的方法是：为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，称为虚表指针（vptr），这种数组成为虚函数表（virtual function table, vtbl），即，每个类使用一个虚函数表，每个类对象用一个虚表指针。<br>  举个例子：基类对象包含一个虚表指针，指向基类中所有虚函数的地址表。派生类对象也将包含一个虚表指针，指向派生类虚函数表。看下面两种情况：<br>  如果派生类重写了基类的虚方法，该派生类虚函数表将保存重写的虚函数的地址，而不是基类的虚函数地址。<br>  如果基类中的虚方法没有在派生类中重写，那么派生类将继承基类中的虚方法，而且派生类中虚函数表将保存基类中未被重写的虚函数的地址。注意，如果派生类中定义了新的虚方法，则该虚函数的地址也将被添加到派生类虚函数表中。</p>
<p>  &#96;&#96;</p>
</li>
<li><p>参见《Effective C++》 条款09：绝不在构造函数或析构函数中调用虚函数。<br>  <code>原因分析：１.　从语法上讲，调用完全没有问题。２.　但是从效果上看，往往不能达到需要的目的。Effective 的解释是：派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。同样，进入基类析构函数时，对象也是基类类型。所以，虚函数始终仅仅调用基类的虚函数（如果是基类调用虚函数），不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果。</code></p>
</li>
<li><p>一个C++对象的大小由哪些因素决定？基类，成员，内存对齐，虚函数。</p>
</li>
<li><p>C++对象的成员函数对对象大小有什么影响？是否有虚函数，虚函数的个数多少对对象大小有什么影响？</p>
</li>
<li><p>一个C++对象的初始化顺序是什么？</p>
</li>
<li><p>虚析构函数有什么用途？</p>
</li>
<li><p>new operator和operator new什么区别和联系？</p>
</li>
<li><p>什么是placement new？</p>
</li>
<li><p>STL迭代器按照支持的操作分为哪几类？</p>
</li>
<li><p>Map和UnorderedMap的主要区别是什么？如何选择？</p>
</li>
<li><p>UnorderedMap如何解决Hash冲突？</p>
</li>
<li><p>Deque和Vector有什么区别？</p>
</li>
<li><p>什么是RAII机制？</p>
</li>
<li><p>在C++中，如何避免内存泄漏？</p>
</li>
<li><p>智能指针有哪些？什么用途？</p>
</li>
</ul>
<p>面试问题</p>
<p>1）TCP&#x2F;IP协议<br>    1）三次握手&#x2F;四次挥手过程<br>    2）TIME_WAIT状态<br>        1）主动关闭&#x2F;被动关闭<br>        2）需要的原因<br>        3）缓解措施<br>        4）有没有方式不出现TIME_WAIT状态<br>    3）RST出现的场景<br>    4）滑动窗口<br>2）网络编程<br>    1）EPOLL&#x2F;SELECT的区别<br>    2）边沿触发&#x2F;水平触发<br>    3）事件触发的场景<br>        1）读事件 有哪些场景<br>        2）写事件 有哪些场景<br>    4）READ调用返回值场景<br>        1）0<br>        2）-1<br>        3）&gt;0<br>    5）UDP客户端可以CONNECT不，那CONNECT和不CONNECT有啥区别<br>3）后台编程<br>    1）FORK的用途，FORK区分父子进程方式<br>    2）进程间通信方式<br>    3）僵尸进程<br>    4）内存模型，有哪些段构成<br>    5）进程&#x2F;线程&#x2F;协程的区别<br>4）常见中间件<br>    1）MYSQL<br>        1）为啥不建议SELECT *<br>        2）覆盖索引<br>        3）分页优化<br>    2）ZOOKEEPER<br>        1）有哪些WATCH以及对应唤醒事件<br>    3）KAFKA<br>        1）分区分服<br>        2）生产者<br>        3）消费者<br>5）语言<br>    1）JAVA语言<br>        1）内存管理<br>6）设计模式<br>    1）单例模式<br>7）项目中的难点、挑战点</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-26T09:35:22.712Z" title="1/26/2024, 5:35:22 PM">2024-01-26</time>发表</span><span class="level-item"><time dateTime="2024-01-31T08:52:17.906Z" title="1/31/2024, 4:52:17 PM">2024-01-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/100-CoderSkills/">100_CoderSkills</a><span> / </span><a class="link-muted" href="/categories/100-CoderSkills/101-OS/">101_OS</a></span><span class="level-item">7 分钟读完 (大约1108个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/26/100_CodingSkills/101_Basic/Linux/">[object Object]</a></p><div class="content">这里是摘要。也可以用在文章中需要截断的地方增加<!--more-->,首页就会显示这条指令以上的内容，隐藏接下来的内容</div><a class="article-more button is-small is-size-7" href="/2024/01/26/100_CodingSkills/101_Basic/Linux/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-26T09:35:22.712Z" title="1/26/2024, 5:35:22 PM">2024-01-26</time>发表</span><span class="level-item"><time dateTime="2024-02-05T02:50:39.237Z" title="2/5/2024, 10:50:39 AM">2024-02-05</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/100-CoderSkills/">100_CoderSkills</a><span> / </span><a class="link-muted" href="/categories/100-CoderSkills/101-OS/">101_OS</a></span><span class="level-item">34 分钟读完 (大约5087个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/01/26/100_CodingSkills/101_Basic/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/">[object Object]</a></p><div class="content">这里是摘要。也可以用在文章中需要截断的地方增加<!--more-->,首页就会显示这条指令以上的内容，隐藏接下来的内容</div><a class="article-more button is-small is-size-7" href="/2024/01/26/100_CodingSkills/101_Basic/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/#more">阅读更多</a></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/3/">上一页</a></div><div class="pagination-next"><a href="/page/5/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link is-current" href="/page/4/">4</a></li><li><a class="pagination-link" href="/page/5/">5</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="Amazing Coder"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Amazing Coder</p><p class="is-size-6 is-block">A programmer who loves coding and life.</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Xi&#039;an China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">43</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">5</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/amazingcoderxyz/" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/amazingcoderxyz/"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/100-CoderSkills/"><span class="level-start"><span class="level-item">100_CoderSkills</span></span><span class="level-end"><span class="level-item tag">24</span></span></a><ul><li><a class="level is-mobile" href="/categories/100-CoderSkills/101-OS/"><span class="level-start"><span class="level-item">101_OS</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/100-CoderSkills/102-Python/"><span class="level-start"><span class="level-item">102_Python</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/100-CoderSkills/103-DesignMode/"><span class="level-start"><span class="level-item">103_DesignMode</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/100-CoderSkills/104-Coding/"><span class="level-start"><span class="level-item">104_Coding</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/100-CoderSkills/105-MiddleWare/"><span class="level-start"><span class="level-item">105_MiddleWare</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/100-CoderSkills/106-Cpp/"><span class="level-start"><span class="level-item">106_Cpp</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/100-CoderSkills/106-Network/"><span class="level-start"><span class="level-item">106_Network</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/100-CoderSkills/107-Productivity/"><span class="level-start"><span class="level-item">107_ Productivity</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/200-SoftSkills/"><span class="level-start"><span class="level-item">200_SoftSkills</span></span><span class="level-end"><span class="level-item tag">15</span></span></a><ul><li><a class="level is-mobile" href="/categories/200-SoftSkills/Trade/"><span class="level-start"><span class="level-item">Trade</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/200-SoftSkills/%E8%AF%BB%E4%B9%A6%E5%8D%A1/"><span class="level-start"><span class="level-item">读书卡</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/300-Sinology/"><span class="level-start"><span class="level-item">300_Sinology</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/TAG1/"><span class="tag">TAG1</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TAG2/"><span class="tag">TAG2</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cs/"><span class="tag">cs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/interview/"><span class="tag">interview</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/os/"><span class="tag">os</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-26T09:35:22.796Z">2024-01-26</time></p><p class="title"><a href="/2024/01/26/200_SoftSkills/%E8%AF%BB%E4%B9%A6%E5%8D%A1/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%A1%E7%89%87/"> </a></p><p class="categories"><a href="/categories/200-SoftSkills/">200_SoftSkills</a> / <a href="/categories/200-SoftSkills/%E8%AF%BB%E4%B9%A6%E5%8D%A1/">读书卡</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-26T09:35:22.796Z">2024-01-26</time></p><p class="title"><a href="/2024/01/26/200_SoftSkills/%E8%AF%BB%E4%B9%A6%E5%8D%A1/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AF%BB%E7%BB%8F%E5%85%B8/"> </a></p><p class="categories"><a href="/categories/200-SoftSkills/">200_SoftSkills</a> / <a href="/categories/200-SoftSkills/%E8%AF%BB%E4%B9%A6%E5%8D%A1/">读书卡</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-26T09:35:22.796Z">2024-01-26</time></p><p class="title"><a href="/2024/01/26/200_SoftSkills/%E8%AF%BB%E4%B9%A6%E5%8D%A1/%E4%BB%80%E4%B9%88%E6%98%AF%E8%AF%BB%E4%B9%A6%E5%8D%A1%E7%89%87/"> </a></p><p class="categories"><a href="/categories/200-SoftSkills/">200_SoftSkills</a> / <a href="/categories/200-SoftSkills/%E8%AF%BB%E4%B9%A6%E5%8D%A1/">读书卡</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-26T09:35:22.796Z">2024-01-26</time></p><p class="title"><a href="/2024/01/26/200_SoftSkills/%E8%AF%BB%E4%B9%A6%E5%8D%A1/%E5%A6%82%E4%BD%95%E5%86%99%E5%8D%A1%E7%89%87/"> </a></p><p class="categories"><a href="/categories/200-SoftSkills/">200_SoftSkills</a> / <a href="/categories/200-SoftSkills/%E8%AF%BB%E4%B9%A6%E5%8D%A1/">读书卡</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-26T09:35:22.795Z">2024-01-26</time></p><p class="title"><a href="/2024/01/26/300_Sinology/%E6%97%A0%E6%AC%B2%E5%88%99%E5%88%9A/"> </a></p><p class="categories"><a href="/categories/300-Sinology/">300_Sinology</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">42</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Amazing Coder" height="28"></a><p class="is-size-7"><span>&copy; 2024 小武哥</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/amazingcoderxyz/"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>