<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Amazing Coder</title>
  
  <subtitle>Coding the future</subtitle>
  <link href="http://amazingcoderpro.github.io/atom.xml" rel="self"/>
  
  <link href="http://amazingcoderpro.github.io/"/>
  <updated>2023-10-08T07:29:00.000Z</updated>
  <id>http://amazingcoderpro.github.io/</id>
  
  <author>
    <name>Amazing Coder</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux系统管理常用命令</title>
    <link href="http://amazingcoderpro.github.io/2023/10/08/Tech/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://amazingcoderpro.github.io/2023/10/08/Tech/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2023-10-08T07:29:00.000Z</published>
    <updated>2023-10-08T07:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux系统管理常用命令"><a href="#Linux系统管理常用命令" class="headerlink" title="Linux系统管理常用命令"></a>Linux系统管理常用命令</h1><h2 id="1-文件管理"><a href="#1-文件管理" class="headerlink" title="1 文件管理"></a>1 文件管理</h2><h3 id="识别文件类型-ls"><a href="#识别文件类型-ls" class="headerlink" title="识别文件类型 ls"></a>识别文件类型 ls</h3><ul><li>文件类开：d:目录文件，l： 链接文件， b: 块设备文件， -: 普通文件</li><li>-l 列表显示</li><li>ls -lt&#x2F;-lrt #  按时间排序或倒序</li><li>ll | grep ^d 显示所有文件夹</li><li>-a 显示包含隐藏</li></ul><h3 id="列出目录结构-tree"><a href="#列出目录结构-tree" class="headerlink" title="列出目录结构 tree"></a>列出目录结构 tree</h3><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ul><li>Linux树状目录结构，最上层目录为根目录 &#x2F;</li><li>一切皆文件</li></ul><h3 id="vi-和-vim区别"><a href="#vi-和-vim区别" class="headerlink" title="vi 和 vim区别"></a>vi 和 vim区别</h3><ul><li>vi 是内置的 ， vim 算是增强版</li><li>i I , a A , o O , r R</li><li>:set nu</li><li>输入行数，shift+g</li><li>gg, GG</li><li>3yy, 3dd, u, x</li></ul><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><ul><li>-a 显示包含隐藏 </li><li>-l 列表显示</li></ul><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><ul><li>cd ~&#x2F; cd ;  —–切到当前用户目录 </li><li>使用绝对或相对路径 </li><li>cd .. 上一级</li></ul><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><ul><li>默认只能创建一级 </li><li>-p 一次性创建多级</li></ul><h3 id="文件权限修改-chmod"><a href="#文件权限修改-chmod" class="headerlink" title="文件权限修改 chmod"></a>文件权限修改 chmod</h3><ul><li>rwx 421</li><li>chmod +x *.sh </li><li>chmod -R 777 &#x2F;tmp&#x2F;test&#x2F;  注：-R参数递归所有子目录，给所有文件加了 777权限</li></ul><h3 id="修改文件或目录的归属信息-chown"><a href="#修改文件或目录的归属信息-chown" class="headerlink" title="修改文件或目录的归属信息 chown"></a>修改文件或目录的归属信息 chown</h3><ul><li>chown zhangsan 123.txt # 把123.txt归属到zhangsan名下</li><li>chown zhangsan:group_name 123.txt # 把123.txt归属到zhangsan名下</li></ul><h3 id="查看文件状态-stat"><a href="#查看文件状态-stat" class="headerlink" title="查看文件状态 stat"></a>查看文件状态 stat</h3><ul><li>stat 123.txt</li></ul><h3 id="设置默认文件、目录权限-umask"><a href="#设置默认文件、目录权限-umask" class="headerlink" title="设置默认文件、目录权限 umask"></a>设置默认文件、目录权限 umask</h3><ul><li>文件 666-umask</li><li>目录 777-umask</li></ul><h3 id="打开文件的几种方式"><a href="#打开文件的几种方式" class="headerlink" title="打开文件的几种方式"></a>打开文件的几种方式</h3><h4 id="cat-从首至尾的顺序打印-只能看不能改"><a href="#cat-从首至尾的顺序打印-只能看不能改" class="headerlink" title="cat 从首至尾的顺序打印, 只能看不能改"></a>cat 从首至尾的顺序打印, 只能看不能改</h4><ul><li>-n 显示行号</li><li>-A 显示尾部隐藏符号，经常windows上的文件在linux环境无法使用问题查看</li><li>cat 有连接功能，可以一次打开多个文件，比如cat 1.txt 2.txt</li><li>| more 分页显示， 按空格翻到下一页</li></ul><h4 id="tac-反序打印出来"><a href="#tac-反序打印出来" class="headerlink" title="tac 反序打印出来"></a>tac 反序打印出来</h4><h4 id="more-以全屏按页显示文件打"><a href="#more-以全屏按页显示文件打" class="headerlink" title="more 以全屏按页显示文件打"></a>more 以全屏按页显示文件打</h4><ul><li>b, f 上下翻屏</li><li>空格 翻页， 回车，换行， </li><li>ctrl+b, ctrl+f 上一屏，下一屏，</li><li>q 离开</li></ul><h4 id="less-按页显示，一页页加载，对于查看大文件，效率高"><a href="#less-按页显示，一页页加载，对于查看大文件，效率高" class="headerlink" title="less 按页显示，一页页加载，对于查看大文件，效率高"></a>less 按页显示，一页页加载，对于查看大文件，效率高</h4><ul><li>pageUp, pageDown翻页</li></ul><h4 id="head-显示文件前面的内容-默认前-10-行"><a href="#head-显示文件前面的内容-默认前-10-行" class="headerlink" title="head 显示文件前面的内容,默认前 10 行"></a>head 显示文件前面的内容,默认前 10 行</h4><ul><li>默认打印前十行 </li><li>可以和其他命令组合，比如： netstat -tunp | head</li></ul><h4 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h4><ul><li>**tail -f 实时查看文件的更新， 很有用， 比如日志追踪 **</li></ul><h4 id="tail-显示文件最后面的内容-默认最后-10-行"><a href="#tail-显示文件最后面的内容-默认最后-10-行" class="headerlink" title="tail 显示文件最后面的内容,默认最后 10 行"></a>tail 显示文件最后面的内容,默认最后 10 行</h4><ul><li>默认打印最后十行 </li><li>tail -100 a.txt</li><li>** tail -f 实时查看文件的更新， 很有用， 比如日志追踪 **</li></ul><h4 id="gt-重定向，-gt-gt-追加"><a href="#gt-重定向，-gt-gt-追加" class="headerlink" title="&gt; 重定向， &gt;&gt; 追加"></a>&gt; 重定向， &gt;&gt; 追加</h4><ul><li>‘&gt;’ 重定向，会覆盖原有文件 ，不存在则创建 </li><li>‘&gt;&gt;’ 追加， 不会覆盖原有文件 ，</li><li>echo “afsafasf” &gt;&gt; file</li></ul><h4 id="echo-输出内容到控制台"><a href="#echo-输出内容到控制台" class="headerlink" title="echo 输出内容到控制台"></a>echo 输出内容到控制台</h4><ul><li>输出环境变量 </li><li>输出简单文件</li></ul><h4 id="head-显示文件前面的内容-默认前-10-行-1"><a href="#head-显示文件前面的内容-默认前-10-行-1" class="headerlink" title="head 显示文件前面的内容,默认前 10 行"></a>head 显示文件前面的内容,默认前 10 行</h4><ul><li>head -n 5 显示前5行</li></ul><h4 id="paste-两个文件按列合并"><a href="#paste-两个文件按列合并" class="headerlink" title="paste 两个文件按列合并"></a>paste 两个文件按列合并</h4><h3 id="ln-符号链接"><a href="#ln-符号链接" class="headerlink" title="ln 符号链接"></a>ln 符号链接</h3><ul><li>ln -s [source] [dest]</li></ul><h3 id="rmdir-删除空目录"><a href="#rmdir-删除空目录" class="headerlink" title="rmdir 删除空目录"></a>rmdir 删除空目录</h3><h3 id="rm-rf-目录下有文件一起删除"><a href="#rm-rf-目录下有文件一起删除" class="headerlink" title="rm -rf 目录下有文件一起删除"></a>rm -rf 目录下有文件一起删除</h3><h3 id="touch-ab-txt-创建一个空文件"><a href="#touch-ab-txt-创建一个空文件" class="headerlink" title="touch ab.txt 创建一个空文件"></a>touch ab.txt 创建一个空文件</h3><ul><li>可以一次性创建多个空文件， touch a.txt b.txt</li></ul><h3 id="cp-拷贝文件"><a href="#cp-拷贝文件" class="headerlink" title="cp 拷贝文件"></a>cp 拷贝文件</h3><ul><li>cp [option] source dest</li><li>cp -r 递归目录下所有文件 </li><li>**\cp 强制覆盖 **</li></ul><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><ul><li>-r 递归  </li><li>-f 强制</li></ul><h3 id="mv-移动文件或目录，或重命名"><a href="#mv-移动文件或目录，或重命名" class="headerlink" title="mv  移动文件或目录，或重命名"></a>mv  移动文件或目录，或重命名</h3><ul><li>mv source target</li></ul><h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><ul><li>find [搜索范围]  [选项]</li><li>find -name , find &#x2F;home -name hello.txt</li><li>find -user , find &#x2F; -user nobody</li><li>find -size, find &#x2F;home -size +20M, 在home目录下，查找超过 20m 的文件, k小写</li></ul><h4 id="locate-快速定位文件路径-，通过查库，所以快"><a href="#locate-快速定位文件路径-，通过查库，所以快" class="headerlink" title="locate 快速定位文件路径 ，通过查库，所以快"></a>locate 快速定位文件路径 ，通过查库，所以快</h4><ul><li>第一次使用，需要 updatedb 创建locate数据库</li></ul><h4 id="grep-和"><a href="#grep-和" class="headerlink" title="grep 和 |"></a>grep 和 |</h4><ul><li>grep 过滤 </li><li>| 管道符，将前一命令的结果交给下一命令执行 </li><li>grep [option] 查找内容 源文件  -n显示出行号， -i 不管大小写</li><li>cat abc.txt | grep -i yes</li></ul><h3 id="压缩和解压缩"><a href="#压缩和解压缩" class="headerlink" title="压缩和解压缩"></a>压缩和解压缩</h3><h4 id="gzip-gunzip"><a href="#gzip-gunzip" class="headerlink" title="gzip, gunzip"></a>gzip, gunzip</h4><ul><li>gzip 压缩后不会保留原来的文件</li></ul><h4 id="zip-unzip"><a href="#zip-unzip" class="headerlink" title="zip, unzip"></a>zip, unzip</h4><ul><li>zip [option] xxx.zip  [source]， -r  递归目录 , zip -r dog.zip dog&#x2F;</li><li>unzip [option] xx.zip,  -d 指定解压后的存方目录 , unzip -d dog1&#x2F; dog.zip</li></ul><h4 id="tar-打包指令"><a href="#tar-打包指令" class="headerlink" title="tar 打包指令"></a>tar 打包指令</h4><ul><li>x.tar.gz</li><li>c, v, f, z,  x</li><li>tar -zcfv abcd.tar.gz  ab.txt cd.txt 打包 </li><li>tar -zcfv abcd.tar.gz  &#x2F;home</li><li>tar -zxvf abcd.tar.gz 解压到当前目录 </li><li>tar -zxvf abcd.tar.gz -C &#x2F;myhome&#x2F;  指定解压到某一目录，这个目录必须存在</li></ul><h2 id="2-用户管理"><a href="#2-用户管理" class="headerlink" title="2 用户管理"></a>2 用户管理</h2><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><ul><li>Id 加用户名，查看用户信息</li><li>切换用户 su 用户名 </li><li>useradd  username -g 指定组 </li><li>Passwd username</li></ul><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><ul><li>Whoami</li><li>Groupadd groupdel</li></ul><h3 id="修改用户组"><a href="#修改用户组" class="headerlink" title="修改用户组"></a>修改用户组</h3><ul><li>usermod -g</li></ul><h3 id="用户信息相关的文件"><a href="#用户信息相关的文件" class="headerlink" title="用户信息相关的文件"></a>用户信息相关的文件</h3><ul><li>Etc&#x2F;group</li><li>etc&#x2F;shadow</li></ul><h3 id="用户切换及信息查看"><a href="#用户切换及信息查看" class="headerlink" title="用户切换及信息查看"></a>用户切换及信息查看</h3><ul><li>su - zhangsan 切换用户 </li><li>sudo su 切换到root</li><li>cat &#x2F;etc&#x2F;passwd | grep zhangsan 查看当前系统下某用用户信息</li><li>id zhangsan 查看账户信息</li><li>whoami 查看当前用户</li></ul><h3 id="新增用户-useradd"><a href="#新增用户-useradd" class="headerlink" title="新增用户 useradd"></a>新增用户 useradd</h3><ul><li>d 指定用户目录, useradd -d &#x2F;data&#x2F;123 zhangsan,</li><li>g 指定所属主组, </li><li>u 指定uid, 场景：通过uid筛选用户</li></ul><h3 id="删除用户-userdel"><a href="#删除用户-userdel" class="headerlink" title="删除用户 userdel"></a>删除用户 userdel</h3><ul><li>r 删除用户及其家目录, userdel -rf zhangsan</li><li>f 强制删除用户，即使该用户下存在运行中的进程</li><li>logout 退出当前用户</li></ul><h3 id="更改密码-passwd"><a href="#更改密码-passwd" class="headerlink" title="更改密码 passwd"></a>更改密码 passwd</h3><ul><li>&#x2F;etc&#x2F;passwd  查看当前系统下怕有用户</li><li>passwd zhangsan  # 这是在root下修改任一用户密码，root下可能修改任何用户密码 ， 且不需要验证原密码，也没有密码复杂度的要求</li><li>passwd 直接修改当前用户密码</li></ul><h3 id="更改用户信息-usermod"><a href="#更改用户信息-usermod" class="headerlink" title="更改用户信息 usermod"></a>更改用户信息 usermod</h3><ul><li>usermod -g 修改组</li></ul><h3 id="shadow-文件"><a href="#shadow-文件" class="headerlink" title="shadow 文件"></a>shadow 文件</h3><ul><li>cat &#x2F;etc&#x2F;shadow # 只有root有权查看，存放有加密后的密码 </li><li>chage -l zhangsan 查看用户密码修改信息</li></ul><h2 id="3-网络管理"><a href="#3-网络管理" class="headerlink" title="3 网络管理"></a>3 网络管理</h2><h3 id="查看本地ip信息-ifconfig-或-ip-address"><a href="#查看本地ip信息-ifconfig-或-ip-address" class="headerlink" title="查看本地ip信息 ifconfig 或 ip address"></a>查看本地ip信息 ifconfig 或 ip address</h3><h3 id="查看本地路由信息-route-n"><a href="#查看本地路由信息-route-n" class="headerlink" title="查看本地路由信息 route -n"></a>查看本地路由信息 route -n</h3><ul><li>flag: UG才能访问外网</li><li>traceroute <a href="http://www.baidu.com/">www.baidu.com</a> 查看网络访问跳转过程</li></ul><h3 id="cat-x2F-etc-x2F-resolv-conf-查看DNS"><a href="#cat-x2F-etc-x2F-resolv-conf-查看DNS" class="headerlink" title="cat &#x2F;etc&#x2F;resolv.conf 查看DNS"></a>cat &#x2F;etc&#x2F;resolv.conf 查看DNS</h3><h3 id="ethtool-eth1-查看网卡信息"><a href="#ethtool-eth1-查看网卡信息" class="headerlink" title="ethtool eth1 查看网卡信息"></a>ethtool eth1 查看网卡信息</h3><h3 id="网络诊断-ping-traceroute"><a href="#网络诊断-ping-traceroute" class="headerlink" title="网络诊断 ping, traceroute"></a>网络诊断 ping, traceroute</h3><ul><li>ping dest-ip</li><li>traceroute dest-ip</li></ul><h3 id="查看网络连接状态-netstat"><a href="#查看网络连接状态-netstat" class="headerlink" title="查看网络连接状态 netstat"></a>查看网络连接状态 netstat</h3><ul><li>netstat (-tunlp or -tunp)</li></ul><h3 id="查看本机端口占用情况-netstat-ano"><a href="#查看本机端口占用情况-netstat-ano" class="headerlink" title="查看本机端口占用情况 netstat -ano"></a>查看本机端口占用情况 netstat -ano</h3><ul><li>netstat -ano | grep 800</li></ul><h3 id="查看文件被占用的情况-lsof"><a href="#查看文件被占用的情况-lsof" class="headerlink" title="查看文件被占用的情况 lsof"></a>查看文件被占用的情况 lsof</h3><ul><li>lsof -c mysql  查看以关键字开头的进程占用的文件信息 </li><li>lsof -i tcp 列出所有tcp 网络连接信息</li><li>lsof -i :3306 列出谁在使用某个端口</li><li>lsof -a -u test -i 列出某个用户的所有活跃的网络端口</li></ul><h3 id="抓包-tcpdump"><a href="#抓包-tcpdump" class="headerlink" title="抓包 tcpdump"></a>抓包 tcpdump</h3><ul><li>tcpdump -nn -i eth0 dst 61.135.169.121 and port 8080</li></ul><h3 id="linux防火墙-iptables"><a href="#linux防火墙-iptables" class="headerlink" title="linux防火墙 iptables"></a>linux防火墙 iptables</h3><ul><li>iptables -nvl</li></ul><h3 id="dig-查看域名的DNS"><a href="#dig-查看域名的DNS" class="headerlink" title="dig 查看域名的DNS"></a>dig 查看域名的DNS</h3><ul><li>dig baidu.com</li></ul><h3 id="网络问题排查"><a href="#网络问题排查" class="headerlink" title="网络问题排查"></a>网络问题排查</h3><ul><li>系统环境： uname -a, free -m , top 查系统版本，内存、cpu使用情况</li><li>系统log：dmesg; &#x2F;var&#x2F;log&#x2F;messages， 有没有error, failed,bug 日志</li><li>netstate 统计，tcpdump抓包， 是否有丢包，重传</li><li>网卡信息：lspci | grep Eth; ethtool  确定网卡类型</li></ul><h2 id="4-磁盘管理"><a href="#4-磁盘管理" class="headerlink" title="4 磁盘管理"></a>4 磁盘管理</h2><h3 id="查看磁盘分区-lsblk-or-df"><a href="#查看磁盘分区-lsblk-or-df" class="headerlink" title="查看磁盘分区 lsblk or df"></a>查看磁盘分区 lsblk or df</h3><ul><li>lsblk 包括未挂载，未格式化，未分区的磁盘也能显示出来，包括插入的u盘等</li><li>df 只显示所有已经分区的磁盘</li></ul><h3 id="硬盘分区-fdisk"><a href="#硬盘分区-fdisk" class="headerlink" title="硬盘分区 fdisk"></a>硬盘分区 fdisk</h3><ul><li>fdisk dev&#x2F;vdb</li></ul><h3 id="挂载-mount"><a href="#挂载-mount" class="headerlink" title="挂载 mount"></a>挂载 mount</h3><ul><li>mount &#x2F;dev&#x2F;vdc1 &#x2F;mountpointA</li><li>持久化挂载：在&#x2F;etc&#x2F;rc.local 中加入上述命令</li></ul><h3 id="找出哪些文件占空间多-du"><a href="#找出哪些文件占空间多-du" class="headerlink" title="找出哪些文件占空间多 du"></a>找出哪些文件占空间多 du</h3><ul><li>du -xks * | sort -rn | head -20</li><li>du -sh xxxxx 显示某个文件或目录的大小</li></ul><h2 id="5-系统运行情况"><a href="#5-系统运行情况" class="headerlink" title="5 系统运行情况"></a>5 系统运行情况</h2><h3 id="查看Linux内核版本"><a href="#查看Linux内核版本" class="headerlink" title="查看Linux内核版本"></a>查看Linux内核版本</h3><ul><li>cat &#x2F;proc&#x2F;version</li><li>uname -a</li></ul><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><ul><li>lscpu</li><li>&#x2F;proc&#x2F;cpuinfo</li><li>top</li><li>sar -u -P ALL 1 # 查询CPU历史情况</li></ul><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><ul><li>free</li><li>&#x2F;proc&#x2F;meminfo</li><li>sar -r 1 # 监控每一秒的内存情况</li></ul><h3 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h3><ul><li>iostat -xm -1 # 看io繁忙情况</li><li>iotop # 查看哪些进程产生大IO</li><li>du # 查看有哪些目录</li><li>sar -d 1</li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul><li>sar -n DEV 1  # 监控每秒网络流量</li></ul><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><ul><li>cat &#x2F;var&#x2F;log&#x2F;secure # 看看谁登录过这台机器</li><li>w # 看当前被谁登录 </li><li>last # 看所有登录信息, su zhangsan,  cat ~&#x2F;.bash_history  看最近执行的命令</li><li>last rebot &#x2F; uptime # 查看机器启动时间</li><li>ps xf</li><li>ps -eo pid,lstart | grep xxpid# 查看某进程的启动时间 </li><li>lsof | grep xxx # 哪个文件被打开了</li><li>ll &#x2F;proc&#x2F;xxpid 查看进程的启动命令, 目录, 可执行文件位置等</li></ul><h2 id="6-正则表达式与文本处理"><a href="#6-正则表达式与文本处理" class="headerlink" title="6 正则表达式与文本处理"></a>6 正则表达式与文本处理</h2><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h3 id="文本处理-sed-按行处理器"><a href="#文本处理-sed-按行处理器" class="headerlink" title="文本处理 sed (按行处理器)"></a>文本处理 sed (按行处理器)</h3><ul><li>打印指定范围的行 sed -n ‘10, 20 p’ test.txt</li><li>打印包括指定关键字（范围）的行： sed -n ‘&#x2F;2014&#x2F;, &#x2F;2018&#x2F; p’ test.txt</li><li>匹配到关键字的行并做整行替换：sed ‘&#x2F;running&#x2F; c\ ‘stop’’ test.txt</li><li>删除包含指定关键字的行 sed ‘&#x2F;running&#x2F; d’ test.txt </li><li>删除指定范围的行 sed ‘1, 100 d’ test.txt , 注：加上-i参数后才会真正修改这个文件，否则只是在内存中修改</li></ul><h3 id="在文件中查找-grep"><a href="#在文件中查找-grep" class="headerlink" title="在文件中查找 grep"></a>在文件中查找 grep</h3><ul><li>grep keyword test.txt | tail&#x2F;head&#x2F;…</li><li>grep -B&#x2F;A&#x2F;C 10 keyword test.txt  # 查看关键字上&#x2F;下&#x2F;上下 10行的信息</li><li>grep -nr keword <em>xxx.log</em> | wc -l  统计某关键字在某类文件里出现的次数</li></ul><h3 id="拆字段-awk"><a href="#拆字段-awk" class="headerlink" title="拆字段 awk"></a>拆字段 awk</h3><ul><li>cat &#x2F;etc&#x2F;passwd | awk -F: ‘{print $1, $3, $5, $NF}’  按冒号分割每一行，并打印出分割后的第 1,3, 5和最后一列</li><li>cat &#x2F;etc&#x2F;passwd | awk -F: ‘$3&gt;100 {print $1, $3}’ # 加条件，第三列大于100</li><li>$0 所有列</li><li>NF 最后一列索引</li><li>$NF 最后一列值</li></ul><h2 id="7-VIM"><a href="#7-VIM" class="headerlink" title="7 VIM"></a>7 VIM</h2><h3 id="vim-有四个模式"><a href="#vim-有四个模式" class="headerlink" title="vim 有四个模式"></a>vim 有四个模式</h3><ul><li>正常模式 (Normal-mode), 默认模式， 进入按esc, 如果在命令模式下需要按两次</li><li>插入模式 (Insert-mode), 在正常模式中按下个别字母键（后面会详细介绍），会进入插入，比如i</li><li>命令模式 (Command-mode),  在正常模式中，按下：（冒号）键或者&#x2F; （撇号），会进入命令模式。在命令模式中可以执行一些输入并执行一些 VIM 或插件提供的指令，就像在shell里一样。这些指令包括设置环境、文件操作、调用某个功能等等</li><li>可视模式 (Visual-mode),  在正常模式下，进入用v&#x2F;V&#x2F;Ctrl+v， 可视模式中的操作有点像拿鼠标进行操作，选择文本的时候有一种鼠标选择的即视感，有时候会很方便</li></ul><h3 id="vim一次打开多个文件"><a href="#vim一次打开多个文件" class="headerlink" title="vim一次打开多个文件"></a>vim一次打开多个文件</h3><ul><li>vim a.txt b.txt 按下键盘上的冒号 ：这时会在显示屏底部出现冒号 ：（进入了 VIM 的命令模式），然后在输入 ls 屏幕上会出现打开的所有文件的序号和文件名，我们继续输入冒号 ： ，然后输入 bn (这里的 n需要做一个解释并不是键盘上的 n ,而是文件序号的代指，如 b1 代表显示屏上切换到第一个文件，b2 代表显示屏上切换到第二个文件</li><li>vim -On file1 file2 … filen  左右分屏</li><li>vim -on file1 file2 … filen  上下分屏</li></ul><h3 id="vim-退出"><a href="#vim-退出" class="headerlink" title="vim 退出"></a>vim 退出</h3><ul><li>:w 保存当前对文件的修改，但是不退出文件。</li><li>:w! 强制保存但是不退出文件。</li><li>:w file 保存当前的文件修改到 file 文件当中。</li><li>:q! 退出文件，对文件的修改不做保存。</li><li>:qa! 退出所有的文件，对所有的文件修改都不做保存</li><li>:wq 退出文件并保存对文件的修改</li><li>:x 退出文件并保存对文件的修改</li><li>:e 打开另一个文件</li><li>:e! 放弃对文件的所有修改，恢复文件到上次保存的位置。</li><li>:saveas file 另存为 file</li><li>:bn 和 :bp 当打开多个文件的时候可以输入 :bn 和 :bp 进行上一个文件或者下一个文件的切换。</li></ul><h3 id="vim编辑模式"><a href="#vim编辑模式" class="headerlink" title="vim编辑模式"></a>vim编辑模式</h3><ul><li>i是在光标所在的字符之前插入需要录入的文本。</li><li>I 是在光标所在行的行首插入需要录入的文本。</li><li>a 是在光标所在的字符之后插入需要录入的文本。</li><li>A 是在光标所在行的行尾插入需要录入的文本。</li><li>o 是光标所在行的下一行行首插入需要录入的文本。</li><li>O 是光标所在行的上一行行首插入需要录入的文本。</li><li>s 删除光标所在处的字符然后插入需要录入的文本。</li><li>S 删除光标所在行，在当前行的行首开始插入需要录入的文本。</li><li>cw ，删除从光标处开始到该单词结束的所有字符，然后插入需要录入的文本（这个命令是两个字符的合体 cw ）。</li></ul><h3 id="vim命令模式"><a href="#vim命令模式" class="headerlink" title="vim命令模式"></a>vim命令模式</h3><ul><li>:set nu 该命令会显示行号。</li><li>:set nonu 该命令会取消行号。</li><li>:n 定位到 n 行。</li><li>&#x2F;{目标字符串} 查找文本中匹配的目标字符串，查到以后，输入键盘上的 n 会去寻找下一个匹配，N 会去寻找上一个匹配。</li><li>:set ic 编辑器将不会区分大小写,如果你进行该设置之后，进行关键字查询如 &#x2F;zempty 如果文本中有 Zempty ,zEmpty,….,只要是字符相同不会区分大小写都会进行匹配。</li><li>:set noic 区分大小写的查询</li><li>:n1,n2d  删除多行文本，n1 和 n2 指的是起始行号和结束行号，d 是删除关键字</li><li>:s&#x2F;old&#x2F;new&#x2F;g 将会把当前光标所在行的 old 替换成 new</li><li>:%s&#x2F;zempty&#x2F;handsome&#x2F;gi 将会把全文中的 old 替换成 new</li><li>:n1,n2s&#x2F;zempty&#x2F;handsome&#x2F;gIc 这里的 n1 和 n2 值得是行号，将会替换掉 n1 到 n2 的所有old 替换为 new. 注：最后的g代表global即全局替换，如果去掉则只替换掉第一次出现的。i&#x2F;I分别代表大小写不敏感和大小写敏感。c代表是否需要确认 。</li><li>:!command   VIM 执行 Linux 命令, : 后面紧跟着 ! ，! 后面紧跟着 linux 命令（ command 指操作 Linux 系统的一系列命令，如创建文件，新建文件夹，查询文件的属性的等）， 如:!date</li><li>:r !command  VIM 执行命令，并且添加结果至操作文本光标处</li></ul><h3 id="VIM-的正常模式（Normal-model"><a href="#VIM-的正常模式（Normal-model" class="headerlink" title="VIM 的正常模式（Normal-model)"></a>VIM 的正常模式（Normal-model)</h3><ul><li>快速移动光标：请记住这几个快捷键 h,j,k,l 这几个按键主要是用来快速移动光标的，h 是向左移动光标，l 是向右移动光标，j 是向下移动光标，k 是向上移动光标，h , j , k ,l 在主键盘区完全可以取代键盘上的 ↑ ,↓ ,← , → 的功能。</li><li>0 移动到行头</li><li>^ 移动到本行的第一个不是 blank 字符</li><li>$ 移动到行尾</li><li>fa 移动到本行下一个为 a 的字符处，fb 移动到下一个为 b 的字符处</li><li>Fa 同 fa 一样，光标移动方向同 fa 相反</li><li>w 光标移动到下一个单词的开头</li><li>e 光标移动到下一个单词的结尾</li><li>; 和, 当使用 f, F, t ,T, 关键字指定字符跳转的时候，使用 ；可以快速跳转到写一个指定的字符，, 是跳到前一个指定的字符</li><li>nG 光标定位到第 n 行的行首</li><li>gg 光标定位到第一行的行首</li><li>G 光标定位到最后一行的行首</li><li>H 光标定位到当前屏幕的第一行行首</li><li>M ML光标移动到当前屏幕的中间</li><li>L 光标移动到当前屏幕的尾部</li><li>ctrl+f 查看下一页内容</li><li>ctrl+b 查看上一页内容</li></ul><h3 id="VIM-的复制，黏贴-，删除"><a href="#VIM-的复制，黏贴-，删除" class="headerlink" title="VIM 的复制，黏贴 ，删除"></a>VIM 的复制，黏贴 ，删除</h3><p>** d 是删除的意思，通常搭配一个字符 ( 删除范围 ) 实现删除功能，常用的如下：**</p><ul><li>dw 删除一个单词</li><li>dnw 删除 n 个单词，</li><li>dfa 删除光标处到下一个 a 的字符处（ fa 定位光标到 a 处 ）</li><li>dnfa 删除光标处到第 n 个 a 的字符处</li><li>dd 删除一整行</li><li>x 删除一个字符 </li><li>ndd 删除光标处开始的 n 行 – dG一直删除到文件末尾，gg,dG删除整个文件内容</li><li>d$ 删除光标到本行的结尾</li><li>dH 删除屏幕显示的第一行文本到光标所在的行</li><li>dG 删除光标所在行到文本的结束<br>**  y 是复制的意思，通常搭配一个字符（复制范围）实现复制的功能，常用的如下：**</li><li>yw 复制一个单词，还有 ynw</li><li>yfa 复制光标到下一个 a 的字符处,还有ynfa</li><li>yy 复制一行，还有 nyy</li><li>y$ 复制光标到本号的结尾</li><li>yH 复制屏幕显示的第一行文本到光标所在的行</li><li>yG 复制光标所在行到文本的结束<br>** p, P是黏贴的意思，当执行完复制或者黏贴的命令以后，VIM 会把文本寄存起来**</li><li>p 在光标后开始粘贴</li><li>P 大写的 P 光标前开始粘贴</li></ul><h3 id="撤销操作和恢复"><a href="#撤销操作和恢复" class="headerlink" title="撤销操作和恢复"></a>撤销操作和恢复</h3><ul><li>u 撤销刚才的操作</li><li>ctrl + r 恢复撤销操作</li></ul><h3 id="删除字符操作和替换"><a href="#删除字符操作和替换" class="headerlink" title="删除字符操作和替换"></a>删除字符操作和替换</h3><ul><li>x 删除光标当前所在的字符</li><li>r 替换掉光标当前所在的字符</li><li>R 替换掉从光标开始以后的所有字符，除非 <ESC > 退出</li></ul><h3 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h3><ul><li>~ 将光标下的字母改变大小写</li><li>3~ 将光标位置开始的3个字母改变其大小写</li><li>g~~ 改变当前行字母的大小写</li><li>gUU 将当前行的字母改成大写</li><li>guu 将当前行的字母全改成小写</li></ul><h3 id="VIM-的重复命令"><a href="#VIM-的重复命令" class="headerlink" title="VIM 的重复命令"></a>VIM 的重复命令</h3><ul><li>. 该命令是重复上一个操作的命令</li><li>n<command>重复某个命令 n 次，</li><li>如 10p复制 10 次，10dd 删除十次。</li></ul><h3 id="VIM可视化"><a href="#VIM可视化" class="headerlink" title="VIM可视化"></a>VIM可视化</h3><ul><li>v 字符可视化</li><li>V 行可视化 </li><li>Ctrl+v 块状可视化</li></ul><h3 id="可视化模式下操作文本"><a href="#可视化模式下操作文本" class="headerlink" title="可视化模式下操作文本"></a>可视化模式下操作文本</h3><p>可视化模式下选择操作区域以后：</p><ul><li>按下 d会删除选择的区域，</li><li>按下 y 会复制选择的区域，</li><li>按下 p 会黏贴选择的区域</li></ul><h3 id="VIM-的代码提示功能"><a href="#VIM-的代码提示功能" class="headerlink" title="VIM 的代码提示功能"></a>VIM 的代码提示功能</h3><ul><li>在编辑模式下 ，快捷键 Ctrl+n 或者 Ctrl+p 会有代码提示功能，我们可以实现快速录入的效果。</li></ul><h2 id="8-搭配管道使用的工具"><a href="#8-搭配管道使用的工具" class="headerlink" title="8 搭配管道使用的工具"></a>8 搭配管道使用的工具</h2><h3 id="最通俗常用的grep-可搭配正则"><a href="#最通俗常用的grep-可搭配正则" class="headerlink" title="最通俗常用的grep 可搭配正则"></a>最通俗常用的grep 可搭配正则</h3><ul><li>cat test.txt | grep keyword</li></ul><h3 id="wc-统计文本行数"><a href="#wc-统计文本行数" class="headerlink" title="wc 统计文本行数"></a>wc 统计文本行数</h3><ul><li>cat test.txt | wc -l # 查看行数</li><li>wc -l test.txgt</li></ul><h3 id="cut-类似awk的拆分功能"><a href="#cut-类似awk的拆分功能" class="headerlink" title="cut 类似awk的拆分功能"></a>cut 类似awk的拆分功能</h3><h3 id="sort-排序"><a href="#sort-排序" class="headerlink" title="sort 排序"></a>sort 排序</h3><ul><li>netstat -tunp | sort -rn -k3  # 按第三列倒序排</li></ul><h3 id="uniq-去重"><a href="#uniq-去重" class="headerlink" title="uniq 去重"></a>uniq 去重</h3><ul><li>cat test | sort | uniq</li></ul><h3 id="tee-既输入到屏幕又保存到文件"><a href="#tee-既输入到屏幕又保存到文件" class="headerlink" title="tee 既输入到屏幕又保存到文件"></a>tee 既输入到屏幕又保存到文件</h3><ul><li>ls -al &#x2F;home | tee result</li></ul><h3 id="tr-替换"><a href="#tr-替换" class="headerlink" title="tr 替换"></a>tr 替换</h3><ul><li>cat a.log | tr -s ‘c’ ‘C’ # 把小c换成大C</li><li>cat a.log | tr -s ‘\n’ ‘ ‘  # 去掉换行变空格 </li><li>tr -d ‘abc’ a.log # 删除abc</li></ul><h3 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h3><ul><li>cat a.log | xargs  # 竖的变横的</li></ul><h2 id="9-安装包管理"><a href="#9-安装包管理" class="headerlink" title="9 安装包管理"></a>9 安装包管理</h2><h3 id="RPM-redhat-package-manager"><a href="#RPM-redhat-package-manager" class="headerlink" title="RPM redhat package manager"></a>RPM redhat package manager</h3><ul><li>rpm -qa | grep firefox 查询是否安装了某个包 </li><li>rpm -qi python  查询安装的某个饭的信息</li><li>rpm -ql python 查看安装包安装了哪些文件 </li><li>rpm -qf &#x2F;etc&#x2F;passwd 查询某个文件属于哪个安装包</li><li>rpm -e firefox 删除 rpm包，  –nodeps 强制删除</li><li>rpm -i firefox的安装路径， 安装某个安装包 -h 进度条， -v 提示 , rpm -ivh 安装包路径</li></ul><h3 id="Yum-是一个shell-前端包管理器"><a href="#Yum-是一个shell-前端包管理器" class="headerlink" title="Yum 是一个shell 前端包管理器"></a>Yum 是一个shell 前端包管理器</h3><ul><li>基于rpm，能够从指定的服务器自动下载 rpm 安装包 ， 可以自动处理依赖关系 </li><li>一次安装所有依赖的软件包</li></ul><h4 id="Yum-的基本指令"><a href="#Yum-的基本指令" class="headerlink" title="Yum 的基本指令"></a>Yum 的基本指令</h4><ul><li>yum list | grep firefox 查询服务器上是否有需要的安装包 </li><li>yum install firefox 安装某个指定的包 , 默认会安装最新版本</li></ul><h2 id="10-其他运维命令"><a href="#10-其他运维命令" class="headerlink" title="10 其他运维命令"></a>10 其他运维命令</h2><h3 id="显示历史执行过的命令-history"><a href="#显示历史执行过的命令-history" class="headerlink" title="显示历史执行过的命令  history"></a>显示历史执行过的命令  history</h3><ul><li>c 清除历史命令  </li><li>显示最近的 10 个 history 10</li><li>! num,  执行编号为 num的指令</li></ul><h3 id="压缩与解压缩-tar"><a href="#压缩与解压缩-tar" class="headerlink" title="压缩与解压缩 tar"></a>压缩与解压缩 tar</h3><ul><li>压缩： tar czf test.tar.gz &#x2F;data&#x2F;test</li><li>解压：tar xf test.tar.gz</li><li>查看但不解压： tar tvf test.tar.gz</li></ul><h3 id="脚本执行"><a href="#脚本执行" class="headerlink" title="脚本执行"></a>脚本执行</h3><ul><li>用expect 编写自动化脚本以提高效率，典型的场景比如登录,</li><li>用alias 给常用的执行命令加上别名，方便快捷</li><li>Shell提供了一些用于调试脚本的选项：<ul><li>-n，读一遍脚本中的命令但不执行，用于检查脚本中的<strong>语法错误</strong>。bash&#x2F;sh -n xxx.sh  # 检测脚本语法错误 </li><li>-v，一边<strong>执行</strong>脚本，一边将执行过的脚本命令打印到标准错误输出。</li><li>-x，提供跟踪执行信息，将执行的<strong>每一条命令和结果依次打印出来</strong>。</li></ul></li></ul><h3 id="用curl下载ftp文件"><a href="#用curl下载ftp文件" class="headerlink" title="用curl下载ftp文件"></a>用curl下载ftp文件</h3><ul><li>curl <a href="ftp://a.b.c.d/test.zip">ftp://a.b.c.d/test.zip</a> -u name:passwd -O  # -O保留原来的文件名，-o:自定义文件名</li></ul><h3 id="列出本机监控端口及服务-包括正在listen的-netstat-tunlp"><a href="#列出本机监控端口及服务-包括正在listen的-netstat-tunlp" class="headerlink" title="列出本机监控端口及服务, 包括正在listen的, netstat -tunlp"></a>列出本机监控端口及服务, 包括正在listen的, netstat -tunlp</h3><ul><li>netstat -tunlp</li></ul><h3 id="列出本机所有连接，不包括本地监听端口-netstat-tunp"><a href="#列出本机所有连接，不包括本地监听端口-netstat-tunp" class="headerlink" title="列出本机所有连接，不包括本地监听端口 netstat -tunp"></a>列出本机所有连接，不包括本地监听端口 netstat -tunp</h3><ul><li>netstat -tunp</li></ul><h3 id="命令置于后台-nohup-amp"><a href="#命令置于后台-nohup-amp" class="headerlink" title="命令置于后台 nohup &amp;"></a>命令置于后台 nohup &amp;</h3><ul><li>nohup &#x2F;bin&#x2F;bash &#x2F;data&#x2F;test.sh &amp;</li><li>screen</li></ul><h3 id="生成一个指定大小的文件-dd"><a href="#生成一个指定大小的文件-dd" class="headerlink" title="生成一个指定大小的文件 dd"></a>生成一个指定大小的文件 dd</h3><ul><li>dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;data&#x2F;matt&#x2F;2G bs&#x3D;1M count&#x3D;2048  # if指定生成器，of指定文件名</li></ul><h3 id="time-统计命令执行花费的时间"><a href="#time-统计命令执行花费的时间" class="headerlink" title="time 统计命令执行花费的时间"></a>time 统计命令执行花费的时间</h3><ul><li>time netstat -tunp</li></ul><h3 id="获取本机ip"><a href="#获取本机ip" class="headerlink" title="获取本机ip"></a>获取本机ip</h3><ul><li>ifconfig | grep inet[^6] | grep -v 127.0.0.1 | awk ‘{print $2}’ | cut -d’:’ -f2</li></ul><h3 id="移动行光标-特别在敲长命令时-ctrl-a-x2F-e"><a href="#移动行光标-特别在敲长命令时-ctrl-a-x2F-e" class="headerlink" title="移动行光标, 特别在敲长命令时 ctrl a&#x2F;e"></a>移动行光标, 特别在敲长命令时 ctrl a&#x2F;e</h3><ul><li>首：Ctrl+a</li><li>末：Ctrl+e</li></ul><h3 id="历史命令快速查找-Ctrl-r"><a href="#历史命令快速查找-Ctrl-r" class="headerlink" title="历史命令快速查找 Ctrl r"></a>历史命令快速查找 Ctrl r</h3><ul><li>Ctrl + r 输入关键字后开始查找，按ctrl+r继续向前查找，如果找到，按下箭头确认</li></ul><h3 id="！在shell中的应用"><a href="#！在shell中的应用" class="headerlink" title="！在shell中的应用"></a>！在shell中的应用</h3><ul><li>!^ 表示上一个成功执行的命令的第一个参数</li><li>!$ 表示上一个成功执行的命令的最后一个参数</li><li>!* 表示上一个成功执行的命令的所有参数， 用空格隔开 </li><li>eg: mkdir -p a&#x2F;b&#x2F;c&#x2F;d, cd !$</li></ul><h3 id="find的应用"><a href="#find的应用" class="headerlink" title="find的应用"></a>find的应用</h3><ul><li>find &#x2F;data&#x2F;logs&#x2F; -mtime +7 -name ‘<em>.log’ -type f | xargs rm # 删除这目录下 7天之前修改过的</em>.log文件</li><li>find &#x2F;abc -user zhangsan -perm -szie +50G</li><li>find &#x2F;data&#x2F;logs -name abc.log</li><li>find &#x2F; -mtime -7 全盘找最近7天改过的文件</li><li>find &#x2F; -mmin -10 全盘找最近10分钟内改过的文件</li></ul><h3 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h3><h4 id="date-显示当前时间"><a href="#date-显示当前时间" class="headerlink" title="date 显示当前时间"></a>date 显示当前时间</h4><ul><li>date “+%Y %m %d “</li><li>date -s “2019-10-01 21:23:13” 设置日期</li></ul><h4 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h4><ul><li>cal 2020 显示某一年的</li><li>mysql -uroot -p’w14i#t1NPW’ -h100.121.190.3 -P3477 CCDB_239</li></ul><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><ul><li>man ls</li></ul><h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><ul><li>shell 内置命令帮助 </li><li>help cd</li></ul>]]></content>
    
    
    <summary type="html">积累Linux系统管理常用命令</summary>
    
    
    
    <category term="Tech" scheme="http://amazingcoderpro.github.io/categories/Tech/"/>
    
    
    <category term="cs" scheme="http://amazingcoderpro.github.io/tags/cs/"/>
    
    <category term="os" scheme="http://amazingcoderpro.github.io/tags/os/"/>
    
    <category term="linux" scheme="http://amazingcoderpro.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>面试八股之操作系统</title>
    <link href="http://amazingcoderpro.github.io/2023/10/08/Tech/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://amazingcoderpro.github.io/2023/10/08/Tech/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-10-08T07:29:00.000Z</published>
    <updated>2023-10-08T07:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试八股之操作系统"><a href="#面试八股之操作系统" class="headerlink" title="面试八股之操作系统"></a>面试八股之操作系统</h1><h2 id="1-Basic-Concept"><a href="#1-Basic-Concept" class="headerlink" title="1. Basic Concept"></a>1. Basic Concept</h2><h3 id="进程、线程、协程概念性区别"><a href="#进程、线程、协程概念性区别" class="headerlink" title="进程、线程、协程概念性区别"></a>进程、线程、协程概念性区别</h3><ul><li>对于进程、线程，都是&#x3D;&#x3D;由内核进行调度，有CPU时间片的概念，进行抢占式调度（有多种调度算法）&#x3D;&#x3D;。 对于协程(用户级线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全&#x3D;&#x3D;由用户的程序自己调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的CPU控制权切换到其他进程&#x2F;线程，通常只能进行协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到&#x3D;&#x3D;。</li><li>进程是程序执行的一个实例, 担当分担系统资源的实体.进程是分配资源的基本单位，也是我们说的隔离。进程切换只发生在内核态。</li><li>线程作为独立运行和独立调度的基本单元。线程(用户级线程&#x2F;内核级线程)，线程是进程的一个执行流，线程是操作系统能够进行运算调度的最小单位, 对于进程和线程,都是由内核进行调度,有 CPU 时间片的概念, 进行抢占式调度,线程可以在启动前设置栈的大小,启动后,线程的栈大小就固定了, 内核由系统内核进行调度, 系统为了实现并发,会不断地切换线程执行, 由此会带来线程的上下文切换.</li><li>协程(用户态线程)是对内核透明的, 也就是系统完全不知道有协程的存在, 完全由用户自己的程序进行调度，在栈大小分配方便,且每个协程占用的默认占用内存很小,只有 <code>2kb</code> ,而线程需要 <code>8mb</code>,相较于线程,因为协程是对内核透明的,所以栈空间大小可以按需增大减小， 在调度方面, 相较于线程，协程与线程主要区别是它将不再被内核调度，而是交给了程序自己而线程是将自己交给内核调度。python中threading创建的是内核级线程，gevent创建的是用户级线程（即线程）</li></ul><h3 id="进程间通信的方式有哪些，以及各自的优劣？"><a href="#进程间通信的方式有哪些，以及各自的优劣？" class="headerlink" title="进程间通信的方式有哪些，以及各自的优劣？"></a>进程间通信的方式有哪些，以及各自的优劣？</h3><ul><li>最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。<strong>匿名管道</strong>顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「|」竖线就是匿名管道，通信的数据是无格式的流并且大小受限，通信的方式是单向的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来匿名管道是只能用于存在父子关系的进程间通信，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。<strong>命名管道</strong>突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循先进先出原则。</li><li><strong>消息队列</strong>克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟<strong>每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。</strong> 每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程，主要有以下两个原因：1. 安全性：操作系统为了保障系统的安全性，在进程间进行数据传输时，需要对数据进行检查和验证。这个过程需要从用户态切换到内核态，然后再切换回用户态，因此会导致数据拷贝。2. 数据结构不同：内核态和用户态的地址空间是分离的，它们所使用的数据结构也不同。当一个进程想要向消息队列中写入或读取数据时，需要将数据从当前进程的用户态地址空间复制到内核态的地址空间中；而另一个进程想要读取数据时，需要将数据从内核态的地址空间复制到当前进程的用户态地址空间中。这种数据结构不同也会导致数据拷贝。虽然数据拷贝会带来一定的开销，但是由于操作系统需要对数据进行检查和验证，而且内核态和用户态的数据结构不同，因此无法避免每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。消息队列是一种通过消息传递进行进程间通信的机制，它允许多个进程向一个共享的消息队列发送和接收数据。消息队列可以独立于发送和接收进程存在，因此可以轻松实现一对多或多对一的通信模式，而且可以选择不同的消息优先级。缺点是如果发送方频率过快，则接收方可能无法及时处理所有消息，导致消息队列溢出。</li><li><strong>共享内存</strong>可以&#x3D;&#x3D;解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，共享内存是一种高效的进程间通信方式，它可以直接将进程地址空间中的某一块区域映射到另一个进程的地址空间中。由于共享内存不需要进行数据的复制和拷贝，所以它可以提供高效的数据传输速度。&#x3D;&#x3D;但是，由于多个进程访问同一块共享内存区域容易造成数据混乱和死锁问题，因此需要进行同步控制。它直接分配一个共享空间，每个进程都可以直接访问，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有最快的进程间通信方式之名。但是便捷高效的共享内存通信，带来新的问题，多进程竞争同个共享资源会造成数据的错乱。那么，就需要信号量来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。</li><li>&#x3D;&#x3D;信号量是一种进程间同步和互斥机制。通过设置信号量来表示临界资源的使用情况，从而协调多个进程之间的并发访问。它主要用于解决系统中竞争资源的分配问题，如共享内存、文件等。但是，如果信号量的使用不当，可能会导致死锁或者饥饿等问题。&#x3D;&#x3D;信号量不仅可以实现访问的互斥性，还可以实现进程间的同步，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 P 操作和 V 操作。信号量是一种进程间同步和互斥机制，它的主要作用是对临界资源进行保护。为了实现这个目的，信号量提供了两个基本操作：P（wait）和V（signal），它们分别用于对信号量的值进行减一和加一操作。具体来说，P操作和V操作的含义如下：<ul><li>P操作（等待操作）P操作用于申请对共享资源的访问权限。如果当前信号量的值大于0，则可以直接访问共享资源，并将信号量的值减一；否则需要阻塞等待，直到其他进程释放资源并通知该进程可以访问共享资源为止。  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P(semaphore) &#123; </span><br><span class="line"><span class="keyword">while</span> (semaphore &lt;= <span class="number">0</span>) </span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">// 阻塞当前进程 </span></span><br><span class="line">sleep(); </span><br><span class="line">&#125; </span><br><span class="line">semaphore--; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>V操作（释放操作）V操作用于释放共享资源。当一个进程使用完共享资源之后，就需要将信号量的值加一，以便其他进程能够继续使用该资源。  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">V(semaphore) </span><br><span class="line">&#123; semaphore++; </span><br><span class="line"><span class="comment">// 唤醒一个等待该资源的进程 </span></span><br><span class="line">wakeup(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>与信号量名字很相似的叫信号，它俩名字虽然相似，但功能一点儿都不一样。信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号。有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SIGSTOP，这是为了方便我们能在任何时候结束或停止某个进程</li><li>前面说到的通信机制，都是工作于同一台主机，如果要与不同主机的进程间通信，那么就需要 Socket 通信了。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。它具有通用性、可移植性和灵活性, 但是，由于套接字需要进行网络传输，因此会存在数据传输的延迟和不可靠性。</li></ul><h3 id="内核态和用户态区别？内核态的底层操作有什么？为什么要分两个不同的态？"><a href="#内核态和用户态区别？内核态的底层操作有什么？为什么要分两个不同的态？" class="headerlink" title="内核态和用户态区别？内核态的底层操作有什么？为什么要分两个不同的态？"></a>内核态和用户态区别？内核态的底层操作有什么？为什么要分两个不同的态？</h3><p>内核态和用户态是操作系统中的两种运行模式。它们的主要区别在于权限和可执行的操作：<br>内核态（Kernel Mode）：&#x3D;&#x3D;在内核态下，CPU 可以执行所有的指令和访问所有的硬件资源。这种模式下的操作具有更高的权限，主要用于操作系统内核的运行。内核态的底层操作主要包括：内存管理、进程管理、设备驱动程序控制、系统调用等。这些操作涉及到操作系统的核心功能，需要较高的权限来执行。&#x3D;&#x3D;<br>用户态（User Mode）：&#x3D;&#x3D;在用户态下，CPU 只能执行部分指令集，无法直接访问硬件资源。这种模式下的操作权限较低，主要用于运行用户程序。&#x3D;&#x3D;<br>分为内核态和用户态的原因主要有以下几点：</p><ul><li>安全性：通过对权限的划分，用户程序无法直接访问硬件资源，从而避免了恶意程序对系统资源的破坏。</li><li>稳定性：用户态程序出现问题时，不会影响到整个系统，避免了程序故障导致系统崩溃的风险。</li><li>隔离性：内核态和用户态的划分使得操作系统内核与用户程序之间有了明确的边界，有利于系统的模块化和维护。<br>内核态和用户态的划分有助于保证操作系统的安全性、稳定性和易维护性</li></ul><h3 id="IO多路复用-，-理解select和poll、epoll使用，-epoll水平、边缘触发的区别，EAGAIN，accept处理新增链接"><a href="#IO多路复用-，-理解select和poll、epoll使用，-epoll水平、边缘触发的区别，EAGAIN，accept处理新增链接" class="headerlink" title="IO多路复用 ， 理解select和poll、epoll使用， epoll水平、边缘触发的区别，EAGAIN，accept处理新增链接"></a>IO多路复用 ， 理解select和poll、epoll使用， epoll水平、边缘触发的区别，EAGAIN，accept处理新增链接</h3><h3 id="Linux-shell命令、问题排查、管道等"><a href="#Linux-shell命令、问题排查、管道等" class="headerlink" title="Linux shell命令、问题排查、管道等"></a>Linux shell命令、问题排查、管道等</h3><h3 id="一个进程的多个线程之间，那些资源是共享的，哪些是私有的？"><a href="#一个进程的多个线程之间，那些资源是共享的，哪些是私有的？" class="headerlink" title="一个进程的多个线程之间，那些资源是共享的，哪些是私有的？"></a>一个进程的多个线程之间，那些资源是共享的，哪些是私有的？</h3><p>在进程中，线程是执行程序的最小单位。每个线程都有自己的栈空间和寄存器等私有资源，但是它们也可以共享进程的资源。<br>进程中的多个线程可以共享以下资源：</p><ul><li>进程地址空间：所有线程都可以访问进程的全局变量、静态变量、常量、堆区和代码段等资源</li><li>文件描述符：在UNIX系统中，每个进程都有一张打开文件的表格，其中每个打开文件对应一个文件描述符。这些文件描述符是共享的，因此，在不同的线程中打开或关闭文件可能会影响其他线程。</li><li>信号处理函数：进程中的所有线程都共享同样的信号处理函数。</li></ul><p>进程中的多个线程各自拥有以下资源：</p><ul><li>栈空间：每个线程都有自己的栈空间，用于保存局部变量、函数返回地址和参数等数据。</li><li>寄存器：每个线程都有自己的寄存器，用于保存临时变量和计算结果等数据。</li><li>线程ID：每个线程有自己独立的线程ID，用于表示该线程的唯一身份标识符。</li><li>CPU时间：每个线程都有自己的CPU时间，用于记录该线程在CPU上的执行时间。</li></ul><h3 id="多个线程之间，线程同步和通讯的原语主要有哪些？"><a href="#多个线程之间，线程同步和通讯的原语主要有哪些？" class="headerlink" title="多个线程之间，线程同步和通讯的原语主要有哪些？"></a>多个线程之间，线程同步和通讯的原语主要有哪些？</h3><p>线程同步是指多个线程对共享资源进行访问或修改时，需要保证数据的一致性和正确性。为了实现线程同步，可以采用以下几种方式：</p><ul><li>互斥锁。互斥锁是一种基本的线程同步机制，它通过给共享资源加锁来确保在任何时刻只有一个线程能够访问共享资源，从而避免数据竞争和冲突。</li></ul><p>优点：<br>简单易用，容易实现。<br>可以有效地避免数据竞争和冲突。</p><p>缺点：<br>常常会导致死锁问题。<br>在高并发场景下，由于每个线程都需要抢占锁资源，可能会导致性能瓶颈。</p><ul><li>条件变量<br>条件变量是一种高级的线程同步机制，用于在多个线程之间进行通信。它允许线程等待某个条件成立后再继续执行，从而避免了线程忙等的情况。</li></ul><p>优点：<br>可以有效地避免线程忙等的情况。<br>提供了更精细的线程同步控制。</p><p>缺点：<br>实现相对较为复杂。<br>可能会导致死锁问题。</p><ul><li>屏障<br>屏障是一种同步机制，用于控制多个线程在某一点上等待，直到所有线程都到达这一点后才能继续执行。它通常用于实现模拟多进程程序的并行计算，以及一些需要复杂同步的算法。</li></ul><p>优点：<br>提供了更精细的线程同步控制。<br>可以有效地避免数据竞争和冲突。</p><p>缺点：<br>实现相对较为复杂。<br>在高并发场景下，可能会导致性能瓶颈。</p><ul><li>读写锁<br>读写锁是一种特殊的互斥锁，它允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。读写锁可以提高程序的并发性能，适用于读多写少的场景。</li></ul><p>优点：<br>可以提高程序的并发性能。<br>可以有效地避免数据竞争和冲突。</p><p>缺点：<br>实现相对较为复杂。<br>在高写并发场景下，可能会导致性能瓶颈。</p><ul><li>原子操作<br>原子操作是指不可中断的操作，即在执行过程中不能被其他线程打断。在多线程编程中，原子操作可以保证对共享数据的修改是原子的、不可分割的，从而避免了数据竞争和冲突。</li></ul><p>优点：<br>简单易用，容易实现。<br>可以有效地避免数据竞争和冲突。<br>可以提高程序的性能。</p><p>缺点：<br>仅适用于对共享资源进行简单修改的场景。<br>无法提供更精细的线程同步控制。<br>总之，在多线程编程中，线程同步是确保程序正确性的关键所在。不同的线程同步方式各有优缺点，应该根据具体场景选择合适的方式，以获得最佳的性能和可靠性。</p><h3 id="如何优化线程锁带来的效率问题？"><a href="#如何优化线程锁带来的效率问题？" class="headerlink" title="如何优化线程锁带来的效率问题？"></a>如何优化线程锁带来的效率问题？</h3><p>互斥锁是一种基本的线程同步机制，它通过给共享资源加锁来确保在任何时刻只有一个线程能够访问共享资源，从而避免数据竞争和冲突。然而，在高并发场景下，由于每个线程都需要抢占锁资源，可能会导致性能瓶颈。为了优化互斥锁带来的线程同步的性能问题，可以采用以下几种策略：</p><ul><li><p>减小锁粒度<br>如果一个共享资源被多个线程频繁访问，但实际上只有很少的代码段需要对其进行修改，那么可以将锁的粒度减小到这些代码段上，从而降低锁的争用率。例如，可以使用读写锁或者细粒度锁等方式来减小锁粒度。</p></li><li><p>避免长时间持有锁<br>如果一个线程需要在临界区内执行耗时较长的操作，那么最好在操作之前先释放锁资源，待操作完成后再重新获取锁资源。这样可以减少其他线程的等待时间，提高程序的并发性能。</p></li><li><p>线程局部存储<br>对于一些只在单个线程中使用的变量，可以将其存储在该线程的局部存储中，避免使用互斥锁来进行同步。这样可以减少线程之间的竞争，提高程序的执行效率。</p></li><li><p>无锁算法<br>对于一些数据结构和算法，可以使用无锁算法来实现线程间同步。无锁算法通过原子操作和内存屏障等技术来保证数据的一致性和正确性，从而避免了锁带来的性能瓶颈。</p></li><li><p>使用协程或异步编程<br>协程和异步编程是一种基于事件驱动的程序设计模式，在其内部实现中通常不需要使用互斥锁来进行同步。因此，如果能够采用协程或异步编程的方式来重构代码，也可以有效地提高程序的并发性能。</p></li></ul><p>总之，在优化互斥锁带来的线程同步的性能问题时，需要根据具体情况选择合适的策略，以获得最佳的性能和可靠性。同时，需要注意在优化过程中不要引入新的竞争条件和安全漏洞。</p><p>根据不同的场景使用不同的锁-</p><h3 id="无锁算法来实现线程间同步"><a href="#无锁算法来实现线程间同步" class="headerlink" title="无锁算法来实现线程间同步"></a>无锁算法来实现线程间同步</h3><p>无锁算法是一种多线程编程的技术，它通过使用原子操作和内存屏障等底层机制来实现对共享资源的访问和修改，从而避免了使用锁所带来的性能瓶颈。具体来说，无锁算法通常具有以下几个特点：</p><ol><li>原子操作</li></ol><p>无锁算法通常使用原子操作来保证对共享资源的修改是原子的、不可分割的。原子操作是指一组操作在任何情况下都是不可中断的，在执行过程中不能被其他线程打断。例如，C++11标准中提供的std::atomic类型就可以用来实现原子操作。</p><ol start="2"><li>内存屏障</li></ol><p>无锁算法还通常使用内存屏障来保证数据的一致性和正确性。内存屏障是一种CPU指令，可以强制处理器按照程序员指定的顺序执行内存操作，从而确保数据的正确性。例如，在x86架构下，可以使用MFENCE指令来创建内存屏障。</p><ol start="3"><li>自旋</li></ol><p>由于无锁算法不使用锁来进行同步，因此在高并发场景下可能会出现多个线程竞争同一个共享资源的情况。为了解决这个问题，无锁算法通常使用自旋来等待共享资源的可用性。自旋是指线程在访问共享资源时不断地重试，直到资源可用为止。</p><p>总之，无锁算法通过使用原子操作和内存屏障等底层机制来保证对共享资源的访问和修改是安全的、不会出现数据竞争和冲突的。相比于锁机制，无锁算法可以提高程序的并发能力，减少锁带来的性能瓶颈。但是，无锁算法的实现比较复杂，容易引入新的竞争条件和安全漏洞，需要谨慎使用和调试。</p><ul><li>程序崩溃了，如何定位崩溃点？</li><li>程序崩溃时，常见的主要有那些信号？</li><li>内存泄漏如何调试？如何预防？</li><li>SSD和机械硬盘的主要区别是什么？</li><li>SSD的写放大是什么意思？</li></ul><p>不懂Linux的，Linux相关的问题可以不知道。</p><ul><li>进程&amp;线程 ，常用进程通讯方式、线程间资源竞争问题，线程同步问题</li><li>Proactor、reactor模式区别，知道通过多线程线程提高并发<br>\6. 数据库的事务的4个特性是什么？并发事务会带来什么问题？</li></ul><ol><li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li><li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><h3 id="多线程锁是什么"><a href="#多线程锁是什么" class="headerlink" title="多线程锁是什么"></a>多线程锁是什么</h3><p>多线程锁是一种用来保护共享资源的机制。在多线程编程中，如果多个线程同时访问同一个共享资源，可能会发生竞态条件（Race Condition），导致程序的行为出现未定义的情况。为了避免这种情况的发生，可以使用多线程锁来保护共享资源。</p><p>多线程锁的基本思想是，在访问共享资源之前先获取锁，访问完成之后再释放锁。这样可以保证同一时刻只有一个线程可以访问共享资源，从而避免竞态条件的发生。</p><p>常见的多线程锁包括&#x3D;&#x3D;互斥锁、读写锁、条件变量&#x3D;&#x3D;等。其中，互斥锁用于保护共享资源的访问，读写锁用于在读多写少的情况下提高并发性能，条件变量用于线程之间的同步和通信。</p><h3 id="select-x2F-epoll的区别"><a href="#select-x2F-epoll的区别" class="headerlink" title="select&#x2F;epoll的区别"></a>select&#x2F;epoll的区别</h3><p>select 和 poll 的缺陷在于，当客户端越多，也就是 Socket 集合越大，Socket 集合的遍历和拷贝会带来很大的开销，因此也很难应对 C10K。</p><p>epoll 是解决 C10K 问题的利器，通过两个方面解决了 select&#x2F;poll 的问题。</p><ul><li><p>epoll 在内核里使用「红黑树」来关注进程所有待检测的 Socket，红黑树是个高效的数据结构，增删改一般时间复杂度是 O(logn)，通过对这棵黑红树的管理，不需要像 select&#x2F;poll 在每次操作时都传入整个 Socket 集合，减少了内核和用户空间大量的数据拷贝和内存分配。</p></li><li><p>epoll 使用事件驱动的机制，内核里维护了一个「链表」来记录就绪事件，只将有事件发生的 Socket 集合传递给应用程序，不需要像 select&#x2F;poll 那样轮询扫描整个集合（包含有和无事件的 Socket ），大大提高了检测的效率。</p></li></ul><h3 id="IO特别密集时epoll效率还高吗"><a href="#IO特别密集时epoll效率还高吗" class="headerlink" title="IO特别密集时epoll效率还高吗"></a>IO特别密集时epoll效率还高吗</h3><p>答：可以考虑select&#x2F;poll，这种情况轮询也很高效，且结构简单。</p><p><strong>补充：</strong></p><p>可以先解释io特别密集时为什么 epoll 效率不高。原因是：</p><ul><li><p>连接密集（短连接特别多），使用epoll的话，每一次连接需要发生epoll_wait-&gt;accpet-&gt;epoll_ctl调用，而使用select只需要select-&gt;accpet，减少了一次系统调用。</p></li><li><p>读写密集的话，如果收到数据，我们需要响应数据的话，使用epoll的情况下， read 完后也需要epoll_ctl 加入写事件，相比select多了一次系统调用</p></li></ul><h3 id="讲一讲ET、LT模式"><a href="#讲一讲ET、LT模式" class="headerlink" title="讲一讲ET、LT模式"></a>讲一讲ET、LT模式</h3><p>epoll 支持两种事件触发模式，分别是边缘触发（edge-triggered，ET）和水平触发（level-triggered，LT）。</p><p>这两个术语还挺抽象的，其实它们的区别还是很好理解的。</p><ul><li><p>使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，<strong>服务器端只会从 epoll_wait 中苏醒一次</strong>，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；</p></li><li><p>使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，<strong>服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</strong>，目的是告诉我们有数据需要读取；</p></li></ul><p>举个例子，你的快递被放到了一个快递箱里，如果快递箱只会通过短信通知你一次，即使你一直没有去取，它也不会再发送第二条短信提醒你，这个方式就是边缘触发；如果快递箱发现你的快递没有被取出，它就会不停地发短信通知你，直到你取出了快递，它才消停，这个就是水平触发的方式。</p><p>这就是两者的区别，水平触发的意思是只要满足事件的条件，比如内核中有数据需要读，就一直不断地把这个事件传递给用户；而边缘触发的意思是只有第一次满足条件的时候才触发，之后就不会再传递同样的事件了。</p><p>如果使用水平触发模式，当内核通知文件描述符可读写时，接下来还可以继续去检测它的状态，看它是否依然可读或可写。所以在收到通知后，没必要一次执行尽可能多的读写操作。</p><p>如果使用边缘触发模式，I&#x2F;O 事件发生时只会通知一次，而且我们不知道到底能读写多少数据，所以在收到通知后应尽可能地读写数据，以免错失读写的机会。因此，我们会<strong>循环</strong>从文件描述符读写数据，那么如果文件描述符是阻塞的，没有数据可读写时，进程会阻塞在读写函数那里，程序就没办法继续往下执行。所以，<strong>边缘触发模式一般和非阻塞 I&#x2F;O 搭配使用</strong>，程序会一直执行 I&#x2F;O 操作，直到系统调用（如 <code>read</code> 和 <code>write</code>）返回错误，错误类型为 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>。</p><p>一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。</p><h3 id="对于一个后端服务，提升性能可以从以下几个方面入手："><a href="#对于一个后端服务，提升性能可以从以下几个方面入手：" class="headerlink" title="对于一个后端服务，提升性能可以从以下几个方面入手："></a>对于一个后端服务，提升性能可以从以下几个方面入手：</h3><ol><li><p>优化算法和数据结构 在编写程序时，应该选择合适的算法和数据结构，以尽量减少程序的计算和存储时间。例如，在进行大规模数据处理时，应该使用散列表或者树型结构，而不是线性查找等慢速算法。</p></li><li><p>减少I&#x2F;O操作 I&#x2F;O操作通常是一个后端服务中最耗时的部分，因此应该尽量减少I&#x2F;O操作的次数和时间。例如，在读取和写入文件时，可以使用缓冲区来批量读取和写入，从而减少I&#x2F;O操作的次数。</p></li><li><p>使用多线程和异步编程 多线程和异步编程可以将一个任务拆分为多个子任务，并行执行，从而提高程序的处理能力和响应速度。例如，可以将一个数据处理任务拆分为多个线程或者进程，并使用消息队列来协调任务之间的数据传输。</p></li><li><p>应用缓存和内存池 缓存和内存池可以将一些常用的数据和资源预先加载到内存中，并重复利用这些数据和资源，从而减少程序的计算和存储时间。例如，在处理大量图片和视频时，可以使用缓存来缓存已经处理过的数据，避免重复计算。</p></li><li><p>负载均衡和服务治理 负载均衡和服务治理可以将一个后端服务分发到多个服务器上，从而提高程序的处理能力和稳定性。例如，可以使用Nginx等负载均衡软件来将请求分发到多个服务器上，并使用Zookeeper等服务治理软件来监控和管理服务器的状态和资源。</p></li></ol><p>总之，对于一个后端服务，提升性能可以通过优化算法和数据结构、减少I&#x2F;O操作、使用多线程和异步编程、应用缓存和内存池、以及负载均衡和服务治理等手段来实现。在实际编程中，应该根据具体情况选择合适的方法，并进行持续优化和监控，以确保程序的高效和稳定运行。</p><h3 id="Linux内存管理、分配、回收、OOM问题。"><a href="#Linux内存管理、分配、回收、OOM问题。" class="headerlink" title="Linux内存管理、分配、回收、OOM问题。"></a>Linux内存管理、分配、回收、OOM问题。</h3><p><a href="https://mp.weixin.qq.com/s/EsU9FT9D9K5Rt1BM0ySVmw">https://mp.weixin.qq.com/s/EsU9FT9D9K5Rt1BM0ySVmw</a></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZclL17ouOHwX7evMsibhcg7X8nibI74ibTZUe7iaibcVVicczgWar2SnG5o7dVaRye2iaU96CGuibjW22XaUw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZclL17ouOHwX7evMsibhcg7XI3m9BCr0NgPDKQ8YRcfK68pEbVwm6u09dYQcAdJhrKBQLcj1ib7pDbA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>先来说说第一个问题：虚拟内存有什么作用？（如果你还不知道虚拟内存概念，可以看这篇：<a href="http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247485033&idx=1&sn=bf9ba7aca126ad186922c57a96928593&chksm=f98e42c3cef9cbd514df38d04deb5e7a9ea67dbd478da75fc4a7636ee90b1384d65f68eb23f5&scene=21#wechat_redirect">真棒！20 张图揭开内存管理的迷雾，瞬间豁然开朗</a>）</p><ul><li><p>第一，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的。这就解决了多进程之间地址冲突的问题。</p></li><li><p>第二，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。</p></li></ul><p>然后今天主要是聊聊第二个问题，「<strong>系统内存紧张时，会发生什么？</strong>」</p><p>发车！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZclL17ouOHwX7evMsibhcg7X6LTbhp7RzsvB18qzKiaIfY1ygUl4p6gBj4u5BvgpVKGlkZwMAaNAiblg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h4 id="内存分配的过程是怎样的？"><a href="#内存分配的过程是怎样的？" class="headerlink" title="内存分配的过程是怎样的？"></a>内存分配的过程是怎样的？</h4><p>应用程序通过 malloc 函数申请内存的时候，实际上申请的是虚拟内存，此时并不会分配物理内存。</p><p>当应用程序读写了这块虚拟内存，CPU 就会去访问这个虚拟内存， 这时会发现这个虚拟内存没有映射到物理内存， CPU 就会产生<strong>缺页中断</strong>，进程会从用户态切换到内核态，并将缺页中断交给内核的 Page Fault Handler （缺页中断函数）处理。</p><p>缺页中断处理函数会看是否有空闲的物理内存，如果有，就直接分配物理内存，并建立虚拟内存与物理内存之间的映射关系。</p><p>如果没有空闲的物理内存，那么内核就会开始进行<strong>回收内存</strong>的工作，回收的方式主要是两种：直接内存回收和后台内存回收。</p><ul><li><p><strong>后台内存回收</strong>（kswapd）：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程<strong>异步</strong>的，不会阻塞进程的执行。</p></li><li><p><strong>直接内存回收</strong>（direct reclaim）：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是<strong>同步</strong>的，会阻塞进程的执行。</p></li></ul><p>如果直接内存回收后，空闲的物理内存仍然无法满足此次物理内存的申请，那么内核就会放最后的大招了 ——<strong>触发 OOM （Out of Memory）机制</strong>。</p><p>OOM Killer 机制会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，OOM Killer 会继续杀死占用物理内存较高的进程，直到释放足够的内存位置。</p><p>申请物理内存的过程如下图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZclL17ouOHwX7evMsibhcg7XaeyZmRScQRicndIdHic4MCk8ydOmYFnbs9GlADQ4NyR4tlibmXjWaSR4A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h4 id="哪些内存可以被回收？"><a href="#哪些内存可以被回收？" class="headerlink" title="哪些内存可以被回收？"></a>哪些内存可以被回收？</h4><p>系统内存紧张的时候，就会进行回收内测的工作，那具体哪些内存是可以被回收的呢？</p><p>主要有两类内存可以被回收，而且它们的回收方式也不同。</p><ul><li><p><strong>文件页</strong>（File-backed Page）：内核缓存的磁盘数据（Buffer）和内核缓存的文件数据（Cache）都叫作文件页。大部分文件页，都可以直接释放内存，以后有需要时，再从磁盘重新读取就可以了。而那些被应用程序修改过，并且暂时还没写入磁盘的数据（也就是脏页），就得先写入磁盘，然后才能进行内存释放。所以，<strong>回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存</strong>。</p></li><li><p><strong>匿名页</strong>（Anonymous Page）：应用程序通过 mmap 动态分配的堆内存叫作匿名页，这部分内存很可能还要再次被访问，所以不能直接释放内存，它们<strong>回收的方式是通过 Linux 的 Swap 机制</strong>，Swap 会把不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。</p></li></ul><p>文件页和匿名页的回收都是基于 LRU 算法，也就是优先回收不常访问的内存。LRU 回收算法，实际上维护着 active 和 inactive 两个双向链表，其中：</p><ul><li><p><strong>active_list</strong> 活跃内存页链表，这里存放的是最近被访问过（活跃）的内存页；</p></li><li><p><strong>inactive_list</strong> 不活跃内存页链表，这里存放的是很少被访问（非活跃）的内存页；</p></li></ul><p>越接近链表尾部，就表示内存页越不常访问。这样，在回收内存时，系统就可以根据活跃程度，优先回收不活跃的内存。</p><p>活跃和非活跃的内存页，按照类型的不同，又分别分为文件页和匿名页。可以从 &#x2F;proc&#x2F;meminfo 中，查询它们的大小，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># grep表示只保留包含active的指标（忽略大小写）# sort表示按照字母顺序排序[root@xiaolin ~]# cat /proc/meminfo | grep -i active | sortActive:           901456 kBActive(anon):     227252 kBActive(file):     674204 kBInactive:         226232 kBInactive(anon):    41948 kBInactive(file):   184284 kB</span><br></pre></td></tr></table></figure><h4 id="回收内存带来的性能影响"><a href="#回收内存带来的性能影响" class="headerlink" title="回收内存带来的性能影响"></a>回收内存带来的性能影响</h4><p>在前面我们知道了回收内存有两种方式。</p><ul><li><p>一种是后台内存回收，也就是唤醒 kswapd 内核线程，这种方式是异步回收的，不会阻塞进程。</p></li><li><p>一种是直接内存回收，这种方式是同步回收的，会阻塞进程，这样就会造成很长时间的延迟，以及系统的 CPU 利用率会升高，最终引起系统负荷飙高。</p></li></ul><p>可被回收的内存类型有文件页和匿名页：</p><ul><li><p>文件页的回收：对于干净页是直接释放内存，这个操作不会影响性能，而对于脏页会先写回到磁盘再释放内存，这个操作会发生磁盘 I&#x2F;O 的，这个操作是会影响系统性能的。</p></li><li><p>匿名页的回收：如果开启了 Swap 机制，那么 Swap 机制会将不常访问的匿名页换出到磁盘中，下次访问时，再从磁盘换入到内存中，这个操作是会影响系统性能的。</p></li></ul><p>可以看到，回收内存的操作基本都会发生磁盘 I&#x2F;O 的，如果回收内存的操作很频繁，意味着磁盘 I&#x2F;O 次数会很多，这个过程势必会影响系统的性能，整个系统给人的感觉就是很卡。</p><p>下面针对回收内存导致的性能影响，说说常见的解决方式。</p><h4 id="调整文件页和匿名页的回收倾向"><a href="#调整文件页和匿名页的回收倾向" class="headerlink" title="调整文件页和匿名页的回收倾向"></a>调整文件页和匿名页的回收倾向</h4><p>从文件页和匿名页的回收操作来看，文件页的回收操作对系统的影响相比匿名页的回收操作会少一点，因为文件页对于干净页回收是不会发生磁盘 I&#x2F;O 的，而匿名页的 Swap 换入换出这两个操作都会发生磁盘 I&#x2F;O。</p><p>Linux 提供了一个 <code>/proc/sys/vm/swappiness</code> 选项，用来调整文件页和匿名页的回收倾向。</p><p>swappiness 的范围是 0-100，数值越大，越积极使用 Swap，也就是更倾向于回收匿名页；数值越小，越消极使用 Swap，也就是更倾向于回收文件页。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xiaolin ~]# cat /proc/sys/vm/swappiness0</span><br></pre></td></tr></table></figure><p>一般建议 swappiness 设置为 0（默认就是 0），这样在回收内存的时候，会更倾向于文件页的回收，但是并不代表不会回收匿名页。</p><h4 id="尽早触发-kswapd-内核线程异步回收内存"><a href="#尽早触发-kswapd-内核线程异步回收内存" class="headerlink" title="尽早触发 kswapd 内核线程异步回收内存"></a>尽早触发 kswapd 内核线程异步回收内存</h4><blockquote><p>如何查看系统的直接内存回收和后台内存回收的指标？</p></blockquote><p>我们可以使用 <code>sar -B 1</code> 命令来观察：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZclL17ouOHwX7evMsibhcg7X4utryibbxdBnrH3Hiaam2vo54bIkjWb0bibJvxpibKAkEm5CBvPh3rY2CA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>图中红色框住的就是后台内存回收和直接内存回收的指标，它们分别表示：</p><ul><li><p>pgscank&#x2F;s : kswapd(后台回收线程) 每秒扫描的 page 个数。</p></li><li><p>pgscand&#x2F;s: 应用程序在内存申请过程中每秒直接扫描的 page 个数。</p></li><li><p>pgsteal&#x2F;s: 扫描的 page 中每秒被回收的个数（pgscank+pgscand）。</p></li></ul><p>如果系统时不时发生抖动，并且在抖动的时间段里如果通过 sar -B 观察到 pgscand 数值很大，那大概率是因为「直接内存回收」导致的。</p><p>针对这个问题，解决的办法就是，可以通过尽早的触发「后台内存回收」来避免应用程序进行直接内存回收。</p><blockquote><p>什么条件下才能触发 kswapd 内核线程回收内存呢？</p></blockquote><p>内核定义了三个内存阈值（watermark，也称为水位），用来衡量当前剩余内存（pages_free）是否充裕或者紧张，分别是：</p><ul><li><p>页最小阈值（pages_min）；</p></li><li><p>页低阈值（pages_low）；</p></li><li><p>页高阈值（pages_high）；</p></li></ul><p>这三个内存阈值会划分为四种内存使用情况，如下图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZclL17ouOHwX7evMsibhcg7XxO0jqBuqNFXBee73YburLnYpRyNQdNN11R88N9HBwklZzEHb52C8fQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>kswapd 会定期扫描内存的使用情况，根据剩余内存（pages_free）的情况来进行内存回收的工作。</p><ul><li><p>图中绿色部分：如果剩余内存（pages_free）大于 页高阈值（pages_high），说明剩余内存是充足的；</p></li><li><p>图中蓝色部分：如果剩余内存（pages_free）在页高阈值（pages_high）和页低阈值（pages_low）之间，说明内存有一定压力，但还可以满足应用程序申请内存的请求；</p></li><li><p>图中橙色部分：如果剩余内存（pages_free）在页低阈值（pages_low）和页最小阈值（pages_min）之间，说明内存压力比较大，剩余内存不多了。<strong>这时 kswapd0 会执行内存回收，直到剩余内存大于高阈值（pages_high）为止</strong>。虽然会触发内存回收，但是不会阻塞应用程序，因为两者关系是异步的。</p></li><li><p>图中红色部分：如果剩余内存（pages_free）小于页最小阈值（pages_min），说明用户可用内存都耗尽了，此时就会<strong>触发直接内存回收</strong>，这时应用程序就会被阻塞，因为两者关系是同步的。</p></li></ul><p>可以看到，当剩余内存页（pages_free）小于页低阈值（pages_low），就会触发 kswapd 进行后台回收，然后 kswapd 会一直回收到剩余内存页（pages_free）大于页高阈值（pages_high）。</p><p>也就是说 kswapd 的活动空间只有 pages_low 与 pages_min 之间的这段区域，如果剩余内测低于了 pages_min 会触发直接内存回收，高于了 pages_high 又不会唤醒 kswapd。</p><p>页低阈值（pages_low）可以通过内核选项  <code>/proc/sys/vm/min_free_kbytes</code> （该参数代表系统所保留空闲内存的最低限）来间接设置。</p><p>min_free_kbytes 虽然设置的是页最小阈值（pages_min），但是页高阈值（pages_high）和页低阈值（pages_low）都是根据页最小阈值（pages_min）计算生成的，它们之间的计算关系如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pages_min = min_free_kbytespages_low = pages_min*5/4pages_high = pages_min*3/2</span><br></pre></td></tr></table></figure><p>如果系统时不时发生抖动，并且通过 sar -B 观察到 pgscand 数值很大，那大概率是因为直接内存回收导致的，这时可以增大 min_free_kbytes 这个配置选项来及早地触发后台回收，然后继续观察 pgscand 是否会降为 0。</p><p>增大了 min_free_kbytes 配置后，这会使得系统预留过多的空闲内存，从而在一定程度上降低了应用程序可使用的内存量，这在一定程度上浪费了内存。极端情况下设置 min_free_kbytes 接近实际物理内存大小时，留给应用程序的内存就会太少而可能会频繁地导致 OOM 的发生。</p><p>所以在调整 min_free_kbytes 之前，需要先思考一下，应用程序更加关注什么，如果关注延迟那就适当地增大 min_free_kbytes，如果关注内存的使用量那就适当地调小 min_free_kbytes。</p><h4 id="NUMA-架构下的内存回收策略"><a href="#NUMA-架构下的内存回收策略" class="headerlink" title="NUMA 架构下的内存回收策略"></a>NUMA 架构下的内存回收策略</h4><blockquote><p>什么是 NUMA 架构？</p></blockquote><p>再说 NUMA 架构前，先给大家说说 SMP 架构，这两个架构都是针对 CPU 的。</p><p>SMP 指的是一种<strong>多个 CPU 处理器共享资源的电脑硬件架构</strong>，也就是说每个 CPU 地位平等，它们共享相同的物理资源，包括总线、内存、IO、操作系统等。每个 CPU 访问内存所用时间都是相同的，因此，这种系统也被称为一致存储访问结构（UMA，Uniform Memory Access）。</p><p>随着 CPU 处理器核数的增多，多个 CPU 都通过一个总线访问内存，这样总线的带宽压力会越来越大，同时每个 CPU 可用带宽会减少，这也就是 SMP 架构的问题。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZclL17ouOHwX7evMsibhcg7XoXqqABKmRJL0bUH2lR2Q64cDaleENibkh8b4JYgHpdN6yibcPeDW5vOw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>SMP 与 NUMA 架构</p><p>为了解决 SMP 架构的问题，就研制出了 NUMA 结构，即非一致存储访问结构（Non-uniform memory access，NUMA）。</p><p>NUMA 架构将每个 CPU  进行了分组，每一组 CPU 用 Node 来表示，一个 Node 可能包含多个 CPU 。</p><p><strong>每个 Node 有自己独立的资源，包括内存、IO 等</strong>，每个 Node 之间可以通过互联模块总线（QPI）进行通信，所以，也就意味着每个 Node 上的 CPU 都可以访问到整个系统中的所有内存。但是，访问远端 Node 的内存比访问本地内存要耗时很多。</p><blockquote><p>NUMA 架构跟回收内存有什么关系？</p></blockquote><p>在 NUMA 架构下，当某个 Node 内存不足时，系统可以从其他 Node 寻找空闲内存，也可以从本地内存中回收内存。</p><p>具体选哪种模式，可以通过 &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;zone_reclaim_mode 来控制。它支持以下几个选项：</p><ul><li><p>0 （默认值）：在回收本地内存之前，在其他 Node 寻找空闲内存；</p></li><li><p>1：只回收本地内存；</p></li><li><p>2：只回收本地内存，在本地回收内存时，可以将文件页中的脏页写回硬盘，以回收内存。</p></li><li><p>4：只回收本地内存，在本地回收内存时，可以用 swap 方式回收内存。</p></li></ul><p>在使用 NUMA 架构的服务器，如果系统出现还有一半内存的时候，却发现系统频繁触发「直接内存回收」，导致了影响了系统性能，那么大概率是因为 zone_reclaim_mode 没有设置为 0 ，导致当本地内存不足的时候，只选择回收本地内存的方式，而不去使用其他 Node 的空闲内存。</p><p>虽然说访问远端 Node 的内存比访问本地内存要耗时很多，但是相比内存回收的危害而言，访问远端 Node 的内存带来的性能影响还是比较小的。因此，zone_reclaim_mode 一般建议设置为 0。</p><h4 id="如何保护一个进程不被-OOM-杀掉呢？"><a href="#如何保护一个进程不被-OOM-杀掉呢？" class="headerlink" title="如何保护一个进程不被 OOM 杀掉呢？"></a>如何保护一个进程不被 OOM 杀掉呢？</h4><p>在系统空闲内存不足的情况，进程申请了一个很大的内存，如果直接内存回收都无法回收出足够大的空闲内存，那么就会触发 OOM 机制，内核就会根据算法选择一个进程杀掉。</p><p>Linux 到底是根据什么标准来选择被杀的进程呢？这就要提到一个在 Linux 内核里有一个 <code>oom_badness()</code> 函数，它会把系统中可以被杀掉的进程扫描一遍，并对每个进程打分，得分最高的进程就会被首先杀掉。</p><p>进程得分的结果受下面这两个方面影响：</p><ul><li><p>第一，进程已经使用的物理内存页面数。</p></li><li><p>第二，每个进程的 OOM 校准值 oom_score_adj。它是可以通过 <code>/proc/[pid]/oom_score_adj</code> 来配置的。我们可以在设置 -1000 到 1000 之间的任意一个数值，调整进程被 OOM Kill 的几率。</p></li></ul><p>函数 oom_badness() 里的最终计算方法是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// points 代表打分的结果// process_pages 代表进程已经使用的物理内存页面数// oom_score_adj 代表 OOM 校准值// totalpages 代表系统总的可用页面数points = process_pages + oom_score_adj*totalpages/1000</span><br></pre></td></tr></table></figure><p><strong>用「系统总的可用页面数」乘以 「OOM 校准值 oom_score_adj」再除以 1000，最后再加上进程已经使用的物理页面数，计算出来的值越大，那么这个进程被 OOM Kill 的几率也就越大</strong>。</p><p>每个进程的 oom_score_adj 默认值都为 0，所以最终得分跟进程自身消耗的内存有关，消耗的内存越大越容易被杀掉。我们可以通过调整 oom_score_adj 的数值，来改成进程的得分结果：</p><ul><li><p>如果你不想某个进程被首先杀掉，那你可以调整该进程的 oom_score_adj，从而改变这个进程的得分结果，降低该进程被 OOM 杀死的概率。</p></li><li><p>如果你想某个进程无论如何都不能被杀掉，那你可以将 oom_score_adj 配置为 -1000。</p></li></ul><p>我们最好将一些很重要的系统服务的 oom_score_adj 配置为 -1000，比如 sshd，因为这些系统服务一旦被杀掉，我们就很难再登陆进系统了。</p><p>但是，不建议将我们自己的业务程序的 oom_score_adj 设置为 -1000，因为业务程序一旦发生了内存泄漏，而它又不能被杀掉，这就会导致随着它的内存开销变大，OOM killer 不停地被唤醒，从而把其他进程一个个给杀掉。</p><p>参考资料：</p><ul><li><p><a href="https://time.geekbang.org/column/article/277358">https://time.geekbang.org/column/article/277358</a></p></li><li><p><a href="https://time.geekbang.org/column/article/75797">https://time.geekbang.org/column/article/75797</a></p></li><li><p><a href="https://www.jianshu.com/p/e40e8813842f">https://www.jianshu.com/p/e40e8813842f</a></p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>内核在给应用程序分配物理内存的时候，如果空闲物理内存不够，那么就会进行内存回收的工作，主要有两种方式：</p><ul><li><p>后台内存回收：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程异步的，不会阻塞进程的执行。</p></li><li><p>直接内存回收：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是同步的，会阻塞进程的执行。</p></li></ul><p>可被回收的内存类型有文件页和匿名页：</p><ul><li><p>文件页的回收：对于干净页是直接释放内存，这个操作不会影响性能，而对于脏页会先写回到磁盘再释放内存，这个操作会发生磁盘 I&#x2F;O 的，这个操作是会影响系统性能的。</p></li><li><p>匿名页的回收：如果开启了 Swap 机制，那么 Swap 机制会将不常访问的匿名页换出到磁盘中，下次访问时，再从磁盘换入到内存中，这个操作是会影响系统性能的。</p></li></ul><p>文件页和匿名页的回收都是基于 LRU 算法，也就是优先回收不常访问的内存。回收内存的操作基本都会发生磁盘 I&#x2F;O 的，如果回收内存的操作很频繁，意味着磁盘 I&#x2F;O 次数会很多，这个过程势必会影响系统的性能。</p><p>针对回收内存导致的性能影响，常见的解决方式。</p><ul><li><p>设置 &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;swappiness，调整文件页和匿名页的回收倾向，尽量倾向于回收文件页；</p></li><li><p>设置 &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;min_free_kbytes，调整 kswapd 内核线程异步回收内存的时机；</p></li><li><p>设置  &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;zone_reclaim_mode，调整 NUMA 架构下内存回收策略，建议设置为 0，这样在回收本地内存之前，会在其他 Node 寻找空闲内存，从而避免在系统还有很多空闲内存的情况下，因本地 Node 的本地内存不足，发生频繁直接内存回收导致性能下降的问题；</p></li></ul><p>在经历完直接内存回收后，空闲的物理内存大小依然不够，那么就会触发 OOM 机制，OOM killer 就会根据每个进程的内存占用情况和 oom_score_adj 的值进行打分，得分最高的进程就会被首先杀掉。</p><p>我们可以通过调整进程的 &#x2F;proc&#x2F;[pid]&#x2F;oom_score_adj 值，来降低被 OOM killer 杀掉的概率。<br>面试问题</p><p>1）TCP&#x2F;IP协议<br>    1）三次握手&#x2F;四次挥手过程<br>    2）TIME_WAIT状态<br>        1）主动关闭&#x2F;被动关闭<br>        2）需要的原因<br>        3）缓解措施<br>        4）有没有方式不出现TIME_WAIT状态<br>    3）RST出现的场景<br>    4）滑动窗口<br>2）网络编程<br>    1）EPOLL&#x2F;SELECT的区别<br>    2）边沿触发&#x2F;水平触发<br>    3）事件触发的场景<br>        1）读事件 有哪些场景<br>        2）写事件 有哪些场景<br>    4）READ调用返回值场景<br>        1）0<br>        2）-1<br>        3）&gt;0<br>    5）UDP客户端可以CONNECT不，那CONNECT和不CONNECT有啥区别<br>3）后台编程<br>    1）FORK的用途，FORK区分父子进程方式<br>    2）进程间通信方式<br>    3）僵尸进程<br>    4）内存模型，有哪些段构成<br>    5）进程&#x2F;线程&#x2F;协程的区别<br>4）常见中间件<br>    1）MYSQL<br>        1）为啥不建议SELECT *<br>        2）覆盖索引<br>        3）分页优化<br>    2）ZOOKEEPER<br>        1）有哪些WATCH以及对应唤醒事件<br>    3）KAFKA<br>        1）分区分服<br>        2）生产者<br>        3）消费者<br>5）语言<br>    1）JAVA语言<br>        1）内存管理<br>6）设计模式<br>    1）单例模式<br>7）项目中的难点、挑战点</p><p>22989-腾讯云网络后台开发工程师(CSIG全资子公司)（西安）</p><p>建议用online ddl（网上可以查）修改，就是逗号后面的参数<br>另外，添加字段要加上after，根据表结构看看fromWanIp适合在哪个字段后<br>ALTER TABLE cEip ALTER COLUMN ispId SET DEFAULT -1, ALGORITHM&#x3D;INPLACE, LOCK&#x3D;NONE;</p><h3 id="FORK的用途，FORK区分父子进程方式"><a href="#FORK的用途，FORK区分父子进程方式" class="headerlink" title="FORK的用途，FORK区分父子进程方式"></a>FORK的用途，FORK区分父子进程方式</h3><p><code>fork()</code>是Unix&#x2F;Linux操作系统中一个重要的系统调用，它的主要作用是创建一个新的进程。下面是<code>fork()</code>函数的一些具体用途：</p><ol><li><p>多进程并发 使用<code>fork()</code>函数可以创建一个与当前进程完全相同的子进程，并且这个子进程所拥有的数据、资源和代码段等都复制自父进程。这样，在不同进程之间就可以实现并发执行，提高程序的执行效率。</p></li><li><p>资源隔离和保护 在多进程并发的情况下，需要考虑如何进行资源隔离和保护。通过使用<code>fork()</code>函数创建多个进程，可以将不同的任务分配到不同的进程中运行，并且使用信号量、共享内存等机制来进行进程间的通信和同步，从而实现资源的隔离和保护。</p></li><li><p>守护进程 守护进程（daemon）是一种在后台运行的进程，独立于控制终端并且没有用户交互界面。在Unix&#x2F;Linux操作系统中，守护进程通常是由<code>fork()</code>函数创建的子进程，并且使用<code>setsid()</code>函数将子进程转换为守护进程。</p></li></ol><p>区分父子进程的方式包括以下两种：</p><ol><li><p><code>fork()</code>函数的返回值 在父进程中，<code>fork()</code>函数返回子进程的PID（进程ID），在子进程中则返回0。通过判断<code>fork()</code>函数的返回值，可以区分父子进程。</p></li><li><p>进程ID（PID） 每个进程都有一个唯一的PID，可以通过系统调用<code>getpid()</code>来获取当前进程的PID，也可以通过<code>fork()</code>函数返回的PID来获取子进程的PID。在父进程和子进程中，它们分别具有不同的PID，从而可以区分父子进程。</p></li></ol><p>总之，<code>fork()</code>函数是Unix&#x2F;Linux操作系统中一个重要的系统调用，它可以创建一个新的进程，并且复制父进程的数据、资源和代码段等。通过使用<code>fork()</code>函数，可以实现多进程并发、资源隔离和保护、守护进程等功能。同时，它还可以通过进程ID和返回值来区分父子进程。</p>]]></content>
    
    
    <summary type="html">积累操作系统相关面试问题及解答。包括进程、线程、内存管理、性能优化等</summary>
    
    
    
    <category term="Tech" scheme="http://amazingcoderpro.github.io/categories/Tech/"/>
    
    
    <category term="cs" scheme="http://amazingcoderpro.github.io/tags/cs/"/>
    
    <category term="os" scheme="http://amazingcoderpro.github.io/tags/os/"/>
    
    <category term="linux" scheme="http://amazingcoderpro.github.io/tags/linux/"/>
    
    <category term="interview" scheme="http://amazingcoderpro.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>面试八股之编码</title>
    <link href="http://amazingcoderpro.github.io/2023/10/08/Tech/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E4%B9%8B%E7%BC%96%E7%A0%81/"/>
    <id>http://amazingcoderpro.github.io/2023/10/08/Tech/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E4%B9%8B%E7%BC%96%E7%A0%81/</id>
    <published>2023-10-08T07:29:00.000Z</published>
    <updated>2023-10-08T07:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试八股之编码"><a href="#面试八股之编码" class="headerlink" title="面试八股之编码"></a>面试八股之编码</h1><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><ul><li><p>1.全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？<br>  <code>  可以，在不同的C文件中以static形式来声明同名全局变量。可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错.  </code></p></li><li><p>2.static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？Static函数与普通函数有什么区别？<br>  <code>  (1)把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。    全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。(2)把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。(3)static函数与普通函数作用域不同,仅在本文件。    综上所述:     static全局变量与普通的全局变量有什么区别：    static全局变量只初使化一次，防止在其他文件单元中被引用;    static局部变量和普通局部变量有什么区别：    static局部变量只被初始化一次，下一次依据上一次结果值；    static函数与普通函数有什么区别：    static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝  </code></p></li><li><p>3.以下代码存在的问题？<br>  <code>  char string[] = “Linux C”;   char *p = “Linux C”;   string[0] = &#39;a&#39;;   p[0] = &#39;a&#39;;   注：”Linux C”是一个字符串常量。C语言对于字符串常量通常是这样处理的：在内存中开辟一个字符数组来存储该字符串常量，并把开辟出的字符数组的首地址赋给p.   注：string[0] = ‘a’是可以的，而p[0] = ‘a’是非法的，因为p指向的是字符串常量，常量的内容不可改变。把p指向一个字符串常量或字符数组时合法的，例如：p = “Hello World!”; p= string;</code></p></li><li><ol start="4"><li>写一个实现字符串拷贝的函数。给定字符串拷贝函数strcpy的原型：<br>char *strcpy(char *dest,const char *src); 要求：（1）不调用任何库函数。（2）说明函数为什么返回char *.<br>  <code>  char *strcpy(char *dest,char *src) &#123;   if( (dest == NULL) || (src == NULL) )   &#123;   return NULL;   &#125;   char *ret_string = dest;   while( *dest ++ = *src++)!=’\0′);   return ret_string;   &#125;  </code></li></ol></li></ul><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><ul><li>可变类型与不可变类型，如何判断一个变量是可变还是不可变</li><li>逻辑表达式中，哪些值是假？（0，空串，空容器，False，None）</li><li>列表和元组有什么不同？</li><li>range和xrange有什么区别？</li><li>for循环如何同时遍历索引和值</li><li>什么是静态方法，如何定义</li><li>静态方法和类方法的区别是什么？</li><li>list如何去重？</li><li>如何判断字符串是否含有某个字串（in比str.find好）为什么？</li><li>is None和&#x3D;&#x3D; None有什么区别？</li><li>什么是GIL</li><li>type isinstance区别</li><li>字符串拼接用 join和+的区别</li><li>python实现单例</li><li></li></ul><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h2 id="上机编程"><a href="#上机编程" class="headerlink" title="上机编程"></a>上机编程</h2><p>编程题本身不考察算法掌握程度，但是考察基本的逻辑思维，把算法转换为代码的能力，以及基本的错误处理。现场面试用纸笔，白板，电脑都可以，远程面试可以用在线代码平台，比如<a href="http://collabedit.com/">collabedit</a>，<a href="https://codeshare.io/">codeshare.io</a>，<a href="https://codeinterview.io/">codeinterview.io</a><br>复杂的算法不太容易验证，二十行内能解决的不太复杂的算法题为宜，速度越快越好，代码不能有明显的语法错误和低级错误，例如：</p><h3 id="1-纯算法"><a href="#1-纯算法" class="headerlink" title="1. 纯算法"></a>1. 纯算法</h3><ul><li>链表逆序</li><li>二叉树求宽度&#x2F;深度</li><li>字符串处理：Split, Trim，逆序</li><li>编码：UTF8编解码，Varint编解码，十六进制编解码</li><li>数组去重，保持顺序 [1, 2, 3, 1, 2] -&gt; [1, 2, 3]</li><li>数组去重，保持顺序，后面的出现后，前面的去掉，[1, 2, 3, 2, 1] -&gt; [3, 2, 1]</li><li>位图中查找第一个设置&#x2F;未设置的位的偏移量</li></ul><h3 id="2-接口设计"><a href="#2-接口设计" class="headerlink" title="2. 接口设计"></a>2. 接口设计</h3><ul><li>比如String类的接口设计（构造函数，拷贝，赋值，拼接等），用数组实现循环队列</li><li>可以考察一些函数的实现，比如String类+&#x3D;的实现，主要关注正确性和内存泄漏和越界</li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h2 id="人员本身"><a href="#人员本身" class="headerlink" title="人员本身"></a>人员本身</h2><ul><li>自我介绍</li><li>项目亮点难点</li><li>项目的领域模型可以画一下吗？</li></ul><h2 id="JD-example"><a href="#JD-example" class="headerlink" title="JD example"></a>JD example</h2><p>腾讯云后端开发工程师（西安）</p><p>职责：<br>负责腾讯云网络产品的研发与设计工作，打造更稳定、安全、高效和可靠的专业后台支撑体系， 保障海量网络业务的稳定运行。</p><p>必须具备的：<br>1、本科及以上学历，计算机相关专业，三年以上后台开发工作经验；<br>2、熟悉Linux操作系统下C++、python(或php)开发，能运用常见工具定位和调试问题代码；<br>3、熟悉http、tcp&#x2F;ip协议， 进程间通讯编程，多线程编程等，熟悉Linux常见网络服务器模型；<br>4、具有扎实的软件开发基础知识，包括算法、操作系统、软件工程、设计模式、数据结构、数据库系统、网络安全等；<br>5、具有良好的团队合作、沟通与口头、书面表达能力， 严谨的工作态度与高质量意识；<br>6、对新技术敏感，求知欲强，能快速学习并具备较强的技术领悟能力。</p><p>有一定了解的：<br>1、Shell 、 Perl 等脚本语言；<br>2、MySQL及 SQL 语言、编程；<br>3、Docker、K8s、Nginx等常用技术组件；<br>4、常见的网络协议，包括但不限于arp、ip、vpn、gre等。</p><p>可以加分的：<br>1、具备分布式系统设计与开发、负载均衡技术、系统容灾设计、高可用系统等知识；<br>2、通过腾讯云从业资格证认证或同等资格认证。</p><p>注：此岗位为腾讯集团旗下全资子公司编制岗位  base 西安 雁塔区</p><p><em>*<em>*10、什么函数不能声明为虚函数？*</em>**<br>*</em>*<em>**答：**constructor*</em>**</p><p><em>*<em>*12、不能做switch()的参数类型*</em>**<br>*</em>*<em>**答** **：**switch的参数不能为实型。*</em>**</p><p><em>*<em>*14、如何引用一个已经定义过的全局变量？*</em>**<br>*</em>*<em>**答** **、可以用引用头文件的方式，也可以用**extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变量，假定你将那个变量写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。*</em>**</p><p>虚函数： 实现类的多态性</p><p>关键字：虚函数；虚函数的作用；多态性；多态公有继承；动态联编</p><p>C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数；在派生类中对基类定义的虚函数进行重写时，需要再派生类中声明该方法为虚方法。</p><p>当子类重新定义了父类的虚函数后，当父类的指针指向子类对象的地址时，[即B b; A a &#x3D; &amp;b;] 父类指针根据赋给它的不同子类指针，动态的调用子类的该函数，而不是父类的函数（如果不使用virtual方法，请看后面★*），且这样的函数调用发生在运行阶段，而不是发生在编译阶段，称为动态联编。而函数的重载可以认为是多态，只不过是静态的。注意，非虚函数静态联编，效率要比虚函数高，但是不具备动态联编能力。</p><p>★如果使用了virtual关键字，程序将根据引用或指针指向的 对 象 类 型 来选择方法，否则使用引用类型或指针类型来选择方法。</p><p>下面的例子解释动态联编性：</p><p>————————————————<br>版权声明：本文为CSDN博主「BigoSprite」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/iFuMI/article/details/51088091">https://blog.csdn.net/iFuMI/article/details/51088091</a></p><p>实现原理：虚函数表+虚表指针</p><p>关键字：虚函数底层实现机制；虚函数表；虚表指针</p><p>编译器处理虚函数的方法是：为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，称为虚表指针（vptr），这种数组成为虚函数表（virtual function table, vtbl），即，每个类使用一个虚函数表，每个类对象用一个虚表指针。</p><p>举个例子：基类对象包含一个虚表指针，指向基类中所有虚函数的地址表。派生类对象也将包含一个虚表指针，指向派生类虚函数表。看下面两种情况：</p><p>如果派生类重写了基类的虚方法，该派生类虚函数表将保存重写的虚函数的地址，而不是基类的虚函数地址。</p><p>如果基类中的虚方法没有在派生类中重写，那么派生类将继承基类中的虚方法，而且派生类中虚函数表将保存基类中未被重写的虚函数的地址。注意，如果派生类中定义了新的虚方法，则该虚函数的地址也将被添加到派生类虚函数表中。<br>————————————————<br>版权声明：本文为CSDN博主「BigoSprite」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/iFuMI/article/details/51088091">https://blog.csdn.net/iFuMI/article/details/51088091</a></p><p>链接：<a href="https://www.nowcoder.com/questionTerminal/4ef1d67edee049c78aa597067c519246">https://www.nowcoder.com/questionTerminal/4ef1d67edee049c78aa597067c519246</a><br>来源：牛客网</p><p>参见《Effective C++》 条款09：绝不在构造函数或析构函数中调用虚函数。</p><p>  这个链接有电子档：<a href="http://blog.csdn.net/hxz_qlh/article/details/14089895">http://blog.csdn.net/hxz_qlh/article/details/14089895</a></p><p>  简要结论：</p><p>  １.　从语法上讲，调用完全没有问题。</p><p>  ２.　但是从效果上看，往往不能达到需要的目的。</p><p>  Effective 的解释是：</p><p>  派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。</p><p>  同样，进入基类析构函数时，对象也是基类类型。</p><p>  所以，虚函数始终仅仅调用基类的虚函数（如果是基类调用虚函数），不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果。</p><h3 id="2-3-依赖倒置原则"><a href="#2-3-依赖倒置原则" class="headerlink" title="2.3 依赖倒置原则"></a>2.3 依赖倒置原则</h3><blockquote><p>抽象不应该依赖于具体类，具体类应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</p></blockquote><p>依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。</p><p>在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。</p><p><strong>优点：通过抽象来搭建框架，建立类和类的关联，以减少类间的耦合性。而且以抽象搭建的系统要比以具体实现搭建的系统更加稳定，扩展性更高，同时也便于维护。</strong></p><p>作者：xietao3<br>链接：<a href="https://juejin.im/post/5c8756e6e51d456cda2e7ff1">https://juejin.im/post/5c8756e6e51d456cda2e7ff1</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>单例模式（Singleton Pattern）</p><p>观察者模式(Observer Pattern)：定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式的别名包括发布-订阅（Publish&#x2F;Subscribe）模式、模型-视图（Model&#x2F;View）模式、源-监听器（Source&#x2F;Listener）模式或从属者（Dependents）模式。观察者模式是一种对象行为型模式。</p><p>作者：xietao3<br>链接：<a href="https://juejin.im/post/5c8756e6e51d456cda2e7ff1">https://juejin.im/post/5c8756e6e51d456cda2e7ff1</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="3-详细介绍一下TCP的四次挥手机制，为什么要有TIME-WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE-WAIT状态如何解决"><a href="#3-详细介绍一下TCP的四次挥手机制，为什么要有TIME-WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE-WAIT状态如何解决" class="headerlink" title="3. 详细介绍一下TCP的四次挥手机制，为什么要有TIME_WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE_WAIT状态如何解决"></a>3. 详细介绍一下TCP的四次挥手机制，为什么要有TIME_WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE_WAIT状态如何解决</h3><p>当客户端要服务器断开连接时，客户端 TCP 会向服务器发送一个特殊的报文段，该报文段的 FIN 标志位会被置1，接着服务器会向客户端发送一个确认报文段。然后服务器也会客户端发送一个 FIN 标志位为1的终止报文段，随后客户端回送一个确认报文段，服务器立即断开连接。客户端等待一段时间后也断开连接。</p><p>其实四次挥手的过程是很容易理解的，由于 TCP 协议是全双工的，也就是说客户端和服务端都可以发起断开连接。两边各发起一次断开连接的申请，加上各自的两次确认，看起来就像执行了四次挥手。</p><p>为什么要有 TIME_WAIT 状态？因为客户端最后向服务器发送的确认 ACK 是有可能丢失的，当出现超时，服务端会再次发送 FIN 报文段，如果客户端已经关闭了就收不到了。还有一点是避免新旧连接混杂。</p><p>大量 CLOSE_WAIT 表示程序出现了问题，对方的 socket 已经关闭连接，而我方忙于读或写没有及时关闭连接，需要检查代码，特别是释放资源的代码，或者是处理请求的线程配置</p><p>\3. TIME_WAIT状态<br>    经过前面的铺垫，终于要讲到与本文主题相关的内容了。 ^_^<br>    从TCP状态迁移图可知，只有首先调用close()发起主动关闭的一方才会进入TIME_WAIT状态，而且是必须进入（图中左下角所示的3条状态迁移线最终均要进入该状态才能回到初始的CLOSED状态）。<br>    从图中还可看到，进入TIME_WAIT状态的TCP连接需要经过2MSL才能回到初始状态，其中，MSL是指Max<br>Segment Lifetime，即数据包在网络中的最大生存时间。每种TCP协议的实现方法均要指定一个合适的MSL值，如RFC1122给出的建议值为2分钟，又如Berkeley体系的TCP实现通常选择30秒作为MSL值。这意味着TIME_WAIT的典型持续时间为1-4分钟。<br>    TIME_WAIT状态存在的原因主要有两点：<br>    1）为实现TCP这种全双工（full-duplex）连接的可靠释放<br>    参考本文前面给出的TCP释放连接4次挥手示意图，假设发起active close的一方（图中为client）发送的ACK（4次交互的最后一个包）在网络中丢失，那么由于TCP的重传机制，执行passiveclose的一方（图中为server）需要重发其FIN，在该FIN到达client（client是active close发起方）之前，client必须维护这条连接的状态（尽管它已调用过close），具体而言，就是这条TCP连接对应的（local_ip, local_port）资源不能被立即释放或重新分配。直到romete peer重发的FIN达到，client也重发ACK后，该TCP连接才能恢复初始的CLOSED状态。如果activeclose方不进入TIME_WAIT以维护其连接状态，则当passive close方重发的FIN达到时，active close方的TCP传输层会以RST包响应对方，这会被对方认为有错误发生（而事实上，这是正常的关闭连接过程，并非异常）。<br>    2）为使旧的数据包在网络因过期而消失<br>    为说明这个问题，我们先假设TCP协议中不存在TIME_WAIT状态的限制，再假设当前有一条TCP连接：(local_ip, local_port, remote_ip,remote_port)，因某些原因，我们先关闭，接着很快以相同的四元组建立一条新连接。本文前面介绍过，TCP连接由四元组唯一标识，因此，在我们假设的情况中，TCP协议栈是无法区分前后两条TCP连接的不同的，在它看来，这根本就是同一条连接，中间先释放再建立的过程对其来说是“感知”不到的。这样就可能发生这样的情况：前一条TCP连接由local peer发送的数据到达remote peer后，会被该remot peer的TCP传输层当做当前TCP连接的正常数据接收并向上传递至应用层（而事实上，在我们假设的场景下，这些旧数据到达remote peer前，旧连接已断开且一条由相同四元组构成的新TCP连接已建立，因此，这些旧数据是不应该被向上传递至应用层的），从而引起数据错乱进而导致各种无法预知的诡异现象。作为一种可靠的传输协议，TCP必须在协议层面考虑并避免这种情况的发生，这正是TIME_WAIT状态存在的第2个原因。<br>    具体而言，local peer主动调用close后，此时的TCP连接进入TIME_WAIT状态，处于该状态下的TCP连接不能立即以同样的四元组建立新连接，即发起active close的那方占用的local port在TIME_WAIT期间不能再被重新分配。由于TIME_WAIT状态持续时间为2MSL，这样保证了旧TCP连接双工链路中的旧数据包均因过期（超过MSL）而消失，此后，就可以用相同的四元组建立一条新连接而不会发生前后两次连接数据错乱的情况。</p><p>另一比较深入的说法</p><p>TIME_WAIT状态的存在有两个理由：（1）让4次握手关闭流程更加可靠；4次握手的最后一个ACK是是由主动关闭方发送出去的，若这个ACK丢失，被动关闭方会再次发一个FIN过来。若主动关闭方能够保持一个2MSL的TIME_WAIT状态，则有更大的机会让丢失的ACK被再次发送出去。（2）防止lost duplicate对后续新建正常链接的传输造成破坏。lost duplicate在实际的网络中非常常见，经常是由于路由器产生故障，路径无法收敛，导致一个packet在路由器A，B，C之间做类似死循环的跳转。IP头部有个TTL，限制了一个包在网络中的最大跳数，因此这个包有两种命运，要么最后TTL变为0，在网络中消失；要么TTL在变为0之前路由器路径收敛，它凭借剩余的TTL跳数终于到达目的地。但非常可惜的是TCP通过超时重传机制在早些时候发送了一个跟它一模一样的包，并先于它达到了目的地，因此它的命运也就注定被TCP协议栈抛弃。另外一个概念叫做incarnation connection，指跟上次的socket pair一摸一样的新连接，叫做incarnation of previous connection。lost duplicate加上incarnation connection，则会对我们的传输造成致命的错误。大家都知道TCP是流式的，所有包到达的顺序是不一致的，依靠序列号由TCP协议栈做顺序的拼接；假设一个incarnation connection这时收到的seq&#x3D;1000, 来了一个lost duplicate为seq&#x3D;1000, len&#x3D;1000, 则tcp认为这个lost duplicate合法，并存放入了receive buffer，导致传输出现错误。通过一个2MSL TIME_WAIT状态，确保所有的lost duplicate都会消失掉，避免对新连接造成错误。</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>从上面的图可以看到滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。</p><p>可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。</p><p>接着就讲讲什么是流量控制窗口，什么是拥塞控制窗口。</p><p>先讲流量控制：</p><p>TCP 是全双工的，客户端和服务器均可作为发送方或接收方，我们现在假设一个发送方向接收方发送数据的场景来讲解流量控制。首先我们的接收方有一块接收缓存，当数据来到时会先把数据放到缓存中，上层应用等缓存中有数据时就会到缓存中取数据。假如发送方没有限制地不断地向接收方发送数据，接收方的应用程序又没有及时把接收缓存中的数据读走，就会出现缓存溢出，数据丢失的现象，为了解决这个问题，我们引入流量控制窗口。</p><p>假设应用程序最后读走的数据序号是 lastByteRead，接收缓存中接收到的最后一个数据序号是 lastByteRcv，接收缓存的大小为 RcvSize，那么必须要满足 lastByteRcv - lastByteRead &lt;&#x3D; RcvSize 才能保证接收缓存不会溢出，所以我们定义流量窗口为接收缓存剩余的空间，也就是Rcv &#x3D; RcvSize - (lastByteRcv - lastByteRead)。只要接收方在响应 ACK 的时候把这个窗口的值带给发送方，发送方就能知道接收方的接收缓存还有多大的空间，进而设置滑动窗口的大小。</p><p>接着讲解拥塞控制：</p><p>拥塞控制是指发送方先设置一个小的窗口值作为发送速率，当成功发包并接收到ACK时，便以指数速率增大发送窗口的大小，直到遇到丢包（超时&#x2F;三个冗余ACK），才停止并调整窗口的大小。这么做能最大限度地利用带宽，又不至于让网络环境变得太过拥挤。</p><p>最终滑动窗口的值将设置为流量控制窗口和拥塞控制窗口中的较小值。</p><p>Q: 编写 TCP&#x2F;SOCK_STREAM 服务程序时，SO_REUSEADDR到底什么意思？</p><p>A: 这个套接字选项通知内核，如果端口忙，但TCP状态位于 TIME_WAIT ，可以重用端口。如果端口忙，而TCP状态位于其他状态，重用端口时依旧得到一个错误信息， 指明”地址已经使用中”。如果你的服务程序停止后想立即重启，而新套接字依旧 使用同一端口，此时 SO_REUSEADDR 选项非常有用。必须意识到，此时任何非期 望数据到达，都可能导致服务程序反应混乱，不过这只是一种可能，事实上很不可能。</p><p>　CLOSE_WAIT： 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。</p><h3 id="5-讲一下HTTP与HTTPS的区别"><a href="#5-讲一下HTTP与HTTPS的区别" class="headerlink" title="5. 讲一下HTTP与HTTPS的区别"></a>5. 讲一下HTTP与HTTPS的区别</h3><p>HTTP和HTTPS的主要区别在于HTTP协议传递的是明文数据，而HTTPS传递的是加密过的数据，也就是说HTTPS更具有安全性。也正由HTTPS需要保证安全性，所以它的性能要比HTTP差一点。</p><p>单说安全性肯定是不够的，我打算扩展讲一下HTTPS是怎么解决安全性问题的，通过这些HTTP没有机制，反映出HTTPS与HTTP的区别。下面尝试把HTTPS加密的过程推导出来。推导过程不涉及复杂的实现细节：</p><h4 id="如何安全地进行数据传输？"><a href="#如何安全地进行数据传输？" class="headerlink" title="如何安全地进行数据传输？"></a>如何安全地进行数据传输？</h4><p>假设现在A和B要进行安全的通信，那么究竟怎样才算是安全的通信？很自然地会想到：A和B之间传递数据，这些数据只有A和B才看得懂，中间人就算截取了信息但也看不懂，这才算得上安全。</p><h4 id="安全通信的处理手段："><a href="#安全通信的处理手段：" class="headerlink" title="安全通信的处理手段："></a>安全通信的处理手段：</h4><p>为了能让A和B才能看懂，就必须要对数据进行加密，而且首先想到的就是对称加密。对称加密的意思是A和B各持有一个相同的密钥，它们传递信息时会用密钥给信息加密，在消息到达端给消息解密，完成安全通信。</p><p>在对称加密中又会涉及到加密算法的选择问题。现实世界中，通常是多个客户端面向一个服务器的情况，不可能让每个客户端和服务器之间都采用相同的加密算法，如果是这样那和没加密差不多。所以注定每个客户端和服务器之间都会采用不同的加密方式。</p><h4 id="如何让每个客户端与服务器之间都采用不同的加密方式？"><a href="#如何让每个客户端与服务器之间都采用不同的加密方式？" class="headerlink" title="如何让每个客户端与服务器之间都采用不同的加密方式？"></a>如何让每个客户端与服务器之间都采用不同的加密方式？</h4><p>要想对不同的机器使用不同的加密方式，最直接想到的就是使用随机数。也就说客户端和服务器之间每次都基于一个随机数产生加密算法。（具体实现时为了保证随机，用到还不止一个随机数）</p><p>这个产生加密算法的过程称之为协商，现在问题是协商的过程是透明的，也就是说中间人可以截获协商的过程，从而知道我们的加密方式。为了解决这个问题，我们需要对协商的过程进行加密。</p><h4 id="如何对协商的过程进行加密？"><a href="#如何对协商的过程进行加密？" class="headerlink" title="如何对协商的过程进行加密？"></a>如何对协商的过程进行加密？</h4><p>之所以能来到这一步，是因为我们一开始就选择使用了对称加密，也就说一开始的对称加密导致了现在的问题，所以这时我们不能再使用对称加密了，否则会陷入死循环。</p><p>在密码学领域，还有一种加密过程叫非对称加密，它的逻辑是这样的：通信双方一方持有私钥，一方持有公钥，经过私钥加密的信息，都能通过公钥进行解密。但是经过公钥加密的数据，只有私钥可以解密。</p><p>按照非对称加密的规则，我们让服务器持有私钥，让客户端持有公钥。这样就能保证客户端给服务器发送消息的时候是安全的（相反，服务器给客户端发送消息就是不安全的），我们可以把协商时重要的逻辑安排在客户端给服务器发送信息的过程中，从而保证了协商过程的安全性。</p><h4 id="客户端如何获得公钥？"><a href="#客户端如何获得公钥？" class="headerlink" title="客户端如何获得公钥？"></a>客户端如何获得公钥？</h4><p>现在用非对称加密算法解决了协商的安全问题，但是非对称加密的前提是客户端需要获得公钥，这又是一个问题了，客户端与服务器打交道之前是互不知道双方身份的，怎么才能让客户端获得公钥呢？</p><p>也就只有两种办法：</p><ol><li>客户端向服务器要公钥</li><li>客户端向一个远程的公共服务器获取公钥</li></ol><p>方法2显然是不行的，尚且不说多了一个访问节点，如何找到公共服务器的地址也是一个待解决的问题，所以还是使用方法1。</p><p>但是方法1存在一个问题：如果中间人把服务器发送给客户端的公钥调包了怎么办？也就是说客户端无法知道发送公钥的是否是正真的服务器。</p><h4 id="引入第三方机构解决问题"><a href="#引入第三方机构解决问题" class="headerlink" title="引入第三方机构解决问题"></a>引入第三方机构解决问题</h4><p>客户端无法辨识服务端和中间人的问题称为“身份验证”问题，也就是说我们需要为服务器向客户端发送公钥的过程进行加密。</p><p>这下完了，之前我们因遇到对称加密的瓶颈选择了非对称加密，现在使用非对称加密也遇到了瓶颈。显然这两种加密方式都是不可用的了，否则会再次陷入死循环。</p><p>接下来我们只好通过第三方机构的介入，解决这个问题。首先我们自己保存有第三方权威机构的公钥，然后第三方机构使用私钥对服务器将要发送给客户端的公钥进行加密，客户端接收到这个经加密的公钥后（数字证书），就能通过自己保存的第三方机构公钥进行解密。</p><blockquote><p>到这里为止，我们解释了HTTPS中使用到的对称加密，非对称加密，CA，数字证书的概念，但是还差一个叫数字签名的概念没有解释。</p></blockquote><p>在现实生活中，CA不单止会给我们正常公司发放证书，还会给中间人的坏公司发放证书，如果中间人把发放的证书调包了怎么办？这时我们仍能用CA的私钥进行解密，但是证书已经被调包了。</p><p>那么客户端怎样验证证书的真伪呢？答案是证书本身会告诉客户端如何辨认真伪。比方说证书上面有一个证书编号，还有一个如何计算证书编号的方法，客户端可以根据计算证书编号的方法计算出自己要获得的证书的编号，然后把这个编号和证书上的编号进行比对，如果一样证明没有被调包。</p><p>这里的证书编号指的就是数字签名，证书指的就是数字证书。</p><p>总结一下HTTPS：HTTPS想要保证客户端与服务器之间的通信安全，就得使用对称加密算法进行加密。协商对称加密算法的过程通过非对称加密算法来保证。在非对称加密算法中，客户端获得公钥的过程需要第三方机构（CA）通过颁发数字证书保证安全性。</p><p>总得来说通过这一系列机制协商出了一个对称加密算法后，客户端与服务器之间就能通过该算法进行安全的通信了</p><h2 id="进程、线程、协程概念性区别"><a href="#进程、线程、协程概念性区别" class="headerlink" title="进程、线程、协程概念性区别"></a>进程、线程、协程概念性区别</h2><p>对于进程、线程，都是有内核进行调度，有CPU时间片的概念，进行抢占式调度（有多种调度算法）。</p><p>对于协程(用户级线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户的程序自己调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的CPU控制权切换到其他进程&#x2F;线程，通常只能进行协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。</p><ol><li><p>goroutine 和协程区别</p><p>本质上，goroutine 就是协程。 不同的是，Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的CPU (P) 转让出去，让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程。</p></li><li><p>其他方面不同</p><p>3.1 内存消耗方面</p><p>每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少。<br>goroutine: 2KB<br>线程: 8MB</p><p>3.2 线程&#x2F;goroutine 切换(调度)开销方面</p><p>线程&#x2F;goroutine 切换开销方面，goroutine 远比线程小<br>线程: 涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP…等寄存器的刷新等。<br>goroutine: 只有三个寄存器的值修改 - PC &#x2F; SP &#x2F; DX.</p></li><li><p>进程是程序执行的一个实例, 担当分担系统资源的实体.</p></li><li><p>进程是分配资源的基本单位，也是我们说的隔离。线程作为独立运行和独立调度的基本单位</p></li><li><p>进程切换只发生在内核态</p></li></ol><h2 id="线程-用户级线程-x2F-内核级线程"><a href="#线程-用户级线程-x2F-内核级线程" class="headerlink" title="线程(用户级线程&#x2F;内核级线程)"></a>线程(用户级线程&#x2F;内核级线程)</h2><ul><li>线程是进程的一个执行流, 线程是操作系统能够进行运算调度的最小单位</li><li>对于进程和线程,都是有内核进行调度,有 CPU 时间片的概念, 进行抢占式调度</li><li>线程可以在启动前设置栈的大小,启动后,线程的栈大小就固定了</li><li>内核由系统内核进行调度, 系统为了实现并发,会不断地切换线程执行, 由此会带来线程的上下文切换.</li></ul><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><ul><li>Goroutine 是协程的go语言实现</li><li>协程(用户态线程)是对内核透明的, 也就是系统完全不知道有协程的存在, 完全由用户自己的程序进行调度</li><li>在栈大小分配方便,且每个协程占用的默认占用内存很小,只有 <code>2kb</code> ,而线程需要 <code>8mb</code>,相较于线程,因为协程是对内核透明的,所以栈空间大小可以按需增大减小</li><li>在调度方面, 相较于线程,go 有自己的一套运行时调度系统,go的调度器类似于内核调度器, 而他不需要进行内核的上下文切换, 所以重新调度一个 Goroutine 的开销会小于重新调度线程的开销</li></ul><p><strong>协程与线程主要区别是它将不再被内核调度，而是交给了程序自己而线程是将自己交给内核调度，所以也不难理解golang中调度器的存在</strong></p><h3 id="cpp"><a href="#cpp" class="headerlink" title="cpp"></a>cpp</h3><ul><li>一个C++对象的大小由哪些因素决定？基类，成员，内存对齐，虚函数。</li><li>C++对象的成员函数对对象大小有什么影响？是否有虚函数，虚函数的个数多少对对象大小有什么影响？</li><li>一个C++对象的初始化顺序是什么？</li><li>虚析构函数有什么用途？</li><li>new operator和operator new什么区别和联系？</li><li>什么是placement new？</li><li>STL迭代器按照支持的操作分为哪几类？</li><li>Map和UnorderedMap的主要区别是什么？如何选择？</li><li>UnorderedMap如何解决Hash冲突？</li><li>Deque和Vector有什么区别？</li><li>什么是RAII机制？</li><li>在C++中，如何避免内存泄漏？</li><li>智能指针有哪些？什么用途？</li></ul><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><ul><li>个进程的多个线程之间，那些资源是共享的，哪些是私有的？</li><li>多个线程之间，线程同步和通讯的原语主要有哪些？</li><li>进程间通讯的方式有哪些？（共享内存，消息队列，管道，信号量，信号等）</li><li>程序崩溃了，如何定位崩溃点？</li><li>程序崩溃时，常见的主要有那些信号？</li><li>内存泄漏如何调试？如何预防？</li><li>SSD和机械硬盘的主要区别是什么？</li><li>SSD的写放大是什么意思？</li></ul><p>不懂Linux的，Linux相关的问题可以不知道。</p><p>\6. 数据库的事务的4个特性是什么？并发事务会带来什么问题？</p><ol><li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li><li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><p>并发事务的问题：</p><ul><li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li><li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A&#x3D;20，事务2也读取A&#x3D;20，事务1修改A&#x3D;A-1，事务2也修改A&#x3D;A-1，最终结果A&#x3D;19，事务1的修改被丢失。</li><li><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li><li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li></ul><p>事务隔离的级别：</p><ul><li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li><li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li><li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。（MySQL默认）</li><li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li></ul><h3 id="上机"><a href="#上机" class="headerlink" title="上机"></a>上机</h3><p>面试问题</p><p>1）TCP&#x2F;IP协议<br>    1）三次握手&#x2F;四次挥手过程<br>    2）TIME_WAIT状态<br>        1）主动关闭&#x2F;被动关闭<br>        2）需要的原因<br>        3）缓解措施<br>        4）有没有方式不出现TIME_WAIT状态<br>    3）RST出现的场景<br>    4）滑动窗口<br>2）网络编程<br>    1）EPOLL&#x2F;SELECT的区别<br>    2）边沿触发&#x2F;水平触发<br>    3）事件触发的场景<br>        1）读事件 有哪些场景<br>        2）写事件 有哪些场景<br>    4）READ调用返回值场景<br>        1）0<br>        2）-1<br>        3）&gt;0<br>    5）UDP客户端可以CONNECT不，那CONNECT和不CONNECT有啥区别<br>3）后台编程<br>    1）FORK的用途，FORK区分父子进程方式<br>    2）进程间通信方式<br>    3）僵尸进程<br>    4）内存模型，有哪些段构成<br>    5）进程&#x2F;线程&#x2F;协程的区别<br>4）常见中间件<br>    1）MYSQL<br>        1）为啥不建议SELECT *<br>        2）覆盖索引<br>        3）分页优化<br>    2）ZOOKEEPER<br>        1）有哪些WATCH以及对应唤醒事件<br>    3）KAFKA<br>        1）分区分服<br>        2）生产者<br>        3）消费者<br>5）语言<br>    1）JAVA语言<br>        1）内存管理<br>6）设计模式<br>    1）单例模式<br>7）项目中的难点、挑战点</p><p>22989-腾讯云网络后台开发工程师(CSIG全资子公司)（西安）</p><p>建议用online ddl（网上可以查）修改，就是逗号后面的参数<br>另外，添加字段要加上after，根据表结构看看fromWanIp适合在哪个字段后<br>ALTER TABLE cEip ALTER COLUMN ispId SET DEFAULT -1, ALGORITHM&#x3D;INPLACE, LOCK&#x3D;NONE;</p><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><h3 id="1-基础语法"><a href="#1-基础语法" class="headerlink" title="1. 基础语法"></a>1. 基础语法</h3><ul><li>可变类型与不可变类型，如何判断一个变量是可变还是不可变</li><li>python的函数传参是值传递还是引用传递</li><li>逻辑表达式中，哪些值是假？（0，空串，空容器，False，None）</li><li>列表和元组有什么不同？</li><li>range和xrange有什么区别？</li><li>for循环如何同时遍历索引和值</li><li>什么是静态方法，如何定义</li><li>静态方法和类方法的区别是什么？</li><li>list如何去重？</li><li>如何判断字符串是否含有某个字串（in比str.find好）为什么？</li><li>is None和&#x3D;&#x3D; None有什么区别？</li><li>什么是GIL, 多线程多进程</li><li>type isinstance区别</li><li>字符串拼接用 join和+的区别</li><li>list、set、tuple 区别，实现细节、效率</li><li>python中的封装、继承、多态</li></ul><h2 id="2-python编码"><a href="#2-python编码" class="headerlink" title="2. python编码"></a>2. python编码</h2><ul><li>python实现单例（多种）</li><li>python实现带参数、带返回值的装饰器（统计函数执行时间为例等，函数名覆盖问题）  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;func.__name__&#125;</span> took <span class="subst">&#123;end_time - start_time:<span class="number">.6</span>f&#125;</span>s.&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">    </span><br><span class="line"><span class="meta">@timer </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>(<span class="params">x, y</span>): </span><br><span class="line">time.sleep(<span class="number">1</span>) </span><br><span class="line"><span class="keyword">return</span> x + y </span><br><span class="line">result = my_func(<span class="number">3</span>, <span class="number">4</span>) <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></li></ul><p>如果需要传递额外参数给装饰器，可以在装饰器外层再添加一层函数，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repeat</span>(<span class="params">n=<span class="number">3</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                result = func(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@repeat(<span class="params">n=<span class="number">5</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>(<span class="params">x, y</span>):</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">result = my_func(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>repeat是一个外层函数，用于接收额外参数n，并返回一个内层函数decorator。decorator函数则是真正的装饰器函数，接受一个函数作为参数，并返回一个内部函数wrapper。wrapper函数接受任意数量的位置参数和关键字参数，并调用原函数，重复执行n次，并返回最后一次函数执行结果。</p><p>总之，Python的装饰器是一种强大的语法特性，可以用于对函数进行增强、统计函数执行时间等操作，提高程序的可维护性和可扩展性。在使用装饰器时，应该注意保留原函数名，避免装饰器对函数名造成覆盖。</p><ul><li>合并两个数组、排序</li></ul>]]></content>
    
    
    <summary type="html">积累编码相关面试问题及解答。包括cpp/python/数据结构等</summary>
    
    
    
    <category term="Tech" scheme="http://amazingcoderpro.github.io/categories/Tech/"/>
    
    
    <category term="cs" scheme="http://amazingcoderpro.github.io/tags/cs/"/>
    
    <category term="python" scheme="http://amazingcoderpro.github.io/tags/python/"/>
    
    <category term="interview" scheme="http://amazingcoderpro.github.io/tags/interview/"/>
    
    <category term="cpp" scheme="http://amazingcoderpro.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>面试问题汇总</title>
    <link href="http://amazingcoderpro.github.io/2023/08/19/Tech/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://amazingcoderpro.github.io/2023/08/19/Tech/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</id>
    <published>2023-08-19T09:41:51.000Z</published>
    <updated>2023-08-19T09:41:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试问题汇总"><a href="#面试问题汇总" class="headerlink" title="面试问题汇总"></a>面试问题汇总</h1><p>1）TCP&#x2F;IP协议<br>    1）三次握手&#x2F;四次挥手过程<br>    2）TIME_WAIT状态<br>        1）主动关闭&#x2F;被动关闭<br>        2）需要的原因<br>        3）缓解措施<br>        4）有没有方式不出现TIME_WAIT状态<br>    3）RST出现的场景<br>    4）滑动窗口<br>2）网络编程<br>    1）EPOLL&#x2F;SELECT的区别<br>    2）边沿触发&#x2F;水平触发<br>    3）事件触发的场景<br>        1）读事件 有哪些场景<br>        2）写事件 有哪些场景<br>    4）READ调用返回值场景<br>        1）0<br>        2）-1<br>        3）&gt;0<br>    5）UDP客户端可以CONNECT不，那CONNECT和不CONNECT有啥区别<br>3）后台编程<br>    1）FORK的用途，FORK区分父子进程方式<br>    2）进程间通信方式<br>    3）僵尸进程<br>    4）内存模型，有哪些段构成<br>    5）进程&#x2F;线程&#x2F;协程的区别<br>4）常见中间件<br>    1）MYSQL<br>        1）为啥不建议SELECT *<br>        2）覆盖索引<br>        3）分页优化<br>    2）ZOOKEEPER<br>        1）有哪些WATCH以及对应唤醒事件<br>    3）KAFKA<br>        1）分区分服<br>        2）生产者<br>        3）消费者<br>5）语言<br>    1）JAVA语言<br>        1）内存管理<br>6）设计模式<br>    1）单例模式<br>7）项目中的难点、挑战点</p>]]></content>
    
    
    <summary type="html">面试问题汇总</summary>
    
    
    
    <category term="Tech" scheme="http://amazingcoderpro.github.io/categories/Tech/"/>
    
    
    <category term="intervew" scheme="http://amazingcoderpro.github.io/tags/intervew/"/>
    
    <category term="job" scheme="http://amazingcoderpro.github.io/tags/job/"/>
    
  </entry>
  
  <entry>
    <title>如何写卡片</title>
    <link href="http://amazingcoderpro.github.io/2023/06/08/SoftSkills/%E5%A6%82%E4%BD%95%E5%86%99%E5%8D%A1%E7%89%87/"/>
    <id>http://amazingcoderpro.github.io/2023/06/08/SoftSkills/%E5%A6%82%E4%BD%95%E5%86%99%E5%8D%A1%E7%89%87/</id>
    <published>2023-06-08T07:29:00.000Z</published>
    <updated>2023-10-08T07:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何写卡片"><a href="#如何写卡片" class="headerlink" title="如何写卡片"></a>如何写卡片</h1><p>from: Day2—《用卡片实现善思会写》<br>听课链接：<a href="https://jcg.h5.xeknow.com/s/HzDLj">https://jcg.h5.xeknow.com/s/HzDLj</a><br>听课密码：1210</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li>格式：核心概念+个人体会+行动指引</li><li>勾连个人体验，有情绪更好</li><li>行动指引</li><li>一张卡片一个概念</li><li>100-500字即可。</li><li>一周有3-6张即可，一本书有10-15个卡片就不错</li></ul><h2 id="个人体会"><a href="#个人体会" class="headerlink" title="个人体会"></a>个人体会</h2><ul><li>以前虽然也会去记录一些知识点，但是没有清晰的格式，有时还是简单的复制粘贴，用的时候就记不起来了。</li><li>没有把个人体验和行动指引清晰的写出来，导致理解的不够深刻，知识没有用起来。</li></ul><h2 id="行动指引"><a href="#行动指引" class="headerlink" title="行动指引"></a>行动指引</h2><ul><li>当读到有感触的文章时可以写一篇卡片</li><li>不要太长，别顺着思路王霞溜，围绕单一概念</li><li>准备写作时可以先搜集相关的概念和知识汇集成一堆卡片，以备写作时使用。</li></ul>]]></content>
    
    
    <summary type="html">如何写卡片</summary>
    
    
    
    <category term="SoftSkills" scheme="http://amazingcoderpro.github.io/categories/SoftSkills/"/>
    
    
    <category term="writ" scheme="http://amazingcoderpro.github.io/tags/writ/"/>
    
    <category term="softskills" scheme="http://amazingcoderpro.github.io/tags/softskills/"/>
    
  </entry>
  
  <entry>
    <title>面试八股之网络</title>
    <link href="http://amazingcoderpro.github.io/2022/10/08/Tech/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E4%B9%8B%E7%BD%91%E7%BB%9C/"/>
    <id>http://amazingcoderpro.github.io/2022/10/08/Tech/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E4%B9%8B%E7%BD%91%E7%BB%9C/</id>
    <published>2022-10-08T07:29:00.000Z</published>
    <updated>2022-10-08T07:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试八股之网络"><a href="#面试八股之网络" class="headerlink" title="面试八股之网络"></a>面试八股之网络</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><h3 id="TCP连接中间会有什么操作"><a href="#TCP连接中间会有什么操作" class="headerlink" title="TCP连接中间会有什么操作"></a>TCP连接中间会有什么操作</h3><p>在TCP连接中，客户端和服务器之间会进行以下操作：</p><ul><li><p>握手阶段：客户端向服务器发送SYN包（同步包），请求建立连接。服务器收到SYN包后，向客户端发送SYN+ACK包（同步确认包），表示可以建立连接。客户端收到SYN+ACK包后，再向服务器发送ACK包（确认包），表示连接建立成功。</p></li><li><p>数据传输阶段：连接建立成功后，客户端和服务器之间可以进行数据的传输。客户端向服务器发送数据包，服务器接收数据包并进行处理，然后向客户端发送响应包。客户端收到响应包后，可以再次向服务器发送数据包，以此类推。</p></li><li><p>断开连接阶段：当客户端或服务器不再需要连接时，可以发送FIN包（结束包）来请求断开连接。对方收到FIN包后，也发送FIN包进行响应，表示同意断开连接。当两端都收到对方的FIN包后，连接才真正关闭。</p></li></ul><p>需要注意的是，在TCP连接中可能会出现丢包、拥塞等情况，需要进行相应的处理，例如重传丢失的数据包、调整发送窗口大小等</p><h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><ul><li>TCP 三次握手中，客户端收到的第二次握手中 ack 确认号不是自己期望的，会发生什么？是直接丢弃 or 回 RST 报文？</li><li>什么情况下会收到不正确的 ack（第二次握手中的 ack） 呢？<br>不卖关子，直接说这个问题，是<strong>回 RST 报文</strong>。过程如下图：</li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeRVaGLU0HSwicWshvgthyXukQSF6kevWWckbxxO3pOCgfYqSVl8H7icM0zFzWD6gjg5n0mI1ETeZew/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>三次握手避免历史连接</p><p>当客户端连续发送多次建立连接的 SYN 报文，然后在网络拥堵的情况，就会发生客户端收到不正确的 ack 的情况。具体过程如下：</p><ul><li><p>客户端先发送了 SYN（seq &#x3D; 90） 报文，但是被网络阻塞了，服务端并没有收到，接着客户端又重新发送了 SYN（seq &#x3D; 100） 报文，注意不是重传 SYN，重传的 SYN 的序列号是一样的。</p></li><li><p>「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端，那么此时服务端就会回一个 SYN + ACK 报文给客户端，此报文的确认号是 91（90+1）。</p></li><li><p>客户端收到后，发行自己期望收到的确认号应该是 100+1，而不是 90 + 1，于是就会回 RST 报文。</p></li><li><p>服务端收到 RST 报文后，就会中止连接。</p></li><li><p>后续最新的 SYN 抵达了服务端后，客户端与服务端就可以正常的完成三次握手了。</p></li></ul><p>上述中的「旧 SYN 报文」称为历史连接，TCP 使用三次握手建立连接的<strong>最主要原因就是防止「历史连接」初始化了连接</strong>。</p><p>我们也可以从 RFC 793 知道 TCP 连接使用三次握手的首要原因：</p><p><em>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</em></p><p>简单来说，三次握手的首要原因是为了防止旧的重复连接初始化造成混乱。RFC 给出的三次握手防止历史连接的案例图如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeRVaGLU0HSwicWshvgthyXulbVmhSyuhoYJicsSqqzlLicN8vibzkAZB3WoAw0cCYE990DtCZckUXdwQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>RFC 793</p><p>如果是两次握手连接，就无法阻止历史连接，那<strong>为什么 TCP 两次握手为什么无法阻止历史连接呢？</strong></p><p>我先直接说结论，主要是因为<strong>在两次握手的情况下，「被动发起方」没有中间状态给「主动发起方」来阻止历史连接，导致「被动发起方」可能建立一个历史连接，造成资源浪费</strong>。</p><p>你想想，两次握手的情况下，「被动发起方」在收到 SYN 报文后，就进入 ESTABLISHED 状态，意味着这时可以给对方发送数据给，但是「主动发」起方此时还没有进入 ESTABLISHED 状态，假设这次是历史连接，主动发起方判断到此次连接为历史连接，那么就会回 RST 报文来断开连接，而「被动发起方」在第一次握手的时候就进入 ESTABLISHED 状态，所以它可以发送数据的，但是它并不知道这个是历史连接，它只有在收到 RST 报文后，才会断开连接。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeRVaGLU0HSwicWshvgthyXuHS7B2sADweWDX3rVH109Hqdw5fbYbJMetYTT3xEicicBrYiaSm7KYnPfg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>两次握手无法阻止历史连接</p><p>可以看到，上面这种场景下，「被动发起方」在向「主动发起方」发送数据前，并没有阻止掉历史连接，导致「被动发起方」建立了一个历史连接，又白白发送了数据，妥妥地浪费了「被动发起方」的资源。</p><p>因此，<strong>要解决这种现象，最好就是在「被动发起方」发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手</strong>。</p><p>我说回 RST 就回 RST 吗？当然不是了，肯定得用源码证明我说的这个结论。</p><p>听到要源码分析，可能有的同学就怂了。</p><p>其实要分析我们今天这个问题，只要懂 if else 就行了，我也会用中文来表述代码的逻辑，所以单纯看我的文字也是可以的。</p><p>这次我们重点分析的是，在 SYN_SENT 状态下，收到不正确的确认号的 syn+ack 报文是如何处理的。</p><p>处于 SYN_SENT 状态下的客户端，在收到服务端的  syn+ack 报文后，最终会调用  tcp_rcv_state_process，在这里会根据 TCP 状态做对应的处理，这里我们只关注 SYN_SENT 状态。</p><p><code>// net/ipv4/tcp_ipv4.c   int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb)   &#123;    ...         int queued = 0;          ...         switch (sk-&gt;sk_state) &#123;    case TCP_CLOSE:     ...    case TCP_LISTEN:     ...    case TCP_SYN_SENT:       ....     queued = tcp_rcv_synsent_state_process(sk, skb, th);     if (queued &gt;= 0)      return queued;       ...    &#125;   </code></p><p>可以看到，接下来，会继续调用 tcp_rcv_synsent_state_process 函数。</p><p><code>static int tcp_rcv_synsent_state_process(struct sock *sk, struct sk_buff *skb,         const struct tcphdr *th)   &#123;    ....       if (th-&gt;ack) &#123;     /* rfc793:      * &quot;If the state is SYN-SENT then      *    first check the ACK bit      *      If the ACK bit is set      *   If SEG.ACK =&lt; ISS, or SEG.ACK &gt; SND.NXT, send      *        a reset (unless the RST bit is set, if so drop      *        the segment and return)&quot;      */       // ack 的确认号不是预期的     if (!after(TCP_SKB_CB(skb)-&gt;ack_seq, tp-&gt;snd_una) ||         after(TCP_SKB_CB(skb)-&gt;ack_seq, tp-&gt;snd_nxt))         //回 RST 报文      goto reset_and_undo;        ...   &#125;      </code></p><p>从上面的函数，就可以得知了，客户端在 SYN_SENT 状态下，收到不正确的确认号的 syn+ack 报文会回 RST 报文。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><blockquote><p>TCP 三次握手中，客户端收到的第二次握手中 ack 确认号不是自己期望的，会发生什么？是直接丢弃 or 回 RST 报文？</p></blockquote><p>回 RST 报文。</p><blockquote><p>什么情况下会收到不正确的 ack（第二次握手中的 ack） 呢？</p></blockquote><p>当客户端发起多次 SYN 报文，然后网络拥堵的情况下，「旧的 SYN 报文」比「新的 SYN 报文」早抵达服务端，此时服务端就会按照收到的「旧的 SYN 报文」回复 syn+ack 报文，而此报文的确认号并不是客户端期望收到的，于是客户端就会回 RST 报文。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>虽然我们在学习 TCP 挥手时，学到的是需要四次来完成 TCP 挥手，但是<strong>在一些情况下， TCP 四次挥手是可以变成 TCP 三次挥手的</strong>。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtq0WaxOzTFbA8SQ5Am8ibRL1JMdq5GibqVeXYWOXB3gtdHAMwic01mMAOSw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>而且在用 wireshark 工具抓包的时候，我们也会常看到 TCP 挥手过程是三次，而不是四次，如下图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqh59jUuDV016elb1Z9Hn0GwfCuDdZbqm1cAn3Pf8FI7RSyficSXgT8Qg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>先来回答为什么 RFC 文档里定义 TCP 挥手过程是要四次？</p><p>再来回答什么情况下，什么情况会出现三次挥手？</p><h4 id="为什么-TCP-挥手需要四次？"><a href="#为什么-TCP-挥手需要四次？" class="headerlink" title="为什么 TCP 挥手需要四次？"></a>为什么 TCP 挥手需要四次？</h4><p>TCP 四次挥手的过程如下：<br>![[Pasted image 20230518120138.png]]</p><p>具体过程：</p><ul><li><p>客户端主动调用关闭连接的函数，于是就会发送 FIN 报文，这个  FIN 报文代表客户端不会再发送数据了，进入 FIN_WAIT_1 状态；</p></li><li><p>服务端收到了 FIN 报文，然后马上回复一个 ACK 确认报文，此时服务端进入 CLOSE_WAIT 状态。在收到 FIN 报文的时候，TCP 协议栈会为 FIN 包插入一个文件结束符 EOF 到接收缓冲区中，服务端应用程序可以通过 read 调用来感知这个 FIN 包，这个 EOF 会被<strong>放在已排队等候的其他已接收的数据之后</strong>，所以必须要得继续 read 接收缓冲区已接收的数据；</p></li><li><p>接着，当服务端在 read 数据的时候，最后自然就会读到 EOF，接着 <strong>read() 就会返回 0，这时服务端应用程序如果有数据要发送的话，就发完数据后才调用关闭连接的函数，如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数</strong>，这时服务端就会发一个 FIN 包，这个  FIN 报文代表服务端不会再发送数据了，之后处于 LAST_ACK 状态；</p></li><li><p>客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进入 TIME_WAIT 状态；</p></li><li><p>服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态；</p></li><li><p>客户端经过 2MSL 时间之后，也进入 CLOSE 状态；</p></li></ul><p>你可以看到，每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。</p><h4 id="为什么-TCP-挥手需要四次呢？"><a href="#为什么-TCP-挥手需要四次呢？" class="headerlink" title="为什么 TCP 挥手需要四次呢？"></a>为什么 TCP 挥手需要四次呢？</h4><p>服务器收到客户端的 FIN 报文时，内核会马上回一个 ACK 应答报文，<strong>但是服务端应用程序可能还有数据要发送，所以并不能马上发送 FIN 报文，而是将发送 FIN 报文的控制权交给服务端应用程序</strong>：</p><ul><li><p>如果服务端应用程序有数据要发送的话，就发完数据后，才调用关闭连接的函数；</p></li><li><p>如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数，</p></li></ul><p>从上面过程可知，<strong>是否要发送第三次挥手的控制权不在内核，而是在被动关闭方（上图的服务端）的应用程序，因为应用程序可能还有数据要发送，由应用程序决定什么时候调用关闭连接的函数，当调用了关闭连接的函数，内核就会发送 FIN 报文了，</strong>所以服务端的 ACK 和 FIN 一般都会分开发送。</p><blockquote><p>FIN 报文一定得调用关闭连接的函数，才会发送吗？</p></blockquote><p>不一定。</p><p>如果进程退出了，不管是不是正常退出，还是异常退出（如进程崩溃），内核都会发送 FIN 报文，与对方完成四次挥手。</p><h4 id="粗暴关闭-vs-优雅关闭"><a href="#粗暴关闭-vs-优雅关闭" class="headerlink" title="粗暴关闭 vs 优雅关闭"></a>粗暴关闭 vs 优雅关闭</h4><p>前面介绍 TCP 四次挥手的时候，并没有详细介绍关闭连接的函数，其实关闭的连接的函数有两种函数：</p><ul><li><p>close 函数，同时 socket 关闭发送方向和读取方向，也就是 socket 不再有发送和接收数据的能力。如果有多进程&#x2F;多线程共享同一个 socket，如果有一个进程调用了 close 关闭只是让 socket 引用计数 -1，并不会导致 socket 不可用，同时也不会发出 FIN 报文，其他进程还是可以正常读写该 socket，直到引用计数变为 0，才会发出 FIN 报文。</p></li><li><p>shutdown 函数，可以指定 socket 只关闭发送方向而不关闭读取方向，也就是 socket 不再有发送数据的能力，但是还是具有接收数据的能力。如果有多进程&#x2F;多线程共享同一个 socket，shutdown 则不管引用计数，直接使得该 socket 不可用，然后发出 FIN 报文，如果有别的进程企图使用该 socket，将会受到影响。</p></li></ul><p>如果客户端是用 close 函数来关闭连接，那么在 TCP 四次挥手过程中，如果收到了服务端发送的数据，由于客户端已经不再具有发送和接收数据的能力，所以客户端的内核会回 RST 报文给服务端，然后内核会释放连接，这时就不会经历完成的 TCP 四次挥手，所以我们常说，调用 close 是粗暴的关闭。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqTKiaCezviad9jEJ6laX7YTvmNr0CNBAeFq1ibFtDo8daKnLoiaZf86QXdg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>当服务端收到 RST 后，内核就会释放连接，当服务端应用程序再次发起读操作或者写操作时，就能感知到连接已经被释放了：</p><ul><li><p>如果是读操作，则会返回 RST 的报错，也就是我们常见的Connection reset by peer。</p></li><li><p>如果是写操作，那么程序会产生 SIGPIPE 信号，应用层代码可以捕获并处理信号，如果不处理，则默认情况下进程会终止，异常退出。</p></li></ul><p>相对的，shutdown 函数因为可以指定只关闭发送方向而不关闭读取方向，所以即使在 TCP 四次挥手过程中，如果收到了服务端发送的数据，客户端也是可以正常读取到该数据的，然后就会经历完整的 TCP 四次挥手，所以我们常说，调用 shutdown 是优雅的关闭。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqjibEsjHAFttJCMw712anZwKVHb6YNvqNjib3Vy9pHQOmeibVYjDNfEnAw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>但是注意，shutdown 函数也可以指定「只关闭读取方向，而不关闭发送方向」，但是这时候内核是不会发送 FIN 报文的，因为发送 FIN 报文是意味着我方将不再发送任何数据，而 <strong>shutdown 如果指定「不关闭发送方向」，就意味着 socket 还有发送数据的能力，所以内核就不会发送 FIN</strong>。</p><h4 id="什么情况会出现三次挥手？"><a href="#什么情况会出现三次挥手？" class="headerlink" title="什么情况会出现三次挥手？"></a>什么情况会出现三次挥手？</h4><p>当被动关闭方（上图的服务端）在 TCP 挥手过程中，「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtq0WaxOzTFbA8SQ5Am8ibRL1JMdq5GibqVeXYWOXB3gtdHAMwic01mMAOSw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>然后因为 TCP 延迟确认机制是默认开启的，所以导致我们抓包时，看见三次挥手的次数比四次挥手还多。</p><blockquote><p>什么是  TCP 延迟确认机制？</p></blockquote><p>当发送没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文。</p><p>为了解决 ACK 传输效率低问题，所以就衍生出了 <strong>TCP 延迟确认</strong>。</p><p>TCP 延迟确认的策略：</p><ul><li><p>当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方</p></li><li><p>当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</p></li><li><p>如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK</p></li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqoexLQeRzR1uwXIKrH3jJ9b0NNcrbxEKo7uvPp3eZLiafZkVfiaiaibVulg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>延迟等待的时间是在 Linux 内核中定义的，如下图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqvkkq2d3h7qiaibwa8q3NghgrSVU48FFROd8ydmATAMAaMQpHiapicKTytw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>关键就需要 HZ 这个数值大小，HZ 是跟系统的时钟频率有关，每个操作系统都不一样，在我的 Linux 系统中 HZ 大小是 1000，如下图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqJzGZ8BicbA81zRB4HzbGnFrxdC9tfsZSK1uj82ZPS52d74JTRMqG4Jg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>知道了 HZ 的大小，那么就可以算出：</p><ul><li><p>最大延迟确认时间是 200 ms （1000&#x2F;5）</p></li><li><p>最短延迟确认时间是 40 ms （1000&#x2F;25）</p></li></ul><blockquote><p>怎么关闭 TCP 延迟确认机制？</p></blockquote><p>如果要关闭 TCP 延迟确认机制，可以在 Socket 设置里启用 TCP_QUICKACK，启用 TCP_QUICKACK，就相当于关闭 TCP 延迟确认机制。</p><p>&#x2F;&#x2F; 1 表示开启 TCP_QUICKACK，即关闭 TCP 延迟确认机制<br>int value &#x3D; 1;<br>setsockopt(socketfd, IPPROTO_TCP, TCP_QUICKACK, (char*)&amp; value, sizeof(int));  </p><h4 id="实验验证"><a href="#实验验证" class="headerlink" title="实验验证"></a>实验验证</h4><h5 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h5><p>接下来，来给大家做个实验，验证这个结论：</p><blockquote><p>当被动关闭方（上图的服务端）在 TCP 挥手过程中，「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p></blockquote><p>服务端的代码如下，做的事情很简单，就读取数据，然后当 read 返回 0 的时候，就马上调用 close 关闭连接。因为 TCP 延迟确认机制是默认开启的，所以不需要特殊设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;netdb.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;netinet/in.h&gt;  </span><br><span class="line">#include &lt;sys/socket.h&gt;  </span><br><span class="line">#include &lt;netinet/tcp.h&gt;  </span><br><span class="line">  </span><br><span class="line">#define MAXLINE 1024  </span><br><span class="line">  </span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line">    // 1. 创建一个监听 socket  </span><br><span class="line">    int listenfd = socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">    if(listenfd &lt; 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">        fprintf(stderr, &quot;socket error : %s\n&quot;, strerror(errno));  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 2. 初始化服务器地址和端口  </span><br><span class="line">    struct sockaddr_in server_addr;  </span><br><span class="line">    bzero(&amp;server_addr, sizeof(struct sockaddr_in));  </span><br><span class="line">    server_addr.sin_family = AF_INET;  </span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">    server_addr.sin_port = htons(8888);  </span><br><span class="line">  </span><br><span class="line">    // 3. 绑定地址+端口  </span><br><span class="line">    if(bind(listenfd, (struct sockaddr *)(&amp;server_addr), sizeof(struct sockaddr)) &lt; 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">        fprintf(stderr,&quot;bind error:%s\n&quot;, strerror(errno));  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;begin listen....\n&quot;);  </span><br><span class="line">  </span><br><span class="line">    // 4. 开始监听  </span><br><span class="line">    if(listen(listenfd, 128))  </span><br><span class="line">    &#123;  </span><br><span class="line">        fprintf(stderr, &quot;listen error:%s\n\a&quot;, strerror(errno));  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    // 5. 获取已连接的socket  </span><br><span class="line">    struct sockaddr_in client_addr;  </span><br><span class="line">    socklen_t client_addrlen = sizeof(client_addr);  </span><br><span class="line">    int clientfd = accept(listenfd, (struct sockaddr *)&amp;client_addr, &amp;client_addrlen);  </span><br><span class="line">    if(clientfd &lt; 0) &#123;  </span><br><span class="line">        fprintf(stderr, &quot;accept error:%s\n\a&quot;, strerror(errno));  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;accept success\n&quot;);  </span><br><span class="line">  </span><br><span class="line">    char message[MAXLINE] = &#123;0&#125;;  </span><br><span class="line">      </span><br><span class="line">    while(1) &#123;  </span><br><span class="line">        //6. 读取客户端发送的数据  </span><br><span class="line">        int n = read(clientfd, message, MAXLINE);  </span><br><span class="line">        if(n &lt; 0) &#123; // 读取错误  </span><br><span class="line">            fprintf(stderr, &quot;read error:%s\n\a&quot;, strerror(errno));  </span><br><span class="line">            break;  </span><br><span class="line">        &#125; else if(n == 0) &#123;  // 返回 0 ，代表读到 FIN 报文  </span><br><span class="line">            fprintf(stderr, &quot;client closed \n&quot;);  </span><br><span class="line">            close(clientfd); // 没有数据要发送，立马关闭连接  </span><br><span class="line">            break;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        message[n] = 0;   </span><br><span class="line">        printf(&quot;received %d bytes: %s\n&quot;, n, message);  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    close(listenfd);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>客户端代码如下，做的事情也很简单，与服务端连接成功后，就发送数据给服务端，然后睡眠一秒后，就调用 close 关闭连接，所以客户端是主动关闭方：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;netdb.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;netinet/in.h&gt;  </span><br><span class="line">#include &lt;sys/socket.h&gt;  </span><br><span class="line">  </span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line">    // 1. 创建一个监听 socket  </span><br><span class="line">    int connectfd = socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">    if(connectfd &lt; 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">        fprintf(stderr, &quot;socket error : %s\n&quot;, strerror(errno));  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 2. 初始化服务器地址和端口  </span><br><span class="line">    struct sockaddr_in server_addr;  </span><br><span class="line">    bzero(&amp;server_addr, sizeof(struct sockaddr_in));  </span><br><span class="line">    server_addr.sin_family = AF_INET;  </span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);  </span><br><span class="line">    server_addr.sin_port = htons(8888);  </span><br><span class="line">      </span><br><span class="line">    // 3. 连接服务器  </span><br><span class="line">    if(connect(connectfd, (struct sockaddr *)(&amp;server_addr), sizeof(server_addr)) &lt; 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">        fprintf(stderr,&quot;connect error:%s\n&quot;, strerror(errno));  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;connect success\n&quot;);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    char sendline[64] = &quot;hello, i am xiaolin&quot;;  </span><br><span class="line">  </span><br><span class="line">    //4. 发送数据  </span><br><span class="line">    int ret = send(connectfd, sendline, strlen(sendline), 0);  </span><br><span class="line">    if(ret != strlen(sendline)) &#123;  </span><br><span class="line">        fprintf(stderr,&quot;send data error:%s\n&quot;, strerror(errno));  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;already send %d bytes\n&quot;, ret);  </span><br><span class="line">  </span><br><span class="line">    sleep(1);  </span><br><span class="line">  </span><br><span class="line">    //5. 关闭连接  </span><br><span class="line">    close(connectfd);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译服务端和客户端的代码：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqXBTTjgQPl0KLGKMq7hAz9mod0RRYpjI9AXksu0CB1qmJDJN2aSMwPg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>先启用服务端：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqia1WLRBYhBiaU7XbDCHsGKWpIibs5WdibLJy6w0G9Oec7dqkw6cMpLKnoQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>然后用 tcpdump 工具开始抓包，命令如下：</p><p>tcpdump -i lo tcp and port 8888 -s0 -w &#x2F;home&#x2F;tcp_close.pcap  </p><p>然后启用客户端，可以看到，与服务端连接成功后，发完数据就退出了。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqmnM7Byiagyo5RWxWm3LR58Zb4QdxDUQIJVa7S9GGfanHvlfTUzOBwKg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>此时，服务端的输出：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqSeF6vb50YiatBrEowxgAjYmgfy8liaL0TognAsrse1Dwm0u3GT7CENMw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>接下来，我们来看看抓包的结果。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtq48mB8VKryOjzdqyjjwy32kiakVBpvJPb1EdznqXfU2BicibY5mibccpbrA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>可以看到，TCP 挥手次数是 3 次。</p><p>所以，下面这个结论是没问题的。</p><blockquote><p>结论：当被动关闭方（上图的服务端）在 TCP 挥手过程中，「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制（默认会开启）」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p></blockquote><h5 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h5><p>我们再做一次实验，来看看<strong>关闭 TCP 延迟确认机制，会出现四次挥手吗？</strong></p><p>客户端代码保持不变，服务端代码需要增加一点东西。</p><p>在上面服务端代码中，增加了打开了 TCP_QUICKACK （快速应答）机制的代码，如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqS3Fia1ibn7iaKlicjzuPNeXibEPwKlzv9uJSsZ63RkzEOiadlLtMtic4loFXg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>编译好服务端代码后，就开始运行服务端和客户端的代码，同时用 tcpdump 进行抓包。</p><p>抓包的结果如下，可以看到是四次挥手。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqOQ7DhUPhZMcpfqkTHHh1XMUmic3od3mHibTwKTFgHhthltE0BxNdicAug/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>所以，当被动关闭方（上图的服务端）在 TCP 挥手过程中，「<strong>没有数据要发送」，同时「关闭了 TCP 延迟确认机制」，那么就会是四次挥手。</strong></p><blockquote><p>设置 TCP_QUICKACK 的代码，为什么要放在 read 返回 0 之后？</p></blockquote><p>我也是多次实验才发现，在 bind 之前设置 TCP_QUICKACK 是不生效的，只有在 read 返回 0 的时候，设置 TCP_QUICKACK 才会出现四次挥手。</p><p>网上查了下资料说，设置 TCP_QUICKACK 并不是永久的，所以每次读取数据的时候，如果想要立刻回 ACK，那就得在每次读取数据之后，重新设置 TCP_QUICKACK。</p><p>而我这里的实验，目的是为了当收到客户端的 FIN 报文（第一次挥手）后，立马回 ACK 报文，所以就在 read 返回 0 的时候，设置 TCP_QUICKACK。</p><p>当然，实际应用中，没人会在我这个位置设置 TCP_QUICKACK，因为操作系统都通过 TCP 延迟确认机制帮我们把四次挥手优化成了三次挥手了，这本来就是一件好事呀。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>当被动关闭方在 TCP 挥手过程中，如果「没有数据要发送」，同时「没有开启 TCP_QUICKACK（默认情况就是没有开启，没有开启 TCP_QUICKACK，等于就是在使用 TCP 延迟确认机制）」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</p><p><strong>所以，出现三次挥手现象，是因为 TCP 延迟确认机制导致的。</strong></p><h3 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h3><h3 id="TCP如何保证可靠性"><a href="#TCP如何保证可靠性" class="headerlink" title="TCP如何保证可靠性"></a>TCP如何保证可靠性</h3><h3 id="TCP-拆包沾包原因"><a href="#TCP-拆包沾包原因" class="headerlink" title="TCP 拆包沾包原因"></a>TCP 拆包沾包原因</h3><p>TCP 拆包和沾包现象是由于 TCP 协议的特性以及网络传输过程中的各种因素所导致的。<br>TCP 协议是基于字节流的传输层协议，没有固定的分包边界。发送方将数据分成多个小的数据包进行传输，接收方再将这些数据包组合成完整的数据。在这个过程中，可能会出现拆包和沾包现象。<br>网络传输中的延迟和拥塞会影响数据包发送的速度和到达接收方的顺序。这可能导致数据包的拆分和组合不规律，从而出现拆包和沾包现象。<br>接收方的缓冲区大小限制。当接收方的缓冲区不足以容纳一个完整的数据包时，可能会将数据包拆分成多个部分，导致拆包现象。<br>为了解决 TCP 拆包和沾包的问题，可以采用以下方法：<br>在应用层实现数据包的边界识别，例如通过添加包头，包头中包含数据包长度等信息，使得接收方能够准确地将数据包进行拼接。<br>使用固定长度的数据包或者特殊的分隔符，以便于接收方识别数据包的边界。<br>使用更高级的传输层协议，如 WebSocket，它在 TCP 基础上增加了数据帧的概念，可以更好地解决拆包和沾包问题。</p><h3 id="TCP粘包问题怎么解决"><a href="#TCP粘包问题怎么解决" class="headerlink" title="TCP粘包问题怎么解决"></a>TCP粘包问题怎么解决</h3><ul><li><p>答：特殊标记</p></li><li><p>追问：打断，如果使用特殊标记解决会遇到什么问题</p></li><li><p>答：正文转义字符</p></li></ul><p><strong>补充：</strong></p><p>1、固定长度的消息</p><p>这种是最简单方法，即每个用户消息都是固定长度的，比如规定一个消息的长度是 64 个字节，当接收方接满 64 个字节，就认为这个内容是一个完整且有效的消息。</p><p>但是这种方式灵活性不高，实际中很少用。</p><p>2、特殊字符作为边界</p><p>我们可以在两个用户消息之间插入一个特殊的字符串，这样接收方在接收数据时，读到了这个特殊字符，就把认为已经读完一个完整的消息。</p><p>HTTP 是一个非常好的例子。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeAuWVqVBTyJ8LzTIjpaUQ9QzbZBW2SaM2whfW9cXicKVPEw0Md73ibUf4BF1nOSqRW3dvpUA0e2oOQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>图片</p><p>HTTP 通过设置回车符、换行符作为 HTTP 报文协议的边界。</p><p>有一点要注意，这个作为边界点的特殊字符，如果刚好消息内容里有这个特殊字符，我们要对这个字符转义，避免被接收方当作消息的边界点而解析到无效的数据。</p><p>3、自定义消息结构</p><p>我们可以自定义一个消息结构，由包头和数据组成，其中包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大。</p><p>比如这个消息结构体，首先 4 个字节大小的变量来表示数据长度，真正的数据则在后面。</p><p><code>struct &#123;        u_int32_t message_length;        char message_data[];    &#125; message;   </code></p><p>当接收方接收到包头的大小（比如 4 个字节）后，就解析包头的内容，于是就可以知道数据的长度，然后接下来就继续读取数据，直到读满数据的长度，就可以组装成一个完整到用户消息来处理了。</p><h3 id="输入网址后发生了什么？"><a href="#输入网址后发生了什么？" class="headerlink" title="输入网址后发生了什么？"></a>输入网址后发生了什么？</h3><p>应用层 DNS 解析，传输层 TCP 连接，网络层 IP，数据链路 MAC，真实物理层，接收到之后再一层层扒皮。</p><h3 id="http报文长度判断"><a href="#http报文长度判断" class="headerlink" title="http报文长度判断"></a>http报文长度判断</h3><h3 id="udp为啥不可靠性。"><a href="#udp为啥不可靠性。" class="headerlink" title="udp为啥不可靠性。"></a>udp为啥不可靠性。</h3><h3 id="服务端挂了，客户端的-TCP-连接会发生什么？"><a href="#服务端挂了，客户端的-TCP-连接会发生什么？" class="headerlink" title="服务端挂了，客户端的 TCP 连接会发生什么？"></a>服务端挂了，客户端的 TCP 连接会发生什么？</h3><p>如果「服务端挂掉」指的是「<strong>服务端进程崩溃</strong>」，那么这个读者猜的想法是对的，服务端的进程在发生崩溃的时候，内核会发送 FIN 报文，与客户端进行四次挥手。</p><p>但是，如果「服务端挂掉」指的是「<strong>服务端主机宕机</strong>」，那么是不会发生四次挥手的，具体后续会发生什么？还要看客户端会不会发送数据？</p><ul><li><p>如果客户端会发送数据，由于服务端已经不存在，客户端的数据报文会超时重传，当重传次数达到一定阈值后，会断开 TCP 连接；</p></li><li><p>如果客户端一直不会发送数据，再看客户端有没有开启 TCP keepalive 机制？</p></li><li><p>如果有开启，客户端在一段时间后，检测到服务端的 TCP 连接已经不存在，则会断开自身的 TCP 连接；</p></li><li><p>如果没有开启，客户端的 TCP 连接会一直存在，并不会断开。</p></li></ul><h3 id="详细介绍一下TCP的四次挥手机制，为什么要有TIME-WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE-WAIT状态如何解决"><a href="#详细介绍一下TCP的四次挥手机制，为什么要有TIME-WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE-WAIT状态如何解决" class="headerlink" title="详细介绍一下TCP的四次挥手机制，为什么要有TIME_WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE_WAIT状态如何解决"></a>详细介绍一下TCP的四次挥手机制，为什么要有TIME_WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE_WAIT状态如何解决</h3><p>当客户端要服务器断开连接时，客户端 TCP 会向服务器发送一个特殊的报文段，该报文段的 FIN 标志位会被置1，接着服务器会向客户端发送一个确认报文段。然后服务器也会客户端发送一个 FIN 标志位为1的终止报文段，随后客户端回送一个确认报文段，服务器立即断开连接。客户端等待一段时间后也断开连接。</p><p>其实四次挥手的过程是很容易理解的，由于 TCP 协议是全双工的，也就是说客户端和服务端都可以发起断开连接。两边各发起一次断开连接的申请，加上各自的两次确认，看起来就像执行了四次挥手。</p><p>为什么要有 TIME_WAIT 状态？因为客户端最后向服务器发送的确认 ACK 是有可能丢失的，当出现超时，服务端会再次发送 FIN 报文段，如果客户端已经关闭了就收不到了。还有一点是避免新旧连接混杂。</p><p>大量 CLOSE_WAIT 表示程序出现了问题，对方的 socket 已经关闭连接，而我方忙于读或写没有及时关闭连接，需要检查代码，特别是释放资源的代码，或者是处理请求的线程配置</p><p>\3. TIME_WAIT状态<br>    经过前面的铺垫，终于要讲到与本文主题相关的内容了。 ^_^<br>    从TCP状态迁移图可知，只有首先调用close()发起主动关闭的一方才会进入TIME_WAIT状态，而且是必须进入（图中左下角所示的3条状态迁移线最终均要进入该状态才能回到初始的CLOSED状态）。<br>    从图中还可看到，进入TIME_WAIT状态的TCP连接需要经过2MSL才能回到初始状态，其中，MSL是指Max<br>Segment Lifetime，即数据包在网络中的最大生存时间。每种TCP协议的实现方法均要指定一个合适的MSL值，如RFC1122给出的建议值为2分钟，又如Berkeley体系的TCP实现通常选择30秒作为MSL值。这意味着TIME_WAIT的典型持续时间为1-4分钟。<br>    TIME_WAIT状态存在的原因主要有两点：<br>    1）为实现TCP这种全双工（full-duplex）连接的可靠释放<br>    参考本文前面给出的TCP释放连接4次挥手示意图，假设发起active close的一方（图中为client）发送的ACK（4次交互的最后一个包）在网络中丢失，那么由于TCP的重传机制，执行passiveclose的一方（图中为server）需要重发其FIN，在该FIN到达client（client是active close发起方）之前，client必须维护这条连接的状态（尽管它已调用过close），具体而言，就是这条TCP连接对应的（local_ip, local_port）资源不能被立即释放或重新分配。直到romete peer重发的FIN达到，client也重发ACK后，该TCP连接才能恢复初始的CLOSED状态。如果activeclose方不进入TIME_WAIT以维护其连接状态，则当passive close方重发的FIN达到时，active close方的TCP传输层会以RST包响应对方，这会被对方认为有错误发生（而事实上，这是正常的关闭连接过程，并非异常）。<br>    2）为使旧的数据包在网络因过期而消失<br>    为说明这个问题，我们先假设TCP协议中不存在TIME_WAIT状态的限制，再假设当前有一条TCP连接：(local_ip, local_port, remote_ip,remote_port)，因某些原因，我们先关闭，接着很快以相同的四元组建立一条新连接。本文前面介绍过，TCP连接由四元组唯一标识，因此，在我们假设的情况中，TCP协议栈是无法区分前后两条TCP连接的不同的，在它看来，这根本就是同一条连接，中间先释放再建立的过程对其来说是“感知”不到的。这样就可能发生这样的情况：前一条TCP连接由local peer发送的数据到达remote peer后，会被该remot peer的TCP传输层当做当前TCP连接的正常数据接收并向上传递至应用层（而事实上，在我们假设的场景下，这些旧数据到达remote peer前，旧连接已断开且一条由相同四元组构成的新TCP连接已建立，因此，这些旧数据是不应该被向上传递至应用层的），从而引起数据错乱进而导致各种无法预知的诡异现象。作为一种可靠的传输协议，TCP必须在协议层面考虑并避免这种情况的发生，这正是TIME_WAIT状态存在的第2个原因。<br>    具体而言，local peer主动调用close后，此时的TCP连接进入TIME_WAIT状态，处于该状态下的TCP连接不能立即以同样的四元组建立新连接，即发起active close的那方占用的local port在TIME_WAIT期间不能再被重新分配。由于TIME_WAIT状态持续时间为2MSL，这样保证了旧TCP连接双工链路中的旧数据包均因过期（超过MSL）而消失，此后，就可以用相同的四元组建立一条新连接而不会发生前后两次连接数据错乱的情况。</p><p>另一比较深入的说法</p><p>TIME_WAIT状态的存在有两个理由：（1）让4次握手关闭流程更加可靠；4次握手的最后一个ACK是是由主动关闭方发送出去的，若这个ACK丢失，被动关闭方会再次发一个FIN过来。若主动关闭方能够保持一个2MSL的TIME_WAIT状态，则有更大的机会让丢失的ACK被再次发送出去。（2）防止lost duplicate对后续新建正常链接的传输造成破坏。lost duplicate在实际的网络中非常常见，经常是由于路由器产生故障，路径无法收敛，导致一个packet在路由器A，B，C之间做类似死循环的跳转。IP头部有个TTL，限制了一个包在网络中的最大跳数，因此这个包有两种命运，要么最后TTL变为0，在网络中消失；要么TTL在变为0之前路由器路径收敛，它凭借剩余的TTL跳数终于到达目的地。但非常可惜的是TCP通过超时重传机制在早些时候发送了一个跟它一模一样的包，并先于它达到了目的地，因此它的命运也就注定被TCP协议栈抛弃。另外一个概念叫做incarnation connection，指跟上次的socket pair一摸一样的新连接，叫做incarnation of previous connection。lost duplicate加上incarnation connection，则会对我们的传输造成致命的错误。大家都知道TCP是流式的，所有包到达的顺序是不一致的，依靠序列号由TCP协议栈做顺序的拼接；假设一个incarnation connection这时收到的seq&#x3D;1000, 来了一个lost duplicate为seq&#x3D;1000, len&#x3D;1000, 则tcp认为这个lost duplicate合法，并存放入了receive buffer，导致传输出现错误。通过一个2MSL TIME_WAIT状态，确保所有的lost duplicate都会消失掉，避免对新连接造成错误。</p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>从上面的图可以看到滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。</p><p>可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。</p><p>接着就讲讲什么是流量控制窗口，什么是拥塞控制窗口。</p><p>先讲流量控制：</p><p>TCP 是全双工的，客户端和服务器均可作为发送方或接收方，我们现在假设一个发送方向接收方发送数据的场景来讲解流量控制。首先我们的接收方有一块接收缓存，当数据来到时会先把数据放到缓存中，上层应用等缓存中有数据时就会到缓存中取数据。假如发送方没有限制地不断地向接收方发送数据，接收方的应用程序又没有及时把接收缓存中的数据读走，就会出现缓存溢出，数据丢失的现象，为了解决这个问题，我们引入流量控制窗口。</p><p>假设应用程序最后读走的数据序号是 lastByteRead，接收缓存中接收到的最后一个数据序号是 lastByteRcv，接收缓存的大小为 RcvSize，那么必须要满足 lastByteRcv - lastByteRead &lt;&#x3D; RcvSize 才能保证接收缓存不会溢出，所以我们定义流量窗口为接收缓存剩余的空间，也就是Rcv &#x3D; RcvSize - (lastByteRcv - lastByteRead)。只要接收方在响应 ACK 的时候把这个窗口的值带给发送方，发送方就能知道接收方的接收缓存还有多大的空间，进而设置滑动窗口的大小。</p><p>接着讲解拥塞控制：</p><p>拥塞控制是指发送方先设置一个小的窗口值作为发送速率，当成功发包并接收到ACK时，便以指数速率增大发送窗口的大小，直到遇到丢包（超时&#x2F;三个冗余ACK），才停止并调整窗口的大小。这么做能最大限度地利用带宽，又不至于让网络环境变得太过拥挤。</p><p>最终滑动窗口的值将设置为流量控制窗口和拥塞控制窗口中的较小值。</p><p>Q: 编写 TCP&#x2F;SOCK_STREAM 服务程序时，SO_REUSEADDR到底什么意思？</p><p>A: 这个套接字选项通知内核，如果端口忙，但TCP状态位于 TIME_WAIT ，可以重用端口。如果端口忙，而TCP状态位于其他状态，重用端口时依旧得到一个错误信息， 指明”地址已经使用中”。如果你的服务程序停止后想立即重启，而新套接字依旧 使用同一端口，此时 SO_REUSEADDR 选项非常有用。必须意识到，此时任何非期 望数据到达，都可能导致服务程序反应混乱，不过这只是一种可能，事实上很不可能。</p><p>　CLOSE_WAIT： 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。</p><h3 id="UDP客户端可以CONNECT不，那CONNECT和不CONNECT有啥区别"><a href="#UDP客户端可以CONNECT不，那CONNECT和不CONNECT有啥区别" class="headerlink" title="UDP客户端可以CONNECT不，那CONNECT和不CONNECT有啥区别"></a>UDP客户端可以CONNECT不，那CONNECT和不CONNECT有啥区别</h3><p>在UDP协议中，没有真正的连接（connection）的概念，因此UDP客户端不能像TCP客户端那样通过<code>connect()</code>函数来建立连接。</p><p>使用<code>connect()</code>函数的主要目的是为了简化代码和提高安全性。当TCP客户端调用<code>connect()</code>函数时，操作系统会自动为其分配一个socket文件描述符，并将该socket与远程服务器的IP地址和端口号绑定起来。这样，在之后的数据通信中，客户端只需要向该socket发送数据即可，而不必每次都指定远程服务器的IP地址和端口号。另外，<code>connect()</code>函数还可以对发送的数据进行一些验证和过滤，以提高数据传输的安全性。</p><p>在UDP协议中，由于不存在真正的连接，因此也就不需要使用<code>connect()</code>函数来建立连接。UDP客户端每次发送数据时，都需要指定远程服务器的IP地址和端口号，这样才能确保数据能够正确地被发送到目标地址。因此，在UDP协议中，没有<code>connect()</code>函数的概念。</p><p>总之，UDP客户端没有连接（connection）的概念，因此不能像TCP客户端那样使用<code>connect()</code>函数来建立连接。每次发送数据时，UDP客户端需要显式地指定远程服务器的IP地址和端口号。如果需要简化代码和提高安全性，可以使用其他技术手段，例如使用加密算法和数字证书来保证数据传输的安全性。</p><h3 id="5-讲一下HTTP与HTTPS的区别"><a href="#5-讲一下HTTP与HTTPS的区别" class="headerlink" title="5. 讲一下HTTP与HTTPS的区别"></a>5. 讲一下HTTP与HTTPS的区别</h3><p>HTTP和HTTPS的主要区别在于HTTP协议传递的是明文数据，而HTTPS传递的是加密过的数据，也就是说HTTPS更具有安全性。也正由HTTPS需要保证安全性，所以它的性能要比HTTP差一点。</p><p>单说安全性肯定是不够的，我打算扩展讲一下HTTPS是怎么解决安全性问题的，通过这些HTTP没有机制，反映出HTTPS与HTTP的区别。下面尝试把HTTPS加密的过程推导出来。推导过程不涉及复杂的实现细节：</p><h4 id="如何安全地进行数据传输？"><a href="#如何安全地进行数据传输？" class="headerlink" title="如何安全地进行数据传输？"></a>如何安全地进行数据传输？</h4><p>假设现在A和B要进行安全的通信，那么究竟怎样才算是安全的通信？很自然地会想到：A和B之间传递数据，这些数据只有A和B才看得懂，中间人就算截取了信息但也看不懂，这才算得上安全。</p><h4 id="安全通信的处理手段："><a href="#安全通信的处理手段：" class="headerlink" title="安全通信的处理手段："></a>安全通信的处理手段：</h4><p>为了能让A和B才能看懂，就必须要对数据进行加密，而且首先想到的就是对称加密。对称加密的意思是A和B各持有一个相同的密钥，它们传递信息时会用密钥给信息加密，在消息到达端给消息解密，完成安全通信。</p><p>在对称加密中又会涉及到加密算法的选择问题。现实世界中，通常是多个客户端面向一个服务器的情况，不可能让每个客户端和服务器之间都采用相同的加密算法，如果是这样那和没加密差不多。所以注定每个客户端和服务器之间都会采用不同的加密方式。</p><h4 id="如何让每个客户端与服务器之间都采用不同的加密方式？"><a href="#如何让每个客户端与服务器之间都采用不同的加密方式？" class="headerlink" title="如何让每个客户端与服务器之间都采用不同的加密方式？"></a>如何让每个客户端与服务器之间都采用不同的加密方式？</h4><p>要想对不同的机器使用不同的加密方式，最直接想到的就是使用随机数。也就说客户端和服务器之间每次都基于一个随机数产生加密算法。（具体实现时为了保证随机，用到还不止一个随机数）</p><p>这个产生加密算法的过程称之为协商，现在问题是协商的过程是透明的，也就是说中间人可以截获协商的过程，从而知道我们的加密方式。为了解决这个问题，我们需要对协商的过程进行加密。</p><h4 id="如何对协商的过程进行加密？"><a href="#如何对协商的过程进行加密？" class="headerlink" title="如何对协商的过程进行加密？"></a>如何对协商的过程进行加密？</h4><p>之所以能来到这一步，是因为我们一开始就选择使用了对称加密，也就说一开始的对称加密导致了现在的问题，所以这时我们不能再使用对称加密了，否则会陷入死循环。</p><p>在密码学领域，还有一种加密过程叫非对称加密，它的逻辑是这样的：通信双方一方持有私钥，一方持有公钥，经过私钥加密的信息，都能通过公钥进行解密。但是经过公钥加密的数据，只有私钥可以解密。</p><p>按照非对称加密的规则，我们让服务器持有私钥，让客户端持有公钥。这样就能保证客户端给服务器发送消息的时候是安全的（相反，服务器给客户端发送消息就是不安全的），我们可以把协商时重要的逻辑安排在客户端给服务器发送信息的过程中，从而保证了协商过程的安全性。</p><h4 id="客户端如何获得公钥？"><a href="#客户端如何获得公钥？" class="headerlink" title="客户端如何获得公钥？"></a>客户端如何获得公钥？</h4><p>现在用非对称加密算法解决了协商的安全问题，但是非对称加密的前提是客户端需要获得公钥，这又是一个问题了，客户端与服务器打交道之前是互不知道双方身份的，怎么才能让客户端获得公钥呢？</p><p>也就只有两种办法：</p><ol><li>客户端向服务器要公钥</li><li>客户端向一个远程的公共服务器获取公钥</li></ol><p>方法2显然是不行的，尚且不说多了一个访问节点，如何找到公共服务器的地址也是一个待解决的问题，所以还是使用方法1。</p><p>但是方法1存在一个问题：如果中间人把服务器发送给客户端的公钥调包了怎么办？也就是说客户端无法知道发送公钥的是否是正真的服务器。</p><h4 id="引入第三方机构解决问题"><a href="#引入第三方机构解决问题" class="headerlink" title="引入第三方机构解决问题"></a>引入第三方机构解决问题</h4><p>客户端无法辨识服务端和中间人的问题称为“身份验证”问题，也就是说我们需要为服务器向客户端发送公钥的过程进行加密。</p><p>这下完了，之前我们因遇到对称加密的瓶颈选择了非对称加密，现在使用非对称加密也遇到了瓶颈。显然这两种加密方式都是不可用的了，否则会再次陷入死循环。</p><p>接下来我们只好通过第三方机构的介入，解决这个问题。首先我们自己保存有第三方权威机构的公钥，然后第三方机构使用私钥对服务器将要发送给客户端的公钥进行加密，客户端接收到这个经加密的公钥后（数字证书），就能通过自己保存的第三方机构公钥进行解密。</p><blockquote><p>到这里为止，我们解释了HTTPS中使用到的对称加密，非对称加密，CA，数字证书的概念，但是还差一个叫数字签名的概念没有解释。</p></blockquote><p>在现实生活中，CA不单止会给我们正常公司发放证书，还会给中间人的坏公司发放证书，如果中间人把发放的证书调包了怎么办？这时我们仍能用CA的私钥进行解密，但是证书已经被调包了。</p><p>那么客户端怎样验证证书的真伪呢？答案是证书本身会告诉客户端如何辨认真伪。比方说证书上面有一个证书编号，还有一个如何计算证书编号的方法，客户端可以根据计算证书编号的方法计算出自己要获得的证书的编号，然后把这个编号和证书上的编号进行比对，如果一样证明没有被调包。</p><p>这里的证书编号指的就是数字签名，证书指的就是数字证书。</p><p>总结一下HTTPS：HTTPS想要保证客户端与服务器之间的通信安全，就得使用对称加密算法进行加密。协商对称加密算法的过程通过非对称加密算法来保证。在非对称加密算法中，客户端获得公钥的过程需要第三方机构（CA）通过颁发数字证书保证安全性。</p><p>总得来说通过这一系列机制协商出了一个对称加密算法后，客户端与服务器之间就能通过该算法进行安全的通信了</p><ul><li><p>TCP消息和UDP的主要区别</p></li><li><p>Epoll比起select&#x2F;poll，主要优化点在哪里？</p></li><li><p>Post和Get有什么区别？</p></li><li><p>接收时，如何确定一个HTTP消息已经读取完毕</p></li><li><p>从一个命令行下载一个网页，会涉及哪些网络协议？（DNS，TCP，HTTP，如果有ARP和SSL更好）</p></li><li><p>HTTP&#x2F;2主要优化点</p></li><li><p>\1. C++中具体是怎么实现多态的？构造函数可以是虚函数吗？构造函数可以调用虚函数吗？<br>编译器发现一个类中有虚函数，便会立即为此类生成虚函数表 vtable。虚函数表的各表项为指向对应虚函数的指针。<br>构造函数不可以是虚函数，也不能调用虚函数，因为此时虚函数表还未生成。</p><p>\2. 操作系统中进程、线程的区别，进程间通信通信的方式？<br>进程： 进程是资源（CPU、内存等）分配的基本单位，具有一定功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。<br>线程：线程是进程的一个实体，是独立运行和独立调度的基本单位（CPU上真正运行的是线程）。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。<br>进程通信的方式：管道，有名管道，信号量，消息队列，信号,共享内存,套接字.</p><p>\3. python中的多线程能充分利用多核CPU吗？如果要充分利用的话应该怎么做？<br>python的多线程不能充分利用多CPU，因为python解释器有一个全局锁；<br>要想利用多CPU只能使用多进程模型，或者使用C++</p><p>\4. http属于OSI分层协议中的哪一层？TCP&#x2F;UDP是属于哪一层？TCP的三次握手的过程是怎样的？为什么要有三次握手？<br>http属于应用层，TCP&#x2F;UDP属于传输层；</p><p>假设 A 为客户端，B 为服务器端。</p><p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p><p>A 向 B 发送连接请求报文，SYN&#x3D;1，ACK&#x3D;0，选择一个初始的序号 x。</p><p>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN&#x3D;1，ACK&#x3D;1，确认号为 x+1，同时也选择一个初始的序号 y。</p><p>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</p><p>B 收到 A 的确认后，连接建立。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><p>\5. TCP怎么实现可靠传输的？</p><p>TCP滑动窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。<br>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。<br>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p></li></ul><h3 id="不同地区的用户的请求怎么打到附近的地区呢？"><a href="#不同地区的用户的请求怎么打到附近的地区呢？" class="headerlink" title="不同地区的用户的请求怎么打到附近的地区呢？"></a>不同地区的用户的请求怎么打到附近的地区呢？</h3><p>答：讲了CDN</p><p><strong>补充：</strong></p><p>CDN 将内容资源分发到位于多个地理位置机房中的服务器上，这样我们在访问内容资源的时候，不用访问源服务器。而是直接访问离我们最近的 CDN 节点 ，这样一来就省去了长途跋涉的时间成本，从而实现了网络加速。</p><p>找到离用户最近的 CDN 节点是由 CDN 的<strong>全局负载均衡器（<em>Global Sever Load Balance，GSLB</em>）</strong>负责的。</p><p>那 GSLB 是在什么时候起作用的呢？在回答这个问题前，我们先来看看在没有 CDN 的情况下，访问域名时发生的事情。</p><p>在没有 CDN 的情况下，当我们访问域名时，DNS 服务器最终会返回源服务器的地址。</p><p>比如，当我们在浏览器输入 <a href="http://www.xiaolin.com/">www.xiaolin.com</a> 域名后，在本地 host 文件找不到域名时，客户端就会访问本地 DNS 服务器。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfg8KBLwPAE6ktepRPahjT7TyX6BwTp8IcDsOAkGvvWiaUcg2dQZc3ExHZyHr2ngzib5HfeMqvHN35g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>图片</p><p>这时候:</p><ul><li><p>如果本地 DNS 服务器有缓存该网站的地址，则直接返回网站的地址；</p></li><li><p>如果没有就通过递归查询的方式，先请求根 DNS，根 DNS 返回顶级 DNS（.com）的地址；再请求 .com 顶级 DNS 得到 xiaolin.com 的域名服务器地址，再从 xiaolin.com 的域名服务器中查询到 <a href="http://www.xiaolin.com/">www.xiaolin.com</a> 对应的 IP 地址，然后返回这个 IP 地址，同时本地 DNS 缓存该 IP 地址，这样下一次的解析同一个域名就不需要做 DNS 的迭代查询了。</p></li></ul><p><strong>但加入 CDN 后就不一样了</strong>。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfg8KBLwPAE6ktepRPahjT7Ve7FiaAianuWiaZic1anXPYAST8dccKtcwJ5uzia8ZqicxiciaWfGOlgyDpVWg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>图片</p><p>会在 xiaolin.com 这个 DNS 服务器上，设置一个 CNAME 别名，指向另外一个域名 <a href="http://www.xiaolin.cdn.com,返回给本地/">www.xiaolin.cdn.com，返回给本地</a> DNS 服务器。</p><p>接着继续解析该域名，这个时候访问的就是 xiaolin.cdn.com 这台 CDN 专用的 DNS 服务器，在这个服务器上，又会设置一个 CNAME，指向另外一个域名，这次指向的就是 CDN 的 GSLB。</p><p>接着，本地 DNS 服务器去请求 CDN 的 GSLB 的域名，GSLB 就会为用户选择一台合适的 CDN 节点提供服务，选择的依据主要有以下几点：</p><ul><li><p>看用户的 IP 地址，查表得知地理位置，找相对最近的 CDN 节点；</p></li><li><p>看用户所在的运营商网络，找相同网络的 CDN 节点；</p></li><li><p>看用户请求 URL，判断哪一台服务器上有用户所请求的资源；</p></li><li><p>查询 CDN 节点的负载情况，找负载较轻的节点；</p></li></ul><p>GSLB 会基于以上的条件进行综合分析后，找出一台最合适的 CDN 节点，并返回该 CDN 节点的 IP 地址给本地 DNS 服务器，然后本地 DNS 服务器缓存该 IP 地址，并将 IP 返回给客户端，客户端去访问这个 CDN 节点，下载资源。</p><h3 id="TCP的close-wait在哪端，如果我们场景中出现了大量的close-wait，你觉得要怎么排查"><a href="#TCP的close-wait在哪端，如果我们场景中出现了大量的close-wait，你觉得要怎么排查" class="headerlink" title="TCP的close_wait在哪端，如果我们场景中出现了大量的close_wait，你觉得要怎么排查"></a>TCP的close_wait在哪端，如果我们场景中出现了大量的close_wait，你觉得要怎么排查</h3><p>答：被动方，代码逻辑有问题，没close</p><p><strong>补充：</strong></p><p>CLOSE_WAIT 状态是「被动关闭方」才会有的状态，而且如果「被动关闭方」没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态。</p><p>所以，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接</strong>。</p><p>那什么情况会导致服务端的程序没有调用 close 函数关闭连接？这时候通常需要排查代码。</p><p>我们先来分析一个普通的 TCP 服务端的流程：</p><ol><li><p>创建服务端 socket，bind 绑定端口、listen 监听端口</p></li><li><p>将服务端 socket 注册到 epoll</p></li><li><p>epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket</p></li><li><p>将已连接的 socket 注册到 epoll</p></li><li><p>epoll_wait 等待事件发生</p></li><li><p>对方连接关闭时，我方调用 close</p></li></ol><p>可能导致服务端没有调用 close 函数的原因，如下。</p><p><strong>第一个原因</strong>：第 2 步没有做，没有将服务端 socket 注册到 epoll，这样有新连接到来时，服务端没办法感知这个事件，也就无法获取到已连接的 socket，那服务端自然就没机会对 socket 调用 close 函数了。</p><p>不过这种原因发生的概率比较小，这种属于明显的代码逻辑 bug，在前期 read view 阶段就能发现的了。</p><p><strong>第二个原因</strong>：第 3 步没有做，有新连接到来时没有调用 accpet 获取该连接的 socket，导致当有大量的客户端主动断开了连接，而服务端没机会对这些 socket 调用 close 函数，从而导致服务端出现大量 CLOSE_WAIT 状态的连接。</p><p>发生这种情况可能是因为服务端在执行 accpet 函数之前，代码卡在某一个逻辑或者提前抛出了异常。</p><p><strong>第三个原因</strong>：第 4 步没有做，通过 accpet 获取已连接的 socket 后，没有将其注册到 epoll，导致后续收到 FIN 报文的时候，服务端没办法感知这个事件，那服务端就没机会调用 close 函数了。</p><p>发生这种情况可能是因为服务端在将已连接的 socket 注册到 epoll 之前，代码卡在某一个逻辑或者提前抛出了异常。之前看到过别人解决 close_wait 问题的实践文章，感兴趣的可以看看：<a href="https://mp.weixin.qq.com/s?__biz=MzU3Njk0MTc3Ng==&mid=2247486020&idx=1&sn=f7cf41aec28e2e10a46228a64b1c0a5c&scene=21#wechat_redirect">一次 Netty 代码不健壮导致的大量 CLOSE_WAIT 连接原因分析</a></p><p><strong>第四个原因</strong>：第 6 步没有做，当发现客户端关闭连接后，服务端没有执行 close 函数，可能是因为代码漏处理，或者是在执行 close 函数之前，代码卡在某一个逻辑，比如发生死锁等等。</p><p>可以发现，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，通常都是代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用 close</strong>。</p><h3 id="服务端出现大量-TIME-WAIT-状态的原因有哪些？"><a href="#服务端出现大量-TIME-WAIT-状态的原因有哪些？" class="headerlink" title="服务端出现大量 TIME_WAIT 状态的原因有哪些？"></a>服务端出现大量 TIME_WAIT 状态的原因有哪些？</h3><p>我们先来看一下 TCP 四次挥手的流程吧，看看 TIME_WAIT 状态发生在哪一个阶段。</p><p>下面这个图，是由「客户端」作为「主动关闭方」的 TCP 四次挥手的流程。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdWrrgBYLP5VsrraBM1qVuzgibl5CZs9FKwxdu2j2In9NPx4W5wC2e91AjbyLlwL7jvEY5NNjuRr5Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>TCP 四次挥手的流程</p><p>从上面我们可以知道，<strong>TIME_WAIT 状态是「主动关闭连接方」才会出现的状态</strong>。而且 TIME_WAIT 状态会持续 2MSL 时间才会进入到 close 状态。在 Linux 上 2MSL 的时长是 60 秒，也就是说<strong>停留在 TIME_WAIT 的时间为固定的 60 秒</strong>。</p><p>为什么需要 TIME_WAIT 状态？（老八股文了，帮大家复习一波）主要有两个原因：</p><ul><li><p><strong>保证「被动关闭连接」的一方，能被正确的关闭</strong>。TCP 协议在关闭连接的四次挥手中，在主动关闭方发送的最后一个 ACK 报文，有可能丢失，这时被动方会重新发 FIN 报文, 如果这时主动方处于 CLOSE 状态 ，就会响应 RST 报文而不是 ACK 报文。所以主动方要处于 TIME_WAIT 状态，而不能是 CLOSE。</p></li><li><p><strong>防止历史连接中的数据，被后面相同四元组的连接错误的接收</strong>。TCP 报文可能由于路由器异常而 “迷路”，在迷途期间，TCP 发送端可能因确认超时而重发这个报文，迷途的报文在路由器修复后也会被送到最终目的地，这个原来的迷途报文就称为 lost duplicate。在关闭一个 TCP 连接后，马上又重新建立起一个相同的 IP 地址和端口之间的 TCP 连接，后一个连接被称为前一个连接的化身，那么有可能出现这种情况，前一个连接的迷途重复报文在前一个连接终止后出现，从而被误解成从属于新的化身。为了避免这个情 况， TIME_WAIT 状态需要持续 2MSL，因为这样就可以保证当成功建立一个 TCP 连接的时候，来自连接先前化身的重复报文已经在网络中消逝。</p></li></ul><p>很多人误解以为只有客户端才会有 TIME_WAIT 状态，这是不对的。TCP 是全双工协议，哪一方都可以先关闭连接，所以哪一方都可能会有 TIME_WAIT 状态。</p><p>总之记住，<strong>谁先关闭连接的，它就是主动关闭方，那么 TIME_WAIT 就会出现在主动关闭方</strong>。</p><h4 id="什么场景下服务端会主动断开连接呢？"><a href="#什么场景下服务端会主动断开连接呢？" class="headerlink" title="什么场景下服务端会主动断开连接呢？"></a>什么场景下服务端会主动断开连接呢？</h4><p>如果服务端出现大量的 TIME_WAIT 状态的 TCP 连接，就是<strong>说明服务端主动断开了很多 TCP 连接</strong>。</p><p>问题来了，<strong>什么场景下服务端会主动断开连接呢？</strong></p><ul><li><p>第一个场景：HTTP 没有使用长连接</p></li><li><p>第二个场景：HTTP 长连接超时</p></li><li><p>第三个场景：HTTP 长连接的请求数量达到上限</p></li></ul><p>接下来，分别介绍下。</p><h5 id="第一个场景：HTTP-没有使用长连接"><a href="#第一个场景：HTTP-没有使用长连接" class="headerlink" title="第一个场景：HTTP 没有使用长连接"></a>第一个场景：HTTP 没有使用长连接</h5><p>我们先来看看 HTTP 长连接（Keep-Alive）机制是怎么开启的。</p><p>在 HTTP&#x2F;1.0 中默认是关闭的，如果浏览器要开启 Keep-Alive，它必须在请求的 header 中添加：</p><p><code>Connection: Keep-Alive   </code></p><p>然后当服务器收到请求，作出回应的时候，它也被添加到响应中 header 里：</p><p><code>Connection: Keep-Alive   </code></p><p>这样做，TCP 连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个 TCP 连接。这一直继续到客户端或服务器端提出断开连接。</p><p><strong>从 HTTP&#x2F;1.1 开始， 就默认是开启了 Keep-Alive</strong>，现在大多数浏览器都默认是使用 HTTP&#x2F;1.1，所以 Keep-Alive 都是默认打开的。一旦客户端和服务端达成协议，那么长连接就建立好了。</p><p>如果要关闭 HTTP Keep-Alive，需要在 HTTP 请求或者响应的 header 里添加 <code>Connection:close</code> 信息，也就是说，<strong>只要客户端和服务端任意一方的 HTTP header 中有 <code>Connection:close</code> 信息，那么就无法使用 HTTP 长连接的机制</strong>。</p><p>关闭 HTTP 长连接机制后，每次请求都要经历这样的过程：建立 TCP -&gt; 请求资源 -&gt; 响应资源 -&gt; 释放连接，那么此方式就是 <strong>HTTP 短连接</strong>，如下图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdWrrgBYLP5VsrraBM1qVuz6Mbyn1OB5sHE3A6HarVbjvNt8Wuoz4bIktXZ4uAQicFlHtVnEibfviaAg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>HTTP 短连接</p><p>在前面我们知道，只要任意一方的 HTTP header 中有 <code>Connection:close</code> 信息，就无法使用 HTTP 长连接机制，这样在完成一次 HTTP 请求&#x2F;处理后，就会关闭连接。</p><p>问题来了，<strong>这时候是客户端还是服务端主动关闭连接呢？</strong></p><p>在 RFC 文档中，并没有明确由谁来关闭连接，<strong>请求和响应的双方都可以主动关闭 TCP 连接。</strong></p><p>不过，<strong>根据大多数 Web 服务的实现，不管哪一方禁用了 HTTP Keep-Alive，都是由服务端主动关闭连接</strong>，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p><blockquote><p>客户端禁用了 HTTP Keep-Alive，服务端开启 HTTP Keep-Alive，谁是主动关闭方？</p></blockquote><p>当客户端禁用了 HTTP Keep-Alive，这时候 HTTP 请求的 header 就会有 <code>Connection:close</code> 信息，这时服务端在发完 HTTP 响应后，就会主动关闭连接。</p><p>为什么要这么设计呢？HTTP 是请求-响应模型，发起方一直是客户端，HTTP Keep-Alive 的初衷是<strong>为客户端后续的请求重用连接</strong>，如果我们<strong>在某次 HTTP 请求-响应模型中，请求的 header 定义了 <code>connection：close</code> 信息，那不再重用这个连接的时机就只有在服务端了</strong>，所以我们在 HTTP 请求-响应这个周期的「末端」关闭连接是合理的。</p><blockquote><p>客户端开启了 HTTP Keep-Alive，服务端禁用了 HTTP Keep-Alive，谁是主动关闭方？</p></blockquote><p>当客户端开启了 HTTP Keep-Alive，而服务端禁用了 HTTP Keep-Alive，这时服务端在发完 HTTP 响应后，服务端也会主动关闭连接。</p><p>为什么要这么设计呢？在服务端主动关闭连接的情况下，只要调用一次 close() 就可以释放连接，剩下的工作由内核 TCP 栈直接进行了处理，整个过程只有一次 syscall；如果是要求 客户端关闭，则服务端在写完最后一个 response 之后需要把这个 socket 放入 readable 队列，调用 select &#x2F; epoll 去等待事件；然后调用一次 read() 才能知道连接已经被关闭，这其中是两次 syscall，多一次用户态程序被激活执行，而且 socket 保持时间也会更长。</p><p>因此，<strong>当服务端出现大量的 TIME_WAIT 状态连接的时候，可以排查下是否客户端和服务端都开启了 HTTP Keep-Alive</strong>，因为任意一方没有开启  HTTP Keep-Alive，都会导致服务端在处理完一个 HTTP 请求后，就主动关闭连接，此时服务端上就会出现大量的 TIME_WAIT 状态的连接。</p><p>针对这个场景下，解决的方式也很简单，让客户端和服务端都开启 HTTP Keep-Alive 机制。</p><h5 id="第二个场景：HTTP-长连接超时"><a href="#第二个场景：HTTP-长连接超时" class="headerlink" title="第二个场景：HTTP 长连接超时"></a>第二个场景：HTTP 长连接超时</h5><p>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p><p>HTTP 长连接可以在同一个 TCP 连接上接收和发送多个 HTTP 请求&#x2F;应答，避免了连接建立和释放的开销。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdWrrgBYLP5VsrraBM1qVuzJOMM2YOyn0hibsGmKnTveXVtdAueyHib140mgZgFCN1kX8LRF4VXexpA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>可能有的同学会问，如果使用了 HTTP 长连接，如果客户端完成一个 HTTP 请求后，就不再发起新的请求，此时这个 TCP 连接一直占用着不是挺浪费资源的吗？</p><p>对没错，所以为了避免资源浪费的情况，web 服务软件一般都会提供一个参数，用来指定 HTTP 长连接的超时时间，比如 nginx 提供的 keepalive_timeout 参数。</p><p>假设设置了 HTTP 长连接的超时时间是 60 秒，nginx 就会启动一个「定时器」，<strong>如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，定时器的时间一到，nginx 就会触发回调函数来关闭该连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接</strong>。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdWrrgBYLP5VsrraBM1qVuz5pHQCUACibMOoaNEuB6JqQHEST9cpyZutary8DxnB1joDHybV0ibWBOw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>HTTP 长连接超时</p><p>当服务端出现大量 TIME_WAIT 状态的连接时，如果现象是有大量的客户端建立完 TCP 连接后，很长一段时间没有发送数据，那么大概率就是因为 HTTP 长连接超时，导致服务端主动关闭连接，产生大量处于 TIME_WAIT 状态的连接。</p><p>可以往网络问题的方向排查，比如是否是因为网络问题，导致客户端发送的数据一直没有被服务端接收到，以至于 HTTP 长连接超时。</p><h5 id="第三个场景：HTTP-长连接的请求数量达到上限"><a href="#第三个场景：HTTP-长连接的请求数量达到上限" class="headerlink" title="第三个场景：HTTP 长连接的请求数量达到上限"></a>第三个场景：HTTP 长连接的请求数量达到上限</h5><p>Web 服务端通常会有个参数，来定义一条 HTTP 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接。</p><p>比如 nginx 的 keepalive_requests 这个参数，这个参数是指一个 HTTP 长连接建立之后，nginx 就会为这个连接设置一个计数器，记录这个 HTTP 长连接上已经接收并处理的客户端请求的数量。<strong>如果达到这个参数设置的最大值时，则 nginx 会主动关闭这个长连接</strong>，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p><p>keepalive_requests 参数的默认值是 100 ，意味着每个 HTTP 长连接最多只能跑 100  次请求，这个参数往往被大多数人忽略，因为当 QPS (每秒请求数) 不是很高时，默认值 100 凑合够用。</p><p>但是，<strong>对于一些 QPS 比较高的场景，比如超过 10000 QPS，甚至达到 30000 , 50000 甚至更高，如果 keepalive_requests 参数值是 100，这时候就 nginx 就会很频繁地关闭连接，那么此时服务端上就会出大量的 TIME_WAIT 状态</strong>。</p><p>针对这个场景下，解决的方式也很简单，调大 nginx 的 keepalive_requests 参数就行。</p><h4 id="TIME-WAIT-状态过多有什么危害？"><a href="#TIME-WAIT-状态过多有什么危害？" class="headerlink" title="TIME_WAIT 状态过多有什么危害？"></a>TIME_WAIT 状态过多有什么危害？</h4><p>过多的 TIME-WAIT 状态主要的危害有两种：</p><ul><li><p>第一是占用系统资源，比如文件描述符、内存资源、CPU 资源等；</p></li><li><p>第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为 <code>32768～61000</code>，也可以通过 <code>net.ipv4.ip_local_port_range</code>参数指定范围。</p></li></ul><p>客户端和服务端 TIME_WAIT 过多，造成的影响是不同的。</p><p><strong>如果客户端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT」都一样的服务端发起连接了，但是被使用的端口，还是可以继续对另外一个服务端发起连接的。具体可以看我这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247517946&idx=1&sn=a3d88d7ac73792c5031ccf8422066f7c&scene=21#wechat_redirect">客户端的端口可以重复使用吗？</a></p><p>因此，客户端（发起连接方）都是和「目的 IP+ 目的 PORT 」都一样的服务端建立连接的话，当客户端的 TIME_WAIT 状态连接过多的话，就会受端口资源限制，如果占满了所有端口资源，那么就无法再跟「目的 IP+ 目的 PORT」都一样的服务端建立连接了。</p><p>不过，即使是在这种场景下，只要连接的是不同的服务端，端口是可以重复使用的，所以客户端还是可以向其他服务端发起连接的，这是因为内核在定位一个连接的时候，是通过四元组（源IP、源端口、目的IP、目的端口）信息来定位的，并不会因为客户端的端口一样，而导致连接冲突。</p><p><strong>如果服务端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接，但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源等。</p><h4 id="如何优化-TIME-WAIT-状态？"><a href="#如何优化-TIME-WAIT-状态？" class="headerlink" title="如何优化 TIME_WAIT 状态？"></a>如何优化 TIME_WAIT 状态？</h4><p>这里给出优化 TIME-WAIT 的几个方式，都是有利有弊：</p><ul><li><p>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；</p></li><li><p>net.ipv4.tcp_max_tw_buckets</p></li><li><p>程序中使用 SO_LINGER ，应用强制使用 RST 关闭。</p></li></ul><p><em>方式一：net.ipv4.tcp_tw_reuse 和 tcp_timestamps</em></p><p>开启 tcp_tw_reuse，则可以<strong>复用处于 TIME_WAIT 的 socket 为新的连接所用</strong>。</p><p>有一点需要注意的是，<strong>tcp_tw_reuse 功能只能用客户端（连接发起方），因为开启了该功能，在调用 connect() 函数时，内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复用。</strong></p><p><code>net.ipv4.tcp_tw_reuse = 1   </code></p><p>使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持，即</p><p><code>net.ipv4.tcp_timestamps=1（默认即为 1）   </code></p><p>这个时间戳的字段是在 TCP 头部的「选项」里，它由一共 8 个字节表示时间戳，其中第一个 4 字节字段用来保存发送该数据包的时间，第二个 4 字节字段用来保存最近一次接收对方发送到达数据的时间。</p><p>由于引入了时间戳，可以使得重复的数据包会因为时间戳过期被自然丢弃，因此 TIME_WAIT 状态才可以被复用。</p><p><em>方式二：net.ipv4.tcp_max_tw_buckets</em></p><p>这个值默认为 18000，<strong>当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接状态重置</strong>，这个方法比较暴力。</p><p><code>net.ipv4.tcp_max_tw_buckets = 18000   </code></p><p><em>方式三：程序中使用 SO_LINGER</em></p><p>我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。</p><p><code>struct linger so_linger;   so_linger.l_onoff = 1;   so_linger.l_linger = 0;   setsockopt(s, SOL_SOCKET, SO_LINGER, &amp;so_linger,sizeof(so_linger));   </code></p><p>如果<code>l_onoff</code>为非 0， 且<code>l_linger</code>值为 0，那么调用<code>close</code>后，会立该发送一个<code>RST</code>标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了<code>TIME_WAIT</code>状态，直接关闭。</p><p>但这为跨越<code>TIME_WAIT</code>状态提供了一个可能，不过是一个非常危险的行为，不值得提倡。</p><p>前面介绍的方法都是试图越过 <code>TIME_WAIT</code>状态的，这样其实不太好。虽然 TIME_WAIT 状态持续的时间是有一点长，显得很不友好，但是它被设计来就是用来避免发生乱七八糟的事情。</p><p>《UNIX网络编程》一书中却说道：<strong>TIME_WAIT 是我们的朋友，它是有助于我们的，不要试图避免这个状态，而是应该弄清楚它</strong>。</p><p><strong>如果服务端要避免过多的 TIME_WAIT 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT</strong>。</p><h3 id="服务端出现大量-CLOSE-WAIT-状态的原因有哪些？"><a href="#服务端出现大量-CLOSE-WAIT-状态的原因有哪些？" class="headerlink" title="服务端出现大量 CLOSE_WAIT 状态的原因有哪些？"></a>服务端出现大量 CLOSE_WAIT 状态的原因有哪些？</h3><p>还是拿这张图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdWrrgBYLP5VsrraBM1qVuzgibl5CZs9FKwxdu2j2In9NPx4W5wC2e91AjbyLlwL7jvEY5NNjuRr5Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>TCP 四次挥手的流程</p><p>从上面这张图我们可以得知，CLOSE_WAIT 状态是「被动关闭方」才会有的状态，而且如果「被动关闭方」没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态。</p><p>所以，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接</strong>。</p><p>那什么情况会导致服务端的程序没有调用 close 函数关闭连接？这时候通常需要排查代码。</p><p>我们先来分析一个普通的 TCP 服务端的流程：</p><ol><li><p>创建服务端 socket，bind 绑定端口、listen 监听端口</p></li><li><p>将服务端 socket 注册到 epoll</p></li><li><p>epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket</p></li><li><p>将已连接的 socket 注册到 epoll</p></li><li><p>epoll_wait 等待事件发生</p></li><li><p>对方连接关闭时，我方调用 close</p></li></ol><p>可能导致服务端没有调用 close 函数的原因，如下。</p><p><strong>第一个原因</strong>：第 2 步没有做，没有将服务端 socket 注册到 epoll，这样有新连接到来时，服务端没办法感知这个事件，也就无法获取到已连接的 socket，那服务端自然就没机会对 socket 调用 close 函数了。</p><p>不过这种原因发生的概率比较小，这种属于明显的代码逻辑 bug，在前期 read view 阶段就能发现的了。</p><p><strong>第二个原因</strong>：第 3 步没有做，有新连接到来时没有调用 accpet 获取该连接的 socket，导致当有大量的客户端主动断开了连接，而服务端没机会对这些 socket 调用 close 函数，从而导致服务端出现大量 CLOSE_WAIT 状态的连接。</p><p>发生这种情况可能是因为服务端在执行 accpet  函数之前，代码卡在某一个逻辑或者提前抛出了异常。</p><p><strong>第三个原因</strong>：第 4 步没有做，通过 accpet 获取已连接的 socket 后，没有将其注册到 epoll，导致后续收到 FIN 报文的时候，服务端没办法感知这个事件，那服务端就没机会调用 close 函数了。</p><p>发生这种情况可能是因为服务端在将已连接的 socket 注册到 epoll 之前，代码卡在某一个逻辑或者提前抛出了异常。之前看到过别人解决 close_wait 问题的实践文章，感兴趣的可以看看：<a href="https://mp.weixin.qq.com/s?__biz=MzU3Njk0MTc3Ng==&mid=2247486020&idx=1&sn=f7cf41aec28e2e10a46228a64b1c0a5c&scene=21#wechat_redirect">一次 Netty 代码不健壮导致的大量 CLOSE_WAIT 连接原因分析</a></p><p><strong>第四个原因</strong>：第 6 步没有做，当发现客户端关闭连接后，服务端没有执行 close 函数，可能是因为代码漏处理，或者是在执行 close 函数之前，代码卡在某一个逻辑，比如发生死锁等等。</p><p>可以发现，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，通常都是代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用 close</strong>。<br>面试问题</p><p>1）TCP&#x2F;IP协议<br>    1）三次握手&#x2F;四次挥手过程<br>    2）TIME_WAIT状态<br>        1）主动关闭&#x2F;被动关闭<br>        2）需要的原因<br>        3）缓解措施<br>        4）有没有方式不出现TIME_WAIT状态<br>    3）RST出现的场景<br>    4）滑动窗口<br>2）网络编程<br>    1）EPOLL&#x2F;SELECT的区别<br>    2）边沿触发&#x2F;水平触发<br>    3）事件触发的场景<br>        1）读事件 有哪些场景<br>        2）写事件 有哪些场景<br>    4）READ调用返回值场景<br>        1）0<br>        2）-1<br>        3）&gt;0<br>    5）UDP客户端可以CONNECT不，那CONNECT和不CONNECT有啥区别<br>3）后台编程<br>    1）FORK的用途，FORK区分父子进程方式<br>    2）进程间通信方式<br>    3）僵尸进程<br>    4）内存模型，有哪些段构成<br>    5）进程&#x2F;线程&#x2F;协程的区别<br>4）常见中间件<br>    1）MYSQL<br>        1）为啥不建议SELECT *<br>        2）覆盖索引<br>        3）分页优化<br>    2）ZOOKEEPER<br>        1）有哪些WATCH以及对应唤醒事件<br>    3）KAFKA<br>        1）分区分服<br>        2）生产者<br>        3）消费者<br>5）语言<br>    1）JAVA语言<br>        1）内存管理<br>6）设计模式<br>    1）单例模式<br>7）项目中的难点、挑战点</p><p>22989-腾讯云网络后台开发工程师(CSIG全资子公司)（西安）</p><p>建议用online ddl（网上可以查）修改，就是逗号后面的参数<br>另外，添加字段要加上after，根据表结构看看fromWanIp适合在哪个字段后<br>ALTER TABLE cEip ALTER COLUMN ispId SET DEFAULT -1, ALGORITHM&#x3D;INPLACE, LOCK&#x3D;NONE;</p><h3 id="HTTP-长连接和-TCP-长连接有什么区别？"><a href="#HTTP-长连接和-TCP-长连接有什么区别？" class="headerlink" title="HTTP 长连接和 TCP 长连接有什么区别？"></a>HTTP 长连接和 TCP 长连接有什么区别？</h3><p>其实就是HTTP 的 Keep-Alive 和 TCP 的 Keepalive 有什么区别？<br>事实上，<strong>这两个完全是两样不同东西</strong>，实现的层面也不同：</p><ul><li><p>HTTP 的 Keep-Alive，是由<strong>应用层（用户态）</strong> 实现的，称为 HTTP 长连接；</p></li><li><p>TCP 的 Keepalive，是由 <strong>TCP 层（内核态）</strong> 实现的，称为 TCP 保活机制；</p></li></ul><p>接下来，分别说说它们。</p><h4 id="HTTP-的-Keep-Alive"><a href="#HTTP-的-Keep-Alive" class="headerlink" title="HTTP 的 Keep-Alive"></a>HTTP 的 Keep-Alive</h4><p>HTTP 协议采用的是「请求-应答」的模式，也就是客户端发起了请求，服务端才会返回响应，一来一回这样子。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcicwmSuxnPJ1qyiaohMl86ibZhnSbPF3JPicyAmYmy8jQZb5zFKD8tGSDQGkCsrbPD7jJLicqRVet6vrA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>请求-应答</p><p>由于 HTTP 是基于 TCP 传输协议实现的，客户端与服务端要进行 HTTP 通信前，需要先建立 TCP 连接，然后客户端发送 HTTP  请求，服务端收到后就返回响应，至此「请求-应答」的模式就完成了，随后就会释放 TCP 连接。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcicwmSuxnPJ1qyiaohMl86ibZcOoBjt1XmlEoAWTf4V6musIJQE5nxsRRe5gjciaDLPJUZbhZowzibMibQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>一个 HTTP 请求</p><p>如果每次请求都要经历这样的过程：建立 TCP -&gt; 请求资源 -&gt; 响应资源 -&gt; 释放连接，那么此方式就是 <strong>HTTP 短连接</strong>，如下图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcicwmSuxnPJ1qyiaohMl86ibZ3ulicF0AUhTNPjyHE5Dur1sI8cda110PRsPmYEenOIBHpZnayHUFkow/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>HTTP 短连接</p><p>这样实在太累人了，一次连接只能请求一次资源。</p><p>能不能在第一个 HTTP 请求完后，先不断开 TCP 连接，让后续的 HTTP 请求继续使用此连接？</p><p>当然可以，HTTP 的 Keep-Alive 就是实现了这个功能，可以使用同一个 TCP 连接来发送和接收多个 HTTP 请求&#x2F;应答，避免了连接建立和释放的开销，这个方法称为 <strong>HTTP 长连接</strong>。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcicwmSuxnPJ1qyiaohMl86ibZAJAJPbK9xMB5j9nTzs87SwRibAU52mG4ILuB3XvpXNll4gKYazoYUaw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>HTTP 长连接</p><p>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p><p>怎么才能使用 HTTP 的 Keep-Alive 功能？</p><p>在 HTTP 1.0 中默认是关闭的，如果浏览器要开启 Keep-Alive，它必须在请求的包头中添加：</p><p><code>Connection: Keep-Alive   </code></p><p>然后当服务器收到请求，作出回应的时候，它也添加一个头在响应中：</p><p><code>Connection: Keep-Alive   </code></p><p>这样做，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接。这一直继续到客户端或服务器端提出断开连接。</p><p><strong>从 HTTP 1.1 开始， 就默认是开启了 Keep-Alive</strong>，如果要关闭 Keep-Alive，需要在 HTTP 请求的包头里添加：</p><p><code>Connection:close   </code></p><p>现在大多数浏览器都默认是使用 HTTP&#x2F;1.1，所以 Keep-Alive 都是默认打开的。一旦客户端和服务端达成协议，那么长连接就建立好了。</p><p>HTTP 长连接不仅仅减少了 TCP 连接资源的开销，而且这给 <strong>HTTP 流水线</strong>技术提供了可实现的基础。</p><p>所谓的 HTTP 流水线，是<strong>客户端可以先一次性发送多个请求，而在发送过程中不需先等待服务器的回应</strong>，可以减少整体的响应时间。</p><p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。HTTP 流水线机制则允许客户端同时发出 A 请求和 B 请求。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcicwmSuxnPJ1qyiaohMl86ibZy8Ha8LtNZHu3672NVwlpK4iaf9TibSkhbPfHKZHeruKPYdZ87utlcIIw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>右边为 HTTP 流水线机制</p><p>但是<strong>服务器还是按照顺序响应</strong>，先回应 A 请求，完成后再回应 B 请求。</p><p>而且要等服务器响应完客户端第一批发送的请求后，客户端才能发出下一批的请求，也就说如果服务器响应的过程发生了阻塞，那么客户端就无法发出下一批的请求，此时就造成了「队头阻塞」的问题。</p><p>可能有的同学会问，如果使用了 HTTP 长连接，如果客户端完成一个 HTTP 请求后，就不再发起新的请求，此时这个 TCP 连接一直占用着不是挺浪费资源的吗？</p><p>对没错，所以为了避免资源浪费的情况，web 服务软件一般都会提供 <code>keepalive_timeout</code> 参数，用来指定 HTTP 长连接的超时时间。</p><p>比如设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会<strong>启动一个定时器</strong>，如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，<strong>定时器的时间一到，就会触发回调函数来释放该连接。</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcicwmSuxnPJ1qyiaohMl86ibZlTIRFic7L5E39WAIhnL2EibUTRwYIqCReFq4J6RKfcmozBP9agZCundA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>HTTP 长连接超时</p><h4 id="TCP-的-Keepalive"><a href="#TCP-的-Keepalive" class="headerlink" title="TCP 的 Keepalive"></a>TCP 的 Keepalive</h4><p>TCP 的 Keepalive 这东西其实就是 <strong>TCP 的保活机制</strong>，它的工作原理我之前的文章写过，这里就直接贴下以前的内容。</p><p>如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。</p><ul><li><p>如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</p></li><li><p>如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</p></li></ul><p>所以，TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活，这个工作是在内核完成的。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcicwmSuxnPJ1qyiaohMl86ibZHmAI3j2722ibjS7IibNtaiaZibbDpMpBPC8OWbfHsEHwcacE0ZRjgc8pibg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>TCP 保活机制</p><p>注意，应用程序若想使用 TCP 保活机制需要通过 socket 接口设置 <code>SO_KEEPALIVE</code> 选项才能够生效，如果没有设置，那么就无法使用 TCP 保活机制。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>HTTP 的 Keep-Alive 也叫 HTTP 长连接，该功能是由「应用程序」实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求&#x2F;应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销。</p><p>TCP 的 Keepalive 也叫 TCP 保活机制，该功能是由「内核」实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。</p><h3 id="HTTPS-一定安全可靠吗？"><a href="#HTTPS-一定安全可靠吗？" class="headerlink" title="HTTPS 一定安全可靠吗？"></a>HTTPS 一定安全可靠吗？</h3><p>客户端通过浏览器向服务端发起 HTTPS 请求时，被「假基站」转发到了一个「中间人服务器」，于是客户端是和「中间人服务器」完成了 TLS 握手，然后这个「中间人服务器」再与真正的服务端完成 TLS 握手。</p><p>具体过程如下：<br>![[Pasted image 20230517164728.png]]</p><ul><li><p>客户端向服务端发起 HTTPS 建立连接请求时，然后被「假基站」转发到了一个「中间人服务器」，接着中间人向服务端发起 HTTPS 建立连接请求，此时客户端与中间人进行 TLS 握手，中间人与服务端进行 TLS 握手；</p></li><li><p>在客户端与中间人进行 TLS 握手过程中，中间人会发送自己的公钥证书给客户端，<strong>客户端验证证书的真伪</strong>，然后从证书拿到公钥，并生成一个随机数，用公钥加密随机数发送给中间人，中间人使用私钥解密，得到随机数，此时双方都有随机数，然后通过算法生成对称加密密钥（A），后续客户端与中间人通信就用这个对称加密密钥来加密数据了。</p></li><li><p>在中间人与服务端进行 TLS 握手过程中，服务端会发送从 CA 机构签发的公钥证书给中间人，从证书拿到公钥，并生成一个随机数，用公钥加密随机数发送给服务端，服务端使用私钥解密，得到随机数，此时双方都有随机数，然后通过算法生成对称加密密钥（B），后续中间人与服务端通信就用这个对称加密密钥来加密数据了。</p></li><li><p>后续的通信过程中，中间人用对称加密密钥（A）解密客户端的 HTTPS 请求的数据，然后用对称加密密钥（B）加密 HTTPS 请求后，转发给服务端，接着服务端发送 HTTPS 响应数据给中间人，中间人用对称加密密钥（B）解密 HTTPS 响应数据，然后再用对称加密密钥（A）加密后，转发给客户端。</p></li></ul><p>从客户端的角度看，其实并不知道网络中存在中间人服务器这个角色。</p><p>那么中间人就可以解开浏览器发起的 HTTPS 请求里的数据，也可以解开服务端响应给浏览器的 HTTPS 响应数据。相当于，中间人能够 “偷看” 浏览器与服务端之间的 HTTPS 请求和响应的数据。</p><p>但是要发生这种场景是有前提的，<strong>前提是用户点击接受了中间人服务器的证书。</strong></p><p>中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0Dm1SNmvUayxCflHTROibNzricwiaRlwzuc1CUqXYTYEapwDNUybxhiaWfofHt7LSuzC4cFdYvwcJoA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>如果用户执意点击「继续浏览此网站」，相当于用户接受了中间人伪造的证书，那么后续整个 HTTPS 通信都能被中间人监听了。</p><p>所以，这其实并不能说 HTTPS 不够安全，毕竟浏览器都已经提示证书有问题了，如果用户坚决要访问，那<strong>不能怪 HTTPS ，得怪自己手贱</strong>。</p><h4 id="客户端是如何验证证书的？"><a href="#客户端是如何验证证书的？" class="headerlink" title="客户端是如何验证证书的？"></a>客户端是如何验证证书的？</h4><p>接下来，详细说一下实际中数字证书签发和验证流程。</p><p>如下图图所示，为数字证书签发和验证流程：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0Dm1SNmvUayxCflHTROibNMxlSGIfI1kiav1TwxTK6ZtGiaCiaygM3g0fFnPYo3n9atZlbhvpkWt77Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">当服务端向 CA 机构申请证书的时候，CA 签发证书的过程，如上图左边部分：</p><ul><li><p>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</p></li><li><p>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</p></li><li><p>最后将 Certificate Signature 添加在文件证书上，形成数字证书；</p></li></ul><p>客户端校验服务端的数字证书的过程，如上图右边部分：</p><ul><li><p>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</p></li><li><p>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</p></li><li><p>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</p></li></ul><p>但事实上，证书的验证过程中<strong>还存在一个证书信任链的问题</strong>，因为我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的，比如百度的证书，从下图你可以看到，证书的层级有三级：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0Dm1SNmvUayxCflHTROibNVINCkWDhqk7OiaibpvuUnYAt2GXtShM9z5bWCG1TSZH6LzzylakSk83w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>对于这种三级层级关系的证书的验证过程如下：</p><ul><li><p>客户端收到 baidu.com 的证书后，发现这个证书的签发者不是根证书，就无法根据本地已有的根证书中的公钥去验证 baidu.com 证书是否可信。于是，客户端根据 baidu.com 证书中的签发者，找到该证书的颁发机构是 “GlobalSign Organization Validation CA - SHA256 - G2”，然后向 CA 请求该中间证书。</p></li><li><p>请求到证书后发现 “GlobalSign Organization Validation CA - SHA256 - G2” 证书是由 “GlobalSign Root CA” 签发的，由于 “GlobalSign Root CA” 没有再上级签发机构，说明它是根证书，也就是自签证书。应用软件会检查此证书有否已预载于根证书清单上，如果有，则可以利用根证书中的公钥去验证 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，如果发现验证通过，就认为该中间证书是可信的。</p></li><li><p>“GlobalSign Organization Validation CA - SHA256 - G2” 证书被信任后，可以使用 “GlobalSign Organization Validation CA - SHA256 - G2” 证书中的公钥去验证 baidu.com 证书的可信性，如果验证通过，就可以信任 baidu.com 证书。</p></li></ul><p>在这四个步骤中，最开始客户端只信任根证书 GlobalSign Root CA 证书的，然后 “GlobalSign Root CA” 证书信任 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，而 “GlobalSign Organization Validation CA - SHA256 - G2” 证书又信任 baidu.com 证书，于是客户端也信任 baidu.com 证书。总括来说，由于用户信任 GlobalSign，所以由 GlobalSign 所担保的 baidu.com 可以被信任，另外由于用户信任操作系统或浏览器的软件商，所以由软件商预载了根证书的 GlobalSign 都可被信任。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0Dm1SNmvUayxCflHTROibNIPhXyF7S1WDIbuUbGwgLjwr47iau48ape1H3GYg8B0hDEKeqdz7xZgg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>操作系统里一般都会内置一些根证书，比如我的 MAC 电脑里内置的根证书有这么多：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0Dm1SNmvUayxCflHTROibNloHzrlsep6vZgNvz8sA8LDBHnAWyErqcpicRM6kovSB5L3IQcjdD5aw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>这样的一层层地验证就构成了一条信任链路，整个证书信任链验证流程如下图所示：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0Dm1SNmvUayxCflHTROibNFruFDENMpzLgnfRH9T8uN0TAOItwoqia9mXLNLsE7UErltjyBu2zicNQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>如果你的电脑中毒了，被恶意导入了中间人的根证书，那么在验证中间人的证书的时候，由于你操作系统信任了中间人的根证书，那么等同于中间人的证书是合法的。</p><p>这种情况下，浏览器是不会弹出证书存在问题的风险提醒的。</p><p>这其实也不关 HTTPS 的事情，是你电脑中毒了才导致 HTTPS 数据被中间人劫持的。</p><p>所以，<strong>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全。</strong></p><h4 id="为什么抓包工具能截取-HTTPS-数据？"><a href="#为什么抓包工具能截取-HTTPS-数据？" class="headerlink" title="为什么抓包工具能截取 HTTPS 数据？"></a>为什么抓包工具能截取 HTTPS 数据？</h4><p>抓包工具 Fiddler 之所以可以明文看到 HTTPS 数据，工作原理与中间人一致的。</p><p>对于 HTTPS 连接来说，中间人要满足以下两点，才能实现真正的明文代理:</p><ol><li><p>中间人，作为客户端与真实服务端建立连接这一步不会有问题，因为服务端不会校验客户端的身份；</p></li><li><p>中间人，作为服务端与真实客户端建立连接，这里会有客户端信任服务端的问题，也就是服务端必须有对应域名的私钥；</p></li></ol><p>中间人要拿到私钥只能通过如下方式：</p><ol><li><p>去网站服务端拿到私钥；</p></li><li><p>去CA处拿域名签发私钥；</p></li><li><p>自己签发证书，且被浏览器信任；</p></li></ol><p>不用解释，抓包工具只能使用第三种方式取得中间人的身份。</p><p>使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装 Fiddler 的根证书，这里实际上起认证中心（CA）的作用。</p><p>Fiddler 能够抓包的关键是客户端会往系统受信任的根证书列表中导入 Fiddler 生成的证书，而这个证书会被浏览器信任，也就是 Fiddler 给自己创建了一个认证中心 CA。</p><p>客户端拿着中间人签发的证书去中间人自己的 CA 去认证，当然认为这个证书是有效的。</p><h4 id="如何避免被中间人抓取数据？"><a href="#如何避免被中间人抓取数据？" class="headerlink" title="如何避免被中间人抓取数据？"></a>如何避免被中间人抓取数据？</h4><p>我们要保证自己电脑的安全，不要被病毒乘虚而入，而且也不要点击任何证书非法的网站，这样 HTTPS 数据就不会被中间人截取到了。</p><p>当然，我们还可以通过 HTTPS 双向认证来避免这种问题。</p><p>一般我们的 HTTPS 是单向认证，客户端只会验证了服务端的身份，但是服务端并不会验证客户端的身份。</p><p>如果用了双向认证方式，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0Dm1SNmvUayxCflHTROibNccBibe4MEf260dWmCfGnvHgz7iaZza3s1Sq6UwibbuGickDfMIcwAlGBGQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。</p><h3 id="客户端连接一个不存在的-IP-地址，会发生什么？客户端连接一个存在的-IP-地址但是端口不存在，会发生什么？"><a href="#客户端连接一个不存在的-IP-地址，会发生什么？客户端连接一个存在的-IP-地址但是端口不存在，会发生什么？" class="headerlink" title="客户端连接一个不存在的 IP 地址，会发生什么？客户端连接一个存在的 IP 地址但是端口不存在，会发生什么？"></a>客户端连接一个不存在的 IP 地址，会发生什么？客户端连接一个存在的 IP 地址但是端口不存在，会发生什么？</h3><p>PS：这里的「连接」指的是 TCP 连接。</p><blockquote><p>Q1：客户端连接一个不存在的 IP 地址，会发生什么？</p></blockquote><p>这个问题要分两种情况来思考，不同的情况得到的结论是不同的。</p><p><em>第一个情况：目标 IP 地址和客户端的 IP 地址是同一个局域网（网络号相同）。</em></p><p>第一种情况，客户端无法发出 SYN 报文，主要卡在数据链路层。</p><p>因为目标地址不存在 IP 地址，客户端的内核在发 arp 请求的时候，广播询问这个目标 IP 地址是谁的，由于网络中不存在该目标 IP 地址，所以没有设备应答客户端的 arp 请求。</p><p>由于<strong>客户端无法拿到目标设备的 MAC，这样就没办法组装 MAC 头的信息，所以 SYN 报文无法发送出去</strong>。</p><p><em>第二个情况：目标 IP 地址和客户端的 IP 地址不在同一个局域网（网络号不同）。</em></p><p>第二种情况，客户端会先将 SYN 报文发给路由器，然后路由器会继续转发。</p><p>由于目标 IP 地址是不存在的，该 SYN 报文会在网络中消亡，因此客户端是不会收到对 SYN 报文的确认报文的，接着<strong>客户端会触发超时重传，重传 SYN 报文，直到重传的次数达到最大次数后，客户端的连接就会被释放</strong>。</p><p>可能有的同学好奇，为什么这种情况客户端的 SYN 报文可以发出来？</p><p>因为当目标 IP 地址和客户端 IP 地址不在同一个局域网时，客户端客通过路由表的判断，判断到下一步是要将网络报文发送给路由器。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfm4PfB688v0rxFhJb6z15lQyA1upkFc3DxHn6sJ50fuyvdBMNTQUZ1FK1d5qM2C9ibWQP0eOKpcaw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>这时候数据链路层的 arp 请求，会广播询问 IP 地址（路由器 IP 地址）是谁的，路由器发现是自己的 IP 地址，于是就会将自己的 MAC 地址告诉客户端。</p><p>然后客户端的网络报文中 MAC 头的「目标 MAC 地址」填入的就是路由器的 MAC 地址，于是 SYN 报文就可以发送出去了。</p><p>由于目标 MAC 地址是路由器的，所以就会被路由器接收，然后路由器继续通过路由表的判断，转发给下一个路由器，直到找到目标设备。</p><blockquote><p>Q2：客户端连接一个存在的 IP 地址但是端口不存在，会发生什么？</p></blockquote><p>客户端连接的目标 IP 地址是存在的，那么 SYN 报文就能正确的抵达到目标设备。</p><p>目标设备收到 SYN 报文后，发现端口号并没有被进程监听，这时候目标设备的内核就会回 RST 报文。</p><p>客户端收到 RST 报文后，就会释放连接。</p><p>…….</p><p>至此，结论已说完。</p><p>不知道你们会不会觉得信息量很大，如果你觉得信息量大，那么你该补补网络知识啦。</p><p>第二题不难，难在的是第一题，如果你没有把两台电脑之间是怎么通信的搞清楚，那么你是无从下手回答的，所以建立好体系化的网络知识，面对这类的场景题目，就能做到举一反三了。</p><p>最近比较忙，偷懒了，没有画图，如果哪里没理解的，可以先看我以前写的这篇文章：<a href="http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247483989&idx=1&sn=7e2ed852770743d3955ef9d5561fcef3&chksm=f98e46ffcef9cfe98e6c753afac86125b0d5891ca5e63968b5f3a8da4905d14274088f40c34e&scene=21#wechat_redirect">探究！一个数据包在网络中的心路历程</a>，有详细讲解每一层是怎么封装头部的，以及路由表是怎么判断的。</p><p><strong>最后再提一个问题：****客户端发送了一个目标 IP 地址存在但是</strong>端口不存在的 UDP 报文<strong>，UDP 没有像 TCP 那样的 RST 报文，此时会发生什么？</strong></p><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul><li><p>TCP消息和UDP的主要区别</p></li><li><p>Epoll比起select&#x2F;poll，主要优化点在哪里？</p></li><li><p>Post和Get有什么区别？</p></li><li><p>接收时，如何确定一个HTTP消息已经读取完毕</p></li><li><p>从一个命令行下载一个网页，会涉及哪些网络协议？（DNS，TCP，HTTP，如果有ARP和SSL更好）</p></li><li><p>HTTP&#x2F;2主要优化点</p></li><li><p>\1. C++中具体是怎么实现多态的？构造函数可以是虚函数吗？构造函数可以调用虚函数吗？<br>编译器发现一个类中有虚函数，便会立即为此类生成虚函数表 vtable。虚函数表的各表项为指向对应虚函数的指针。<br>构造函数不可以是虚函数，也不能调用虚函数，因为此时虚函数表还未生成。</p><p>\2. 操作系统中进程、线程的区别，进程间通信通信的方式？<br>进程： 进程是资源（CPU、内存等）分配的基本单位，具有一定功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。<br>线程：线程是进程的一个实体，是独立运行和独立调度的基本单位（CPU上真正运行的是线程）。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。<br>进程通信的方式：管道，有名管道，信号量，消息队列，信号,共享内存,套接字.</p><p>\3. python中的多线程能充分利用多核CPU吗？如果要充分利用的话应该怎么做？<br>python的多线程不能充分利用多CPU，因为python解释器有一个全局锁；<br>要想利用多CPU只能使用多进程模型，或者使用C++</p><p>\4. http属于OSI分层协议中的哪一层？TCP&#x2F;UDP是属于哪一层？TCP的三次握手的过程是怎样的？为什么要有三次握手？<br>http属于应用层，TCP&#x2F;UDP属于传输层；</p><p>假设 A 为客户端，B 为服务器端。</p><p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p><p>A 向 B 发送连接请求报文，SYN&#x3D;1，ACK&#x3D;0，选择一个初始的序号 x。</p><p>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN&#x3D;1，ACK&#x3D;1，确认号为 x+1，同时也选择一个初始的序号 y。</p><p>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</p><p>B 收到 A 的确认后，连接建立。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><p>\5. TCP怎么实现可靠传输的？</p><p>TCP滑动窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。<br>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。<br>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p></li></ul>]]></content>
    
    
    <summary type="html">积累计算机网络相关面试问题及解答。包括tcp/udp/网络分层等</summary>
    
    
    
    <category term="Tech" scheme="http://amazingcoderpro.github.io/categories/Tech/"/>
    
    
    <category term="cs" scheme="http://amazingcoderpro.github.io/tags/cs/"/>
    
    <category term="network" scheme="http://amazingcoderpro.github.io/tags/network/"/>
    
    <category term="interview" scheme="http://amazingcoderpro.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>技术指标</title>
    <link href="http://amazingcoderpro.github.io/2021/06/08/SoftSkills/Trade/%E6%8A%80%E6%9C%AF%E6%8C%87%E6%A0%87/"/>
    <id>http://amazingcoderpro.github.io/2021/06/08/SoftSkills/Trade/%E6%8A%80%E6%9C%AF%E6%8C%87%E6%A0%87/</id>
    <published>2021-06-08T07:29:00.000Z</published>
    <updated>2021-10-08T07:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="技术指标"><a href="#技术指标" class="headerlink" title="技术指标"></a>技术指标</h1><h3 id="均线"><a href="#均线" class="headerlink" title="均线"></a>均线</h3><ul><li><p>10月均线向上，中期指标</p></li><li><p>30月均线，长期指标</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjfnhasenj319u0mmmzs.jpg" alt="image-20211219133651915"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjfnfj2bwj317k0n8q5w.jpg" alt="image-20211219133925714"></p></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjfniaywaj317w0mugoj.jpg" alt="image-20211219134600341"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjfng0j4zj31700k840w.jpg" alt="image-20211219134720997"></p><h3 id="KDJ"><a href="#KDJ" class="headerlink" title="KDJ"></a>KDJ</h3><p>超买超卖，提示风险</p><p>月线</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjfniqd5ej317s0n2q76.jpg" alt="image-20211219203418286"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjfngv8f3j316a0mu0vn.jpg" alt="image-20211219203940966"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjfngh609j319u0qkae8.jpg" alt="image-20211219204715570"></p><p>背离是辅助判断，不是买卖点。只是用来更加确认买卖点</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjfnhr3ibj316q0my40q.jpg" alt="image-20211219204950389"></p><h3 id="MACD"><a href="#MACD" class="headerlink" title="MACD"></a>MACD</h3><p>月线</p><p>以柱线为准，长期稳定</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjfs3zv8cj315q0l4q6a.jpg" alt="image-20211219205518843"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjfsjgrabj31640nmgok.jpg" alt="image-20211219205543734"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjfuee30pj317u0mu785.jpg" alt="image-20211219205730511"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjfwjqhxgj31880mu41w.jpg" alt="image-20211219205934087"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjg0blg4ej31760miwi2.jpg" alt="image-20211219210253627"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjg3gu0ayj31700m60uz.jpg" alt="image-20211219210614753"></p><h3 id="RSI"><a href="#RSI" class="headerlink" title="RSI"></a>RSI</h3><p>月线，预测未来，不是仅短线用， </p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjg6g0207j31720kaq5t.jpg" alt="image-20211219210906129"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjg7jsrqqj31640mm0wa.jpg" alt="image-20211219211009671"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjg8g18bhj318g0nmwi1.jpg" alt="image-20211219211059511"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjgb2qs82j319s0ncgpo.jpg" alt="image-20211219211330961"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjgd47u7oj317q0nwdj8.jpg" alt="image-20211219211528760"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjgf8zcs8j318c0nmn1b.jpg" alt="image-20211219211731492"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjghi0zxwj317q0o4jto.jpg" alt="image-20211219211941665"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjgirt7mij316q0iq0uy.jpg" alt="image-20211219212056757"></p><h3 id="CCI"><a href="#CCI" class="headerlink" title="CCI"></a>CCI</h3><p>特定行情下发挥奇效的指标，震荡行情不适用</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjgo7a9f9j31b00m20vr.jpg" alt="image-20211219212608218"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjgoovdvij31e80r442s.jpg" alt="image-20211219212637379"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjgq34c7sj31cw0r8q6d.jpg" alt="image-20211219212748601"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjgrc5b4fj31bk0pi0we.jpg" alt="image-20211219212909328"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjgtgg423j317u0nuwhz.jpg" alt="image-20211219213111340"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjgv6ls2rj317q0nctce.jpg" alt="image-20211219213251009"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjgxydxi2j316m0limz8.jpg" alt="image-20211219213530849"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjgypla0yj317u0m6acg.jpg" alt="image-20211219213614309"></p><h3 id="布林带"><a href="#布林带" class="headerlink" title="布林带"></a>布林带</h3><p>震荡与趋势的抉择</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjh2s6qf5j31io0oeq64.jpg" alt="image-20211219214008791"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjh3d7dgwj31hi0sqq7v.jpg" alt="image-20211219214042893"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjh4d7m32j31i20sigqh.jpg" alt="image-20211219214140463"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjh922qo5j31hy0ts0xu.jpg" alt="image-20211219214610779"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjha9x6nbj31hi0te42j.jpg" alt="image-20211219214721880"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjhavfvqnj31iw0tujw5.jpg" alt="image-20211219214755448"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxjhdqg7k3j31go0rcju7.jpg" alt="image-20211219215039697"></p><h3 id="回调百分百与黄金分割"><a href="#回调百分百与黄金分割" class="headerlink" title="回调百分百与黄金分割"></a>回调百分百与黄金分割</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxk7bjlkh0j319y0p20v0.jpg" alt="image-20211220124808782"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxk7bslk84j31880n80v7.jpg" alt="image-20211220124823289"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxk7d8laj4j319g0nqdjx.jpg" alt="image-20211220124936052"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxk7ey9kwoj319g0oqq6w.jpg" alt="image-20211220125124000"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxk7fu3840j31900nuq6z.jpg" alt="image-20211220125216224"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxk7gp8nhej31980n0wi1.jpg" alt="image-20211220125253952"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxk7gssmb1j318g0n8n0u.jpg" alt="image-20211220125312475"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxk7i38xmpj318u0matay.jpg" alt="image-20211220125426935"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxk7insbstj316y0lkdiu.jpg" alt="image-20211220125500202"></p><h3 id="成交量"><a href="#成交量" class="headerlink" title="成交量"></a>成交量</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxk7pft4dqj318k0o6q66.jpg" alt="image-20211220130011499"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxk7qjyx9xj317m0ncdiy.jpg" alt="image-20211220130234880"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxk7rzznn4j319w0oejv4.jpg" alt="image-20211220130358178"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxk7u39iqhj318w0ng41t.jpg" alt="image-20211220130558730"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxk7vl4zs7j316u0mswi8.jpg" alt="image-20211220130725570"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxk7y6h1u9j31700oin0v.jpg" alt="image-20211220130954556"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxk7zstw5kj319w0n8ads.jpg" alt="image-20211220131125963"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxk810ho2uj317g0mqacb.jpg" alt="image-20211220131237587"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxk828dyxcj31860lwn0r.jpg" alt="image-20211220131348889"></p><h3 id="趋势线和形态"><a href="#趋势线和形态" class="headerlink" title="趋势线和形态"></a>趋势线和形态</h3><p>不能创越k线实体</p><p>多点相连，跨度适中</p><p>三角形必须有个直角边，水平线</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxk86za2vwj316a0mi77e.jpg" alt="image-20211220131812318"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxk87ln90lj319y0ne41q.jpg" alt="image-20211220131854527"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxk8a7vgcyj31aq0o477a.jpg" alt="image-20211220132127963"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxk8d6ojcoj318q0mggox.jpg" alt="image-20211220132415854"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxk8ep1zzmj318w0loada.jpg" alt="image-20211220132546888"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxk8fp0ujyj317w0mkn0c.jpg" alt="image-20211220132644343"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxk8h5fobzj31940naadc.jpg" alt="image-20211220132807986"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxk8hyxcctj31740miac4.jpg" alt="image-20211220132855724"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxk8j2r53jj315a0jsdi6.jpg" alt="image-20211220132959611"></p><h3 id="缺口理论"><a href="#缺口理论" class="headerlink" title="缺口理论"></a>缺口理论</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxkcw05rl5j31920muac6.jpg" alt="image-20211220160049476"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxkcy7b023j31b00ns42h.jpg" alt="image-20211220160255007"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxkcz26496j31600ns0vu.jpg" alt="image-20211220160345056"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxkd0c2p3oj318e0oa0wc.jpg" alt="image-20211220160458100"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxkd3atkdhj31900nawhd.jpg" alt="image-20211220160750577"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxkd4wk2xsj318o0no40l.jpg" alt="image-20211220160921979"></p><h3 id="均线组合"><a href="#均线组合" class="headerlink" title="均线组合"></a>均线组合</h3><p> <img src="https://tva1.sinaimg.cn/large/008i3skNly1gxkdb138uuj319g0nq77q.jpg" alt="image-20211220161515335"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxkddpi7ywj31840niq6c.jpg" alt="image-20211220161749776"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxkdgvulwlj317y0man0z.jpg" alt="image-20211220162049970"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxkdi37juqj317y0ncacz.jpg" alt="image-20211220162202206"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxkdk668z6j319w0nqwi7.jpg" alt="image-20211220162403671"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxkdmiixvhj317k0mq41x.jpg" alt="image-20211220162618601"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxkdnlqkpuj318k0la76f.jpg" alt="image-20211220162718175"></p>]]></content>
    
    
    <summary type="html">技术指标</summary>
    
    
    
    <category term="SoftSkills" scheme="http://amazingcoderpro.github.io/categories/SoftSkills/"/>
    
    <category term="Trade" scheme="http://amazingcoderpro.github.io/categories/SoftSkills/Trade/"/>
    
    
    <category term="softskills" scheme="http://amazingcoderpro.github.io/tags/softskills/"/>
    
    <category term="trade" scheme="http://amazingcoderpro.github.io/tags/trade/"/>
    
  </entry>
  
  <entry>
    <title>投资基金</title>
    <link href="http://amazingcoderpro.github.io/2021/06/08/SoftSkills/Trade/%E6%8A%95%E8%B5%84%E5%9F%BA%E9%87%91/"/>
    <id>http://amazingcoderpro.github.io/2021/06/08/SoftSkills/Trade/%E6%8A%95%E8%B5%84%E5%9F%BA%E9%87%91/</id>
    <published>2021-06-08T07:29:00.000Z</published>
    <updated>2021-10-08T07:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="投资基金"><a href="#投资基金" class="headerlink" title="投资基金"></a>投资基金</h1><h2 id="风险评估"><a href="#风险评估" class="headerlink" title="风险评估"></a>风险评估</h2><ul><li>影响因素： 收入，年龄</li></ul><h2 id="保守型"><a href="#保守型" class="headerlink" title="保守型"></a>保守型</h2><ul><li>5-10， 平衡</li><li>货币基金</li><li>沪深300指数基金, 大企</li><li>纯债式基金</li><li>中证500指数基金， 中小企</li><li>混合型基金 </li><li>下一年初，调回平衡 </li><li>天天基金， 参考前三的债股比例 。多留意市场动向。</li></ul><h2 id="稳健型"><a href="#稳健型" class="headerlink" title="稳健型"></a>稳健型</h2><p>-5， 11-16 %</p><ul><li>不要货币基金（稳，收益低）</li><li>长期定投</li><li>积极法：加多一个行业板块股票基金 ，未来：生物医药， 人工智能， 新零售</li></ul><h2 id="进取型"><a href="#进取型" class="headerlink" title="进取型"></a>进取型</h2><ul><li>-10， 17-25%</li><li>300+500+混+行业</li><li>更多的学习和关注</li></ul><h2 id="怎么买，-哪里买"><a href="#怎么买，-哪里买" class="headerlink" title="怎么买， 哪里买"></a>怎么买， 哪里买</h2><ul><li>除货币基金，其他都 要收费， 1.5% 平均的申购费</li><li>可以：基金公司，代销机构， 第三方</li><li>基金公司：易方达，华夏， 博时， 只能买到该公司的， 基乎不要申购费</li><li>代销：银行和证券公司，全，但不打折，证券账户， 太贵</li><li>第三方：基金大超市， 天天基金， 蚂蚁财富，腾讯理财通， 全而打折，适合小白。</li><li>推荐：天天基金搭配蚂蚁或腾讯</li><li>前端收费：买入时就给申购费（买入量大小</li><li>后端收费：卖时才收费（持有时间 长</li><li>卖出： 赎回费， 时间 越长越便宜</li><li>特殊：管理费，托管费，服务 费</li><li>单位净值， 份额</li><li>累计净值：单位净值 加 分红， 过去业绩或表现好不好</li></ul><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><h3 id="历史业绩"><a href="#历史业绩" class="headerlink" title="历史业绩"></a>历史业绩</h3><ul><li><p>怎么看， 纵向对比： 同类基金中同一段时间的对比， 至少看3年历史 </p></li><li><h2 id="4433法则：好买基金网，-4：选择两年，三年，-五年，今年以来业绩排名在同类基金中排名前1-x2F-4的基金-4：选择一年期业绩排名，在同类基金中提成名前1-x2F-4的基金-3：近6月在同类中排名前1-x2F-3-3-近三个月业绩排名，-在同类基金中排名前1-x2F-3的"><a href="#4433法则：好买基金网，-4：选择两年，三年，-五年，今年以来业绩排名在同类基金中排名前1-x2F-4的基金-4：选择一年期业绩排名，在同类基金中提成名前1-x2F-4的基金-3：近6月在同类中排名前1-x2F-3-3-近三个月业绩排名，-在同类基金中排名前1-x2F-3的" class="headerlink" title="4433法则：好买基金网，  - 4：选择两年，三年， 五年，今年以来业绩排名在同类基金中排名前1&#x2F;4的基金  - 4：选择一年期业绩排名，在同类基金中提成名前1&#x2F;4的基金  - 3：近6月在同类中排名前1&#x2F;3  - 3: 近三个月业绩排名， 在同类基金中排名前1&#x2F;3的"></a>4433法则：好买基金网，<br>  - 4：选择两年，三年， 五年，今年以来业绩排名在同类基金中排名前1&#x2F;4的基金<br>  - 4：选择一年期业绩排名，在同类基金中提成名前1&#x2F;4的基金<br>  - 3：近6月在同类中排名前1&#x2F;3<br>  - 3: 近三个月业绩排名， 在同类基金中排名前1&#x2F;3的</h2></li><li><p>橫向对比，同期大盘涨跌参考</p></li></ul><h3 id="晨星评级，-天天基金的评级，-三年以上才有，晨星-4星或五星，天天基金国内至少两家机构的五星"><a href="#晨星评级，-天天基金的评级，-三年以上才有，晨星-4星或五星，天天基金国内至少两家机构的五星" class="headerlink" title="晨星评级， 天天基金的评级， 三年以上才有，晨星 4星或五星，天天基金国内至少两家机构的五星"></a>晨星评级， 天天基金的评级， 三年以上才有，晨星 4星或五星，天天基金国内至少两家机构的五星</h3><h3 id="基金经理："><a href="#基金经理：" class="headerlink" title="基金经理："></a>基金经理：</h3><ul><li>从业年限，穿越牛熊， 八年以上</li><li>历史业绩：管理过的基金， 从业期间表现如何。 天天基金</li><li>管理的基金数：不要超过6只， 除非是指数基金</li><li>指数基金（复制指数，按照指数的比例投资于成分股， 跟市场走， 无需加入主观的投资判断）， 超短债权基金（没有太大的升值空间， 好与坏在回报率上没有多大差别， ），对技术选股信赖比较深的基金：若基金依赖技术选股的程度很深，采用的技术模式非常多， 那么人为因素影响就会变得非常小， ——-以上，不需要特别关注基金经理的变化</li></ul><h3 id="基金公司"><a href="#基金公司" class="headerlink" title="基金公司"></a>基金公司</h3><ul><li>如：南方基金， 华夏基金， 易方达， 嘉实基金</li></ul><h3 id="风险评估-1"><a href="#风险评估-1" class="headerlink" title="风险评估"></a>风险评估</h3><ul><li>夏普比率：单位风险所获得的超额回报率， 即都 承担同样风险的情况下，看谁能获得更多的收益 ，预期收益同样的情况下，谁的风险更小。—– 较高时， 更好</li><li>标准 差： 越高，波多性越大。 低些好</li><li>如何判断高低： 晨星网，</li></ul><h3 id="以上，-可以按不同的侧重排优先级"><a href="#以上，-可以按不同的侧重排优先级" class="headerlink" title="以上， 可以按不同的侧重排优先级"></a>以上， 可以按不同的侧重排优先级</h3><h2 id="该拿出多少钱买基金"><a href="#该拿出多少钱买基金" class="headerlink" title="该拿出多少钱买基金"></a>该拿出多少钱买基金</h2><ul><li>最佳状态：保证生活品质的同时，增值 </li><li>标准普尔家庭资产象限图：<ul><li>要花的钱：短期要用的。3-6月的生活费 </li><li>保命的钱：社保等，保险。年收入的10% ， 一勺财商教育</li><li>风险投资，生钱的钱：股票， 基金 ， 100法则： （100-年龄）</li><li>保本：债权， 信托，银行理财</li></ul></li><li>不要一刀切</li></ul><h2 id="三大策略"><a href="#三大策略" class="headerlink" title="三大策略"></a>三大策略</h2><ul><li>长线投资：</li><li>分散投资： 不同类型的基金， 组合， 低相关性， 有对冲性的分散。 分散在不同的基金公司和不同的基金经理， 国内与海外分散。</li><li>分段投资: 定投。</li></ul><h2 id="投多少只"><a href="#投多少只" class="headerlink" title="投多少只"></a>投多少只</h2><ul><li>四五只基金 ， 要有对冲意义的</li></ul><h2 id="基金定投"><a href="#基金定投" class="headerlink" title="基金定投"></a>基金定投</h2><ul><li>和单买的区别：</li><li>为什么定投：<ul><li>强制储蓄， 积少成多</li><li>分批买入，摊分成本</li><li>无须择时，避免跟风</li></ul></li><li>定投时间 周期：<ul><li>目的： 长远规划， 月金额低一些， 一月一次， 10年以上</li><li>止盈定投：  两周或一周一次，</li></ul></li><li>什么类型的基金适合定投<ul><li>股票，指数， 混合—波动大的更适合定投</li></ul></li><li>周期频率：<ul><li>年， 月， 周 （周略优于月， 长远来看差不多）</li></ul></li><li>哪一天扣款入市：<ul><li>金股：黑色周四， 月末， 季末，</li><li>月投: 月末， </li><li>周：周四</li></ul></li><li>熊市是否停止定投 <ul><li>继续投， 牛市要谨慎， 降低频率和金额。</li></ul></li><li>智能定投：<ul><li>判断高低位，牛熊市。</li><li>均线定投：跌多买， 涨少买， 风险承受能力高的</li><li>趋势定投：风险承受能力低的， 留 心频繁的转换基金产生的手续费</li><li>估值定投：PE市盈率， 长期持有</li></ul></li></ul><h2 id="基金交易规则"><a href="#基金交易规则" class="headerlink" title="基金交易规则"></a>基金交易规则</h2><ul><li>T+1,  15点之前</li><li>分红方式选 择：红利再投资</li><li>计算收益： EXCEL-&gt;XIRR: 2013&#x2F;08&#x2F;12 -10000</li></ul>]]></content>
    
    
    <summary type="html">投资基金</summary>
    
    
    
    <category term="SoftSkills" scheme="http://amazingcoderpro.github.io/categories/SoftSkills/"/>
    
    <category term="Trade" scheme="http://amazingcoderpro.github.io/categories/SoftSkills/Trade/"/>
    
    
    <category term="softskills" scheme="http://amazingcoderpro.github.io/tags/softskills/"/>
    
    <category term="trade" scheme="http://amazingcoderpro.github.io/tags/trade/"/>
    
  </entry>
  
  <entry>
    <title>投资理财组合</title>
    <link href="http://amazingcoderpro.github.io/2021/06/08/SoftSkills/Trade/%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2%E7%BB%84%E5%90%88/"/>
    <id>http://amazingcoderpro.github.io/2021/06/08/SoftSkills/Trade/%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2%E7%BB%84%E5%90%88/</id>
    <published>2021-06-08T07:29:00.000Z</published>
    <updated>2021-10-08T07:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="投资理财组合"><a href="#投资理财组合" class="headerlink" title="投资理财组合"></a>投资理财组合</h1><h3 id="永久组合："><a href="#永久组合：" class="headerlink" title="永久组合："></a>永久组合：</h3><p>上世纪 80 年代，美国的专业投资人哈利·布朗就提出了永久组合，它以相等的权重，配置于四类非常常规并且“永久”的资产：25% 的股票、25% 的国债、25% 的黄金和 25% 的现金。股票和国债，我们在介绍股债组合的时候都熟悉了，新加入的黄金则是一把对抗通货膨胀的“利器”，而现金可以最大程度上削弱风险，并留出流动资金用沪深 300 指数代表股票资产，上证 5 年国债指数代表债券资产，黄金资产则用黄金期货指数来代表，现金资产呢，我们使用货币基金</p><h3 id="耶鲁组合"><a href="#耶鲁组合" class="headerlink" title="耶鲁组合"></a>耶鲁组合</h3><p>。我们用“万得 - 普通股票型基金指数”代表中国的主动股票型基金资产，使用“标普 500 人民币指数”代表美国股票资产，使用上证 5 年国债指数代表债券资产。按 30% 中国主动股基，10% 美国股票资产和 60% 债券的权重在</p><h3 id="基金筛选"><a href="#基金筛选" class="headerlink" title="基金筛选"></a>基金筛选</h3><ul><li>用基金评级结果进行初步筛选，剔除掉成立时间太短、基金经理近期换过、偏行业或主题型的主动股票基金和被动指数型基金，得到 3 到 5 只符合条件的备选基金；</li><li>把这 3 到 5 只基金放入价格比工具，和沪深 300 指数比较，看哪只价格比的曲线斜率更高，走势更平稳。</li><li>根据你的风险偏好，选出最适合你的那只基金。</li><li>在配置美股资产的时候，我建议直接选被动指数基金，既省心效果也不错投资美股时，投资 QDII 被动指数基金是一个兼顾收益率和便捷性的选择；</li></ul><h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><p>对于波动性比较小的债基，不同时点的建仓成本变化不大，所以没必要定投，直接一步到位就可以，分批定投反而会错失债券的时间收益。对于波动性比较大的股票型基金，比如说国内的普通股票型基金和标普 500 的指数基金，是可以考虑在 3 个月到半年这样的时间尺度上分批建仓的，因为这样可以平滑掉你的建仓时点选择的风险。另外，如果你的可投现金流是按月收到的，那就没得选，只能是定投，每月收到一笔钱投一笔。</p><p>作为普通投资者，只要我们在购买基金的时候进行了充足的分析，是没有必要在平时频繁查看这个配置组合的。我们只需要每隔一个季度，或者在市场出现大幅波动的时候，计算一下基金组合在几类资产上的配置比例是否因为价格的变化偏离过大。如果偏离不多，就可以不用管，如果偏离得比较大了，就把它再平衡一次，重新调回初始比例。</p><h3 id="个人投资计划"><a href="#个人投资计划" class="headerlink" title="个人投资计划"></a>个人投资计划</h3><p>每月平均投资1万（每月6000定投股值+每季度12000的债券）一个季度3万&#x3D; 3*6000+12000 &#x3D; 30000</p><h4 id="主动型占比30-，-月投入3000："><a href="#主动型占比30-，-月投入3000：" class="headerlink" title="主动型占比30%， 月投入3000："></a>主动型占比30%， 月投入3000：</h4><ul><li>000803 工银研究精选股票 - 10% (每两周四定投500) </li><li><a href="http://fund.eastmoney.com/001070.html">建信信息产业股票 (001070)</a>–10%（每两周四定投500）； </li><li>700003 平安策略先锋混合  —10%（每两周四定投500）</li></ul><h4 id="混合型占比10"><a href="#混合型占比10" class="headerlink" title="混合型占比10%"></a>混合型占比10%</h4><ul><li>易方达安心回馈（偏债） 10% （每两周四定投500）</li></ul><h4 id="美股-20"><a href="#美股-20" class="headerlink" title="美股 20%"></a>美股 20%</h4><ul><li>博时标普500ETF联接A(050025  20%  （每两周四定投1000）</li></ul><h4 id="债券-40"><a href="#债券-40" class="headerlink" title="债券 40%"></a>债券 40%</h4><ul><li>天弘永利债券A(420002)-10%（每个季度投入3000）</li><li><a href="http://fund.eastmoney.com/000297.html">鹏华可转债债券A</a> – 10% （每季度3000）</li><li>160513 博时稳健回报债券  – 20%（每季度投入6000）</li></ul><h4 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h4><ul><li>每个季度做一次再平衡</li><li>每个月检验一次支点： 是否五星评级，最大回撤不能超过15%，基金经理没有变动，</li></ul><h4 id="是买点吗"><a href="#是买点吗" class="headerlink" title="是买点吗"></a>是买点吗</h4><p>遇到买点（后期看涨），买也行，不买也行，不卖 </p><p>遇到卖点（后期看空），卖也行，不卖也行，不要买</p>]]></content>
    
    
    <summary type="html">投资理财组合</summary>
    
    
    
    <category term="SoftSkills" scheme="http://amazingcoderpro.github.io/categories/SoftSkills/"/>
    
    <category term="Trade" scheme="http://amazingcoderpro.github.io/categories/SoftSkills/Trade/"/>
    
    
    <category term="softskills" scheme="http://amazingcoderpro.github.io/tags/softskills/"/>
    
    <category term="trade" scheme="http://amazingcoderpro.github.io/tags/trade/"/>
    
  </entry>
  
  <entry>
    <title>短线技巧跟庄，长线看趋势</title>
    <link href="http://amazingcoderpro.github.io/2021/06/08/SoftSkills/Trade/%E7%9F%AD%E7%BA%BF%E6%8A%80%E5%B7%A7%E8%B7%9F%E5%BA%84%EF%BC%8C%E9%95%BF%E7%BA%BF%E7%9C%8B%E8%B6%8B%E5%8A%BF/"/>
    <id>http://amazingcoderpro.github.io/2021/06/08/SoftSkills/Trade/%E7%9F%AD%E7%BA%BF%E6%8A%80%E5%B7%A7%E8%B7%9F%E5%BA%84%EF%BC%8C%E9%95%BF%E7%BA%BF%E7%9C%8B%E8%B6%8B%E5%8A%BF/</id>
    <published>2021-06-08T07:29:00.000Z</published>
    <updated>2021-10-08T07:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="短线技巧跟庄，长线看趋势"><a href="#短线技巧跟庄，长线看趋势" class="headerlink" title="短线技巧跟庄，长线看趋势"></a>短线技巧跟庄，长线看趋势</h1><h3 id="短线技巧跟庄，长线看趋势-1"><a href="#短线技巧跟庄，长线看趋势-1" class="headerlink" title="短线技巧跟庄，长线看趋势"></a>短线技巧跟庄，长线看趋势</h3><h3 id="风险识别"><a href="#风险识别" class="headerlink" title="风险识别"></a>风险识别</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxnhza25iwj31fu0u0q6w.jpg" alt="image-20211223091107242"></p><h3 id="二次突破"><a href="#二次突破" class="headerlink" title="二次突破"></a>二次突破</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxni7emwx5j31e10u0n2m.jpg" alt="image-20211223092128192"></p><h3 id="lt-自律的交易者-gt"><a href="#lt-自律的交易者-gt" class="headerlink" title="&lt;自律的交易者&gt;"></a>&lt;自律的交易者&gt;</h3><p>心态80%+20%技术</p>]]></content>
    
    
    <summary type="html">短线技巧跟庄，长线看趋势</summary>
    
    
    
    <category term="SoftSkills" scheme="http://amazingcoderpro.github.io/categories/SoftSkills/"/>
    
    <category term="Trade" scheme="http://amazingcoderpro.github.io/categories/SoftSkills/Trade/"/>
    
    
    <category term="softskills" scheme="http://amazingcoderpro.github.io/tags/softskills/"/>
    
    <category term="trade" scheme="http://amazingcoderpro.github.io/tags/trade/"/>
    
  </entry>
  
  <entry>
    <title>股票资金管理</title>
    <link href="http://amazingcoderpro.github.io/2021/06/08/SoftSkills/Trade/%E8%82%A1%E7%A5%A8%E8%B5%84%E9%87%91%E7%AE%A1%E7%90%86/"/>
    <id>http://amazingcoderpro.github.io/2021/06/08/SoftSkills/Trade/%E8%82%A1%E7%A5%A8%E8%B5%84%E9%87%91%E7%AE%A1%E7%90%86/</id>
    <published>2021-06-08T07:29:00.000Z</published>
    <updated>2021-10-08T07:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="股票资金管理"><a href="#股票资金管理" class="headerlink" title="股票资金管理"></a>股票资金管理</h1><h2 id="理财配置"><a href="#理财配置" class="headerlink" title="理财配置"></a>理财配置</h2><p>富人投资比例：</p><p>家庭总的可支配收入减去家庭每年必须支出的费用（房贷，车贷，生活费）（也可以按月算），然后剩下的钱按下面的比例进行配置：</p><p>稳定无风险投资&#x2F;股票基金有一定风险的&#x2F;风投(高风险高收益)：</p><p>富人：6&#x2F;3&#x2F;1或5&#x2F;4&#x2F;1</p><p>普通人可以按：6&#x2F;4, 7&#x2F;3 来配置。</p><h2 id="主动、被动投资"><a href="#主动、被动投资" class="headerlink" title="主动、被动投资"></a>主动、被动投资</h2><p>指数型：沪深300ETF， 上证50ETF， 不要增强型, 长年可以跑赢大盘</p><p>基金也分：长期持有或波段操作，把k线用上来。</p><h2 id="仓位管理"><a href="#仓位管理" class="headerlink" title="仓位管理"></a>仓位管理</h2><p>基金分两仓</p><p>股票初期分四仓，每仓投入四分之一</p><h2 id="投资计划"><a href="#投资计划" class="headerlink" title="投资计划"></a>投资计划</h2><p>胜兵先胜而后求战，败兵先战而后求胜<br>年度计划-》月度计划-》分解<br>短线!&#x3D;高风险!&#x3D;低收益!&#x3D;不稳定<br>长线!&#x3D;低风险!&#x3D;高收益!&#x3D;稳定<br>做长线还是短线取决于你的计划，你的精力投入。</p><p>先长后短</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxklf1t8crj30wa0gyq4y.jpg" alt="image-20211220205552653"></p><h2 id="done第一阶段"><a href="#done第一阶段" class="headerlink" title="done第一阶段"></a>done第一阶段</h2><h3 id="亢龙有悔-大盘上用"><a href="#亢龙有悔-大盘上用" class="headerlink" title="亢龙有悔-大盘上用"></a>亢龙有悔-大盘上用</h3><p>上涨回调更好，个股不确定因素太多</p><p>胜率80%， 盈亏比5：1， 所以机会很少</p><p>个股上如果用，找上升通道的， 慎用，成功率不高</p><p>个股两个形态：1. 底部反弹型：极速下跌，三根阴，有跳空更好，至少有一根大阴线， 在熊市末期反抽。</p><ol start="2"><li>大趋势上涨，回调时出现，可以用。</li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxdricotnej30x00ke3zo.jpg" alt="image-20211214230739676"></p><p>大盘上找模型，个股上选：在上证50或沪深300成分股选， 第四日开盘买入</p><p>阶段一：无脑拿十天卖出</p><p>空间洗盘：低开高收不正常，是强庄所为</p><p>要点精讲补充条件（越像标准模型越好，以下条件越多符合越好）：</p><ul><li>小阴线最好不被大阴线包含：实体被包含，最低价–最高价之间也被包含，不好， 拿不到十天</li><li>小阴线与大阴线对比越明显越好</li><li>大阴线最好跳空低开（实体不接就可以）</li><li>阳线的实体最好偏小， 如果太大，后续涨幅可能不会太大</li><li>全部3根k线的上影线都不要太长</li></ul><p>卖点在大盘和个股上看都可以，有一个出现就算：</p><ul><li>5日或10日内大阳线收盘价</li><li>任意阴线</li></ul><p>止损设置：</p><ul><li>跌破三根k线的最低价， 适用于大盘</li></ul><p>个人感悟：</p><ul><li>适合基本面没问题，蓝筹股，盘整震荡的个股</li><li>越不符合标准模型，拿的时间越短</li><li>要分仓，要设置止损，提前做好交易计划，根据和模型的匹配度来大致确定拿多久</li></ul><h3 id="扩展模型：七星落长空，一般在行情底部，直接用在个股上，不管阴线阳线的大小，次日开盘买入。不管三阴之前是啥。涨了就能卖，-不设止损。"><a href="#扩展模型：七星落长空，一般在行情底部，直接用在个股上，不管阴线阳线的大小，次日开盘买入。不管三阴之前是啥。涨了就能卖，-不设止损。" class="headerlink" title="扩展模型：七星落长空，一般在行情底部，直接用在个股上，不管阴线阳线的大小，次日开盘买入。不管三阴之前是啥。涨了就能卖， 不设止损。"></a>扩展模型：七星落长空，一般在行情底部，直接用在个股上，不管阴线阳线的大小，次日开盘买入。不管三阴之前是啥。涨了就能卖， 不设止损。</h3><p>一般出现了大多是底部， 如果要设止损，就设在这段k线的最低价</p><p>纯时间理论，只看时间，只看阴阳。阴阳真假都能用， 大小也无所谓， 高开低开都行，</p><p><strong>位置注意要在一段下跌后的底部，短线抄底，吃到利润就走。</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxe94kybpqj31820u0mzf.jpg" alt="image-20211215091716469"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxelace9uej30re0ggabq.jpg" alt="image-20211215161758658"></p><p>胜率，盈亏比<br><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxea2u8pepj30og0cqwev.jpg" alt="image-20211215094834440"></p><h2 id="价值投资与技术分析"><a href="#价值投资与技术分析" class="headerlink" title="价值投资与技术分析"></a>价值投资与技术分析</h2><h3 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxeaagliqij30z00jqq4c.jpg" alt="image-20211215095730361"></p><h3 id="风险识别，量价关系"><a href="#风险识别，量价关系" class="headerlink" title="风险识别，量价关系"></a>风险识别，量价关系</h3><h4 id="诱多阳线"><a href="#诱多阳线" class="headerlink" title="诱多阳线"></a>诱多阳线</h4><ul><li>经常在顶部出现，物极必反的疯狂拉升</li><li>缩量的大阳线，相比昨天</li><li>阳线变动更大，但是量能反而小了</li></ul><h3 id="技术面和基本面结合"><a href="#技术面和基本面结合" class="headerlink" title="技术面和基本面结合"></a>技术面和基本面结合</h3><p>选公司既要有热点还有看看有没有实力</p><p>上涨过程中抄底，不要在下跌过程抄底，买在底部也不一定涨，可能是横盘很久。应该在上涨突破时买入。</p><p>基金就买沪深300和上证50， 不要增强，场内可以做波段。</p><h3 id="被套和拿不住"><a href="#被套和拿不住" class="headerlink" title="被套和拿不住"></a>被套和拿不住</h3><ul><li><p>要有交易计划，包含：买点，卖点（根据行情，时间，空间），止损点，难点是找卖点。</p></li><li><p>上涨拿不住，计算预期涨幅， </p></li><li><p>移动止盈</p></li></ul><h3 id="葛式八法"><a href="#葛式八法" class="headerlink" title="葛式八法"></a>葛式八法</h3><p>下跌、盘整过程中不买，上涨过程才买，才加仓</p><p>快10， 慢60</p><h4 id="买点一"><a href="#买点一" class="headerlink" title="买点一"></a>买点一</h4><p>周k线</p><p>在沪深300指数上用很不错，基金也可以做波段</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfitdg9b6j31d20o477d.jpg" alt="image-20211216113741239" style="zoom:200%;" /><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfiu5xdu2j30jg0hs0ts.jpg" alt="image-20211216113844079"></p><h4 id="卖点1，-物极必反的急速拉升之后，价格远离价值均线，"><a href="#卖点1，-物极必反的急速拉升之后，价格远离价值均线，" class="headerlink" title="卖点1， 物极必反的急速拉升之后，价格远离价值均线，"></a>卖点1， 物极必反的急速拉升之后，价格远离价值均线，</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfj0h7he7j31cm0n6n00.jpg" alt="image-20211216114450941"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfj4s241pj319q0petbu.jpg" alt="image-20211216114854712"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfjriimhrj30g80iejsn.jpg" alt="image-20211216121048355"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfj6fyo4rj30lm0higlx.jpg" alt="image-20211216115035160"></p><h4 id="买点二，卖点二"><a href="#买点二，卖点二" class="headerlink" title="买点二，卖点二"></a>买点二，卖点二</h4><p>分仓：至少分四仓，每只股票至少分两次买入</p><p>加仓：上涨才加</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfpnga3efj30du06x74x.jpg" alt="image-20211216153431471"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfqahs6dlj319q0hedi4.jpg" alt="image-20211216155642926"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfsp4fgj3j317q0l477o.jpg" alt="image-20211216171953925"></p><p>任何一根k线收盘价不能突破到慢速均线下方， 开盘价，下影线可以突破，不要紧。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfstfipq8j317e0mm789.jpg" alt="image-20211216172402121"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfsuuhfqdj31b60n60vg.jpg" alt="image-20211216172523384"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfsyd91uhj31a00kstbp.jpg" alt="image-20211216172801373"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxft30ge53j315k0ketat.jpg" alt="image-20211216173314207"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxft5klzidj31hc0rq0yc.jpg" alt="image-20211216173543714"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxftgweh9kj31aa0mkdj5.jpg" alt="image-20211216174636374"></p><h4 id="买点3"><a href="#买点3" class="headerlink" title="买点3"></a>买点3</h4><p>弱势回调</p><p>![image-20211216175700361](&#x2F;Users&#x2F;charles&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20211216175700361.png)</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxftteejhgj31b60owdji.jpg" alt="image-20211216175834211"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxftvtl624j317e0nc0vj.jpg" alt="image-20211216180057785"></p><h4 id="买点4-尽量不做，-短线博反弹，-别勉强"><a href="#买点4-尽量不做，-短线博反弹，-别勉强" class="headerlink" title="买点4 尽量不做， 短线博反弹， 别勉强"></a>买点4 尽量不做， 短线博反弹， 别勉强</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfu244xebj31da0p00w7.jpg" alt="image-20211216180659706"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfu3u051zj31ei0q442i.jpg" alt="image-20211216180840552"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>没有买点尽量不要勉强，分仓买入，做好止损计划</p><p>行情刚开始不容易出现急速拉升，不会太快翻转</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfu4hc65bj31bq0ngdiz.jpg" alt="image-20211216180917791"></p><h3 id="止损"><a href="#止损" class="headerlink" title="止损"></a>止损</h3><ul><li>初始止损</li><li>行情止损</li><li>再推止损</li></ul><h3 id="日线神奇均线组合"><a href="#日线神奇均线组合" class="headerlink" title="日线神奇均线组合"></a>日线神奇均线组合</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxgvvr84r1j31dk0jon0s.jpg" alt="image-20211217155544077"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxi0yd1aixj31c60l077y.jpg" alt="image-20211218153640967"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxi15aoue1j314g0isjus.jpg" alt="image-20211218154324750"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxi16fa0fcj31900kogmv.jpg" alt="image-20211218154430783"></p><h4 id="风险识别，日线上高位阴包阳"><a href="#风险识别，日线上高位阴包阳" class="headerlink" title="风险识别，日线上高位阴包阳"></a>风险识别，日线上高位阴包阳</h4><h4 id="长线操作思路，避免无意义的亏损"><a href="#长线操作思路，避免无意义的亏损" class="headerlink" title="长线操作思路，避免无意义的亏损"></a>长线操作思路，避免无意义的亏损</h4><ul><li><p>短线精髓：买卖点要精准</p></li><li><p>长线精髓：买卖点要确定,不要没事天天看，别给自己找麻烦，看周线就只看周线</p></li></ul><h3 id="仓位管理，目的规避风险"><a href="#仓位管理，目的规避风险" class="headerlink" title="仓位管理，目的规避风险"></a>仓位管理，目的规避风险</h3><ul><li>分批建仓，别一上来就重仓</li><li>股票至少分四仓，进一步可以分十仓，每只股票分两到三次买入</li><li>加仓的唯一原则：顺势加仓</li><li>中线过程中可以再日线级别做加仓减仓。反向亢龙有悔可以减仓</li></ul><h3 id="神龙摆尾"><a href="#神龙摆尾" class="headerlink" title="神龙摆尾"></a>神龙摆尾</h3><p>目标价位是涨停板收盘价*1.5</p><p>止损价格是涨停板开盘价</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxidy99drjj31bu0n8ac6.jpg" alt="image-20211218230623717"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxie3qi0n2j31bi0iigo2.jpg" alt="image-20211218231142384"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxie91xatkj319i0lcjti.jpg" alt="image-20211218231650044"></p><p>第一段的横盘超过一个月，第二个横盘一般超过一周，出现阳线，成交量必须比前一天明显放大</p><ul><li>分仓投入+分批建仓+过程中推止损，有条件加仓或减仓</li><li>交易计划让你心里踏实，有理有据，不是赌徒，事后回顾复盘</li></ul><h3 id="量价时空"><a href="#量价时空" class="headerlink" title="量价时空"></a>量价时空</h3><ul><li><p>箱体理论：收盘价跌破或涨过箱体上下沿。箱体上下沿是最高价和最低价</p></li><li><p>箱体等高上下移</p></li><li><p><strong>空间理论在个股上不好用，用在大盘上比较好</strong></p></li></ul><h3 id="神龙摆尾2"><a href="#神龙摆尾2" class="headerlink" title="神龙摆尾2"></a>神龙摆尾2</h3><p>22个交易日</p><p>买入后的实时价格探到涨停板上沿就卖出。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxiy13ycc5j31ca0notcr.jpg" alt="image-20211219104109688"></p><p>高位横盘要缩量</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxiy4qxi6mj30p20matax.jpg" alt="image-20211219104439851"></p><h4 id="以逸待劳，主力洗盘"><a href="#以逸待劳，主力洗盘" class="headerlink" title="以逸待劳，主力洗盘"></a>以逸待劳，主力洗盘</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxiyjlcykkj30xw0h2mz1.jpg" alt="image-20211219105855864"></p><h3 id="一箭双雕，主力中继洗盘-后续极速拉升"><a href="#一箭双雕，主力中继洗盘-后续极速拉升" class="headerlink" title="一箭双雕，主力中继洗盘,后续极速拉升"></a>一箭双雕，主力中继洗盘,后续极速拉升</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxizwti87tj30zk0h4abw.jpg" alt="image-20211219114613341"></p><h3 id="时间-空间理论在个股上不好用，用在大盘上比较好，越大的盘子越有效"><a href="#时间-空间理论在个股上不好用，用在大盘上比较好，越大的盘子越有效" class="headerlink" title="时间 空间理论在个股上不好用，用在大盘上比较好，越大的盘子越有效"></a>时间 空间理论在个股上不好用，用在大盘上比较好，越大的盘子越有效</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxj0dn9iyej31e40se45u.jpg" alt="image-20211219120226264"></p><p>四次回踩通道下沿不破，大概率往上突破</p><h3 id="再谈资金管理"><a href="#再谈资金管理" class="headerlink" title="再谈资金管理"></a>再谈资金管理</h3><ul><li>学到一个理论，先加自选股，模拟盘，跟踪观察，记下来验证</li><li>分仓，初期至少分四仓，后续可以考虑十仓</li><li>一只股票再分两三次买入</li><li>顺势加仓</li></ul>]]></content>
    
    
    <summary type="html">股票资金管理</summary>
    
    
    
    <category term="SoftSkills" scheme="http://amazingcoderpro.github.io/categories/SoftSkills/"/>
    
    <category term="Trade" scheme="http://amazingcoderpro.github.io/categories/SoftSkills/Trade/"/>
    
    
    <category term="softskills" scheme="http://amazingcoderpro.github.io/tags/softskills/"/>
    
    <category term="trade" scheme="http://amazingcoderpro.github.io/tags/trade/"/>
    
  </entry>
  
  <entry>
    <title>GIT修炼</title>
    <link href="http://amazingcoderpro.github.io/2021/04/08/Tech/GIT%E4%BF%AE%E7%82%BC/"/>
    <id>http://amazingcoderpro.github.io/2021/04/08/Tech/GIT%E4%BF%AE%E7%82%BC/</id>
    <published>2021-04-08T07:29:00.000Z</published>
    <updated>2021-05-08T07:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GIT修炼"><a href="#GIT修炼" class="headerlink" title="GIT修炼"></a>GIT修炼</h1><h2 id="git-删除分支"><a href="#git-删除分支" class="headerlink" title="git 删除分支"></a>git 删除分支</h2><ol><li>切换到要操作的项目文件夹命令行: $ cd <ProjectPath></li><li>查看项目的<strong>分支</strong>们(包括本地和远程) …</li><li><strong>删除</strong>本地<strong>分支</strong>命令行: $ <strong>git</strong> branch -d <BranchName></li><li><strong>删除</strong>远程<strong>分支</strong>命令行: $ <strong>git</strong> push origin –delete <BranchName></li></ol><h2 id="git分支重命名"><a href="#git分支重命名" class="headerlink" title="git分支重命名"></a>git分支重命名</h2><p><strong>1. 本地分支重命名(还没有推送到远程)</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m oldName newName</span><br></pre></td></tr></table></figure><p><strong>2. 远程分支重命名 (已经推送远程-假设本地分支和远程对应分支名称相同)</strong><br> a. 重命名远程分支对应的本地分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m oldName newName</span><br></pre></td></tr></table></figure><p>b. 删除远程分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --delete origin oldName</span><br></pre></td></tr></table></figure><p>c. 上传新命名的本地分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin newName</span><br></pre></td></tr></table></figure><p>d.把修改后的本地分支与远程分支关联</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to origin/newName</span><br></pre></td></tr></table></figure><h2 id="git回滚代码"><a href="#git回滚代码" class="headerlink" title="git回滚代码"></a>git回滚代码</h2><p>只commit并未push的代码回滚</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;版本号&gt;</span><br><span class="line">或</span><br><span class="line">git reset --soft HEAD~1</span><br><span class="line">撤销最近一次的commit(撤销commit，不撤销git add)</span><br><span class="line"></span><br><span class="line">git reset --mixed HEAD~1</span><br><span class="line">撤销最近一次的commit(撤销commit，撤销git add)</span><br><span class="line"></span><br><span class="line">git reset --hard HEAD~1 </span><br><span class="line">撤销最近一次的commit(撤销commit，撤销git add，工作区的代码改动将丢失。操作完成后回到上一次commit状态)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果已经push:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行完上面的rest之后再继续</span><br><span class="line">git push origin &lt;分支名&gt; --force   // 需要有force权限</span><br></pre></td></tr></table></figure><h2 id="git-放弃本地修改"><a href="#git-放弃本地修改" class="headerlink" title="git 放弃本地修改"></a>git 放弃本地修改</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout . &amp;&amp; git clean -xdf</span><br></pre></td></tr></table></figure><h2 id="修改最后一次commits-已经push过的"><a href="#修改最后一次commits-已经push过的" class="headerlink" title="修改最后一次commits  ,已经push过的"></a>修改最后一次commits  ,已经push过的</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><h2 id="git-撤回commit"><a href="#git-撤回commit" class="headerlink" title="git 撤回commit"></a>git 撤回commit</h2><p>写完代码后，我们一般这样</p><p>git add . &#x2F;&#x2F;添加所有文件</p><p>git commit -m “本功能全部完成”</p><p>执行完commit后，想撤回commit，怎么办？</p><p>这样凉拌：</p><p>git  reset –hard HEAD</p><p>这样就成功的撤销了你的commit</p><p>注意，仅仅是撤回commit操作，您写的代码仍然保留。</p><h3 id="说一下个人理解："><a href="#说一下个人理解：" class="headerlink" title="说一下个人理解："></a>说一下个人理解：</h3><p>HEAD^的意思是上一个版本，也可以写成HEAD~1</p><p>如果你进行了2次commit，想都撤回，可以使用HEAD~2</p><h3 id="至于这几个参数："><a href="#至于这几个参数：" class="headerlink" title="至于这几个参数："></a>至于这几个参数：</h3><ul><li>–mixed</li></ul><p>意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作</p><p>这个为默认参数,git reset –mixed HEAD^ 和 git reset HEAD^ 效果是一样的。</p><ul><li>–soft</li></ul><p>不删除工作空间改动代码，撤销commit，不撤销git add . </p><ul><li>–hard</li></ul><p>删除工作空间改动代码，撤销commit，撤销git add . </p><p>注意完成这个操作后，就恢复到了上一次的commit状态。</p><h3 id="顺便说一下，如果commit注释写错了，只是想改一下注释，只需要："><a href="#顺便说一下，如果commit注释写错了，只是想改一下注释，只需要：" class="headerlink" title="顺便说一下，如果commit注释写错了，只是想改一下注释，只需要："></a>顺便说一下，如果commit注释写错了，只是想改一下注释，只需要：</h3><p>git commit –amend</p><p>此时会进入默认vim编辑器，修改注释完毕后保存就好了。</p><h2 id="git-回退本地修改"><a href="#git-回退本地修改" class="headerlink" title="git 回退本地修改"></a>git 回退本地修改</h2><p>Git checkout . &amp;&amp; git clean -xdf </p><p>git reset -soft HEAD^</p><p>忽略本地所有，和远程分支保持一致<br>git reset –hard origin&#x2F;dev&#x2F;internal_ipv6</p>]]></content>
    
    
    <summary type="html">git 常用命令梳理</summary>
    
    
    
    <category term="Tech" scheme="http://amazingcoderpro.github.io/categories/Tech/"/>
    
    
    <category term="cs" scheme="http://amazingcoderpro.github.io/tags/cs/"/>
    
    <category term="git" scheme="http://amazingcoderpro.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>周易</title>
    <link href="http://amazingcoderpro.github.io/2020/06/08/LifeEssay/%E5%91%A8%E6%98%93/"/>
    <id>http://amazingcoderpro.github.io/2020/06/08/LifeEssay/%E5%91%A8%E6%98%93/</id>
    <published>2020-06-08T07:29:00.000Z</published>
    <updated>2020-10-08T07:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="周易"><a href="#周易" class="headerlink" title="周易"></a>周易</h1><h2 id="易德"><a href="#易德" class="headerlink" title="易德"></a>易德</h2><h2 id="易理"><a href="#易理" class="headerlink" title="易理"></a>易理</h2><h2 id="易术"><a href="#易术" class="headerlink" title="易术"></a>易术</h2><h3 id="卦术"><a href="#卦术" class="headerlink" title="卦术"></a>卦术</h3><h4 id="梅花易数"><a href="#梅花易数" class="headerlink" title="梅花易数"></a>梅花易数</h4><h3 id="命理学"><a href="#命理学" class="headerlink" title="命理学"></a>命理学</h3><h4 id="四柱八字"><a href="#四柱八字" class="headerlink" title="四柱八字"></a>四柱八字</h4><h4 id="紫微斗数"><a href="#紫微斗数" class="headerlink" title="紫微斗数"></a>紫微斗数</h4><h3 id="风水学"><a href="#风水学" class="headerlink" title="风水学"></a>风水学</h3><h4 id="三元纳气"><a href="#三元纳气" class="headerlink" title="三元纳气"></a>三元纳气</h4><h4 id="玄空风水"><a href="#玄空风水" class="headerlink" title="玄空风水"></a>玄空风水</h4><h4 id="八宅"><a href="#八宅" class="headerlink" title="八宅"></a>八宅</h4>]]></content>
    
    
    <summary type="html">周易</summary>
    
    
    
    <category term="LifeEssay" scheme="http://amazingcoderpro.github.io/categories/LifeEssay/"/>
    
    
    <category term="sinology" scheme="http://amazingcoderpro.github.io/tags/sinology/"/>
    
    <category term="writ" scheme="http://amazingcoderpro.github.io/tags/writ/"/>
    
  </entry>
  
  <entry>
    <title>国学经典积累</title>
    <link href="http://amazingcoderpro.github.io/2020/06/08/LifeEssay/%E5%9B%BD%E5%AD%A6%E7%BB%8F%E5%85%B8%E7%A7%AF%E7%B4%AF/"/>
    <id>http://amazingcoderpro.github.io/2020/06/08/LifeEssay/%E5%9B%BD%E5%AD%A6%E7%BB%8F%E5%85%B8%E7%A7%AF%E7%B4%AF/</id>
    <published>2020-06-08T07:29:00.000Z</published>
    <updated>2020-10-08T07:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="国学经典积累"><a href="#国学经典积累" class="headerlink" title="国学经典积累"></a>国学经典积累</h1><h2 id="国学通识"><a href="#国学通识" class="headerlink" title="国学通识"></a>国学通识</h2><h2 id="名言警句"><a href="#名言警句" class="headerlink" title="名言警句"></a>名言警句</h2><p>[[知者不惑，仁者不忧，勇者不惧]]<br>[[无欲则刚]]</p><h2 id="风流人物"><a href="#风流人物" class="headerlink" title="风流人物"></a>风流人物</h2>]]></content>
    
    
    <summary type="html">国学经典积累</summary>
    
    
    
    <category term="LifeEssay" scheme="http://amazingcoderpro.github.io/categories/LifeEssay/"/>
    
    
    <category term="sinology" scheme="http://amazingcoderpro.github.io/tags/sinology/"/>
    
    <category term="writ" scheme="http://amazingcoderpro.github.io/tags/writ/"/>
    
  </entry>
  
  <entry>
    <title>无欲乃刚</title>
    <link href="http://amazingcoderpro.github.io/2020/06/08/LifeEssay/%E6%97%A0%E6%AC%B2%E5%88%99%E5%88%9A/"/>
    <id>http://amazingcoderpro.github.io/2020/06/08/LifeEssay/%E6%97%A0%E6%AC%B2%E5%88%99%E5%88%9A/</id>
    <published>2020-06-08T07:29:00.000Z</published>
    <updated>2020-10-08T07:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="无欲乃刚"><a href="#无欲乃刚" class="headerlink" title="无欲乃刚"></a>无欲乃刚</h1><p>人生而有欲，天经地义。但只能有正当之欲，且应加以节制。林则徐曾经说过：“海纳百川，有容乃大；壁立千仞，无欲则刚。”林则徐在禁毒时不畏凶险，把一切都置之度外。如果顾虑自己的身家性命，他是不可能完成禁毒大业的。</p><p>《史记》上说：“欲而不知止，失其所以欲；有而不知足，失其所以有。”寡欲，才能胸怀宽广、乐观旷达。</p><p>春秋时晋国的大夫祁奚，可以称得上无欲则刚的典范。</p><p>祁奚，字黄羊，春秋时期晋国大夫，历经晋国景、厉、悼、平四世，可谓四朝元老。悼公继位后，立祁奚为中军尉。平公时，复起为公族大夫。祁奚在位约60年，忠公体国，急公好义，誉满朝野，深受人们爱戴。</p><p>祁奚因年事已高，向晋悼公请求告老退休。晋悼公问祁奚：“你退休以后，谁接任你的职务较为合适呢？”</p><p>祁奚回答说：“解狐这个人可以。”晋悼公大惑不解，问道：“解狐不是跟你有仇吗？”祁奚说：“君问我谁适合担任中军尉，并非问谁是我的仇人。”</p><p>晋悼公正准备立解狐为中军尉，解狐却死了。晋悼公又征求祁奚的意见，祁奚回答说：“祁午可以任中军尉。”晋悼公见祁奚推荐祁午，于是问道：“祁午不是你的儿子吗？”祁奚回答说：“君问谁适合担任中军尉，并非问谁是我的儿子。”</p><p>祁奚在推荐继任者的问题上，外举不避仇，内举不避亲，历来为人们所称道。</p><p>后来的事实证明，祁奚的举荐确实具有独到的眼光。祁午担任中军尉后，“好学而不戏，守业而不淫，柔惠小物而镇定大事，有质直而无流心”“军无秕政”，的确是中军尉的合格人选。</p><p>祁奚以大公无私赢得朝野内外的赞誉，他的言行也随之成为衡量是非曲直的标准。</p><p>祁奚退休以后，晋国大臣范宣子审查一个叛乱案件时，抓了一个叫叔向的大臣。叔向的弟弟参与了叛乱，叔向却不是同党。</p><p>叔向有可能以叛乱罪问斩，他却一点儿也不畏惧，他说：“祁大夫外举不弃仇，内举不失亲，难道就只不管我的事吗？”</p><p>祁奚听说后，就去找范宣子，请求范宣子赦免叔向。他对范宣子说，叔向惠而有谋，是国家栋梁之才，以其弟之故而杀之，是弃国家社稷于不顾，这样做，是非常愚蠢的。范宣子听了祁奚的话，就赦免了叔向。</p><p>祁奚见目的已经达成，就准备回去。随从说，你这次专为叔向的事而来，已经办成了，你不去见一下叔向吗？祁奚认为自己救叔向是出于公心而非私谊，所以就没有见叔向而直接回家了。</p><p>叔向的一个部下准备去向祁奚道谢，叔向劝他不要去，但那个部下还是执意去了。</p><p>祁奚说：“我救叔向，不是为了他那条命，而是为了公家，我无恩于你们，你们也没有必要谢我。”</p><p>祁奚正是因为断绝私欲，才能公事公办，成就刚正美名。另一个刚正不阿、光明磊落的例子是大书法家颜真卿。</p>]]></content>
    
    
    <summary type="html">无欲乃刚</summary>
    
    
    
    <category term="LifeEssay" scheme="http://amazingcoderpro.github.io/categories/LifeEssay/"/>
    
    
    <category term="sinology" scheme="http://amazingcoderpro.github.io/tags/sinology/"/>
    
    <category term="writ" scheme="http://amazingcoderpro.github.io/tags/writ/"/>
    
  </entry>
  
  <entry>
    <title>知者不惑，仁者不忧，勇者不惧</title>
    <link href="http://amazingcoderpro.github.io/2020/06/08/LifeEssay/%E7%9F%A5%E8%80%85%E4%B8%8D%E6%83%91%EF%BC%8C%E4%BB%81%E8%80%85%E4%B8%8D%E5%BF%A7%EF%BC%8C%E5%8B%87%E8%80%85%E4%B8%8D%E6%83%A7/"/>
    <id>http://amazingcoderpro.github.io/2020/06/08/LifeEssay/%E7%9F%A5%E8%80%85%E4%B8%8D%E6%83%91%EF%BC%8C%E4%BB%81%E8%80%85%E4%B8%8D%E5%BF%A7%EF%BC%8C%E5%8B%87%E8%80%85%E4%B8%8D%E6%83%A7/</id>
    <published>2020-06-08T07:29:00.000Z</published>
    <updated>2020-10-08T07:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知者不惑，仁者不忧，勇者不惧"><a href="#知者不惑，仁者不忧，勇者不惧" class="headerlink" title="知者不惑，仁者不忧，勇者不惧"></a>知者不惑，仁者不忧，勇者不惧</h1><h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p>《论语·子罕》：子曰：”知者不惑，仁者不忧，勇者不惧。”</p><h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><p>孔子说：“智慧的人不疑惑，仁德的人不忧愁，勇敢的人不畏惧。”<br>意思是说:有仁爱之心的人,不会有忧愁,他会用宽容来对待给他带来忧愁的人和事;有大智大慧的人,遇见有迷惑的事物,不解的地方,他会利用他的聪明才智去求得解决问题的方法;勇敢的人,面对强敌,是不会有所畏惧的,他会义无反顾的去迎接挑战.</p><h2 id="典故"><a href="#典故" class="headerlink" title="典故"></a>典故</h2><p>有一次孔子的弟子司马牛请教如何去做一个君子，孔子回答说：“君子不忧愁，不恐惧”。司马牛不大明白，接着又问：“不忧愁不恐惧，这样就可以称作君子了吗？”孔子的回答是：“内省不疚，夫何忧何惧？”也就是说，如果自己问心无愧，那有什么可以忧愁和恐惧的呢？当然，君子坦荡荡，不仅是一个行为端正的问题，同时也来自于人的内在品德。古人认为，君子有三种基本品德——仁爱、智慧和勇敢。孔子说：“仁者不忧，智者不惑，勇者不惧”，也就是说人如果有着一颗博爱之心，有着高远的人生智慧，有着勇敢坚强的意志，那么他就必然会具有良好的心理和精神状态，从而心底宽广、胸怀坦荡。</p><h2 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h2><p>在儒家传统道德中，智、仁、勇是三个重要的范畴，也是仁之精神境界的不同体现，是君子的基本品质。《礼记·中庸》说：“知、仁、勇，三者天下之达德也。”有智慧的人能将事理看得明白透彻，所以不会迷惑。仁者存公心，去私欲，乐天知命，不患得患失，所以不忧虑。有勇气的人不畏惧困难，见义勇为，所以不惧。</p><h2 id="古为今用"><a href="#古为今用" class="headerlink" title="古为今用"></a>古为今用</h2><p>作为近代中国启蒙思想家、教育家的梁启超，他的九个孩子个个俊秀，皆成大才。关于教育，关于做人，梁先生就很好的践行了孔子的话，他认为“知育要教到人不惑，情育要教到人不忧，意育要教到人不惧。”</p><p>下面是梁启超先生于1922年在苏州学生联合会上的讲演部分内容整理所得, 他对于教育的目的、方法做了详细的阐述，他引用孔老夫子说过的“知者不惑，仁者不忧，勇者不惧”，认为教育应分为知育、情育、意育三方面，现在讲的知育、德育、体育不对，德育范围太笼统，体育范围太狭隘。知育要教导人不惑，情育要教导人不忧，意育要教导人不惧。教育家教学生，应该以这三件为究竟。我们自动的自己教育自己，也应该以这三件为究竟。</p><p>那么如何做到以上三点？</p><p>首先，怎样才能不惑呢？最要紧的是养成我们的判断力。想要养成判断力︰第一步，最少须有相当的常识﹔进一步，对于自己要做的事须有专门知识﹔再进一步，还须有遇事能判断的智慧。假如一个人连常识都没有了，听见打雷，说是雷公发威﹔看见月蚀，说是蛤蟆贪嘴。那么，一定闹到什么事都没有主意，成了最可怜的人了。学校里小学、中学所教，就是要人有了许多基本的常识，免得凡事都暗中摸索。但仅仅有这点常识还不够。我们做人，总要各有一件专门职业。这职业也并不是我一人破天荒去做，从前已经许多人做过。他们积了无数经验，发现出好些原理、原则，这就是专门学识。我打算做这项职业，就应该有这项专门学识。例如我想做农吗？怎样的改良土壤，怎样的改良种子，怎样的防御水罕、病虫‥‥等等，都是前人经验有得成为学识的。我们有了这种学识，应用他来处置这些事，自然会不惑﹔反是则惑了。教育家、军事家‥‥等等，都各各有他的专门学识，也是如此。我们在高等以上学校所求得的知识，就是这一类。但专靠这种常识和学识就够吗？还不能。宇宙和人生是活的，不是呆的﹔我们每日所碰见的事理，是复杂、变化的，不是单纯的、印板的。倘若我们只是学过这一件才懂这一件，那么，碰著一件没有学过的事来到跟前，便手忙脚乱了。所以还要养成总体的智慧，才能得有根本的判断力。这种总体的智慧如何才能养成呢？第一件，要把我们向来粗浮的脑筋，着实磨练他，叫他变成细密而且踏实﹔那么，无论遇着如何繁难的事，一定可以彻头彻尾想清楚他的条理，自然不至于惑了。第二件，要把我们向来昏浊的脑筋，着实将养他，叫他变成清明﹔那么，一件事理到跟前，我才能很从容、很莹澈的去判断他，自然不至于惑了。以上所说常识、学识和总体智慧，都是知育的要件﹔目的是教人做到“知者不惑”。</p><p>其次，怎么样才能不忧呢？为什么仁者便会不忧呢？想明白这个道理，先要知道中国先哲的人生观是怎么样。“仁”之一字，儒家人生观的全体大用都包在里头。“仁”到底是什么，很难用言语来说明。勉强下个解释，可以说是︰“普遍人格之实现。”孔子说︰“仁者，人也。”意思说是人格完成就叫做“仁”。但我们要知道︰人格不是单独一个人可以表见的，要从人和人的关系上看出来。所以“仁”字从二人，郑康成解他做“相人偶”。总而言之，要彼我交感互发，成为一体，然后我的人格才能实现。所以我们若不讲人格主义，那便无话可说﹔讲到这个主义，当然归宿到普遍人格。换句话说，宇宙即是人生，人生即是宇宙，我的人格和宇宙无二无别。体验得这个道理，就叫做“仁者”。然则这种“仁者”为什么会不忧呢？大凡忧之所从来，不外两端︰一曰忧成败，一曰忧得失。我们得着“仁”的人生观，就不会忧成败。为什么呢？因为我们知道，宇宙和人生是永远不会圆满的，所以易经六十四卦，始“乾”而终于“未济”﹔正为在这永远不圆满的宇宙中，才永远容得我们创造进化。我们所做的事，不过在宇宙进化几万里的长途中，往前挪一寸两寸，那里配说成功呢？然则不做怎么样？不做便连一寸两寸都不往前挪，那可真失败了。“仁者”看透这种道理，信得过只有不做事才算失败，凡做事便不会失败﹔所以易经说︰“君子以自强不息。”换一方面来看，他们又信得过凡事不会成功的﹔几万里路挪了一两寸，算成功吗？所以论语说︰“知其不可而为之。”你想︰有这种人生观的人，还有什么成败可说呢？</p><p>再者，我们得着“仁”的人生观，便不会忧得失。为什么呢？因为认定这件东西是我的，才有得失之可言。连人格都不是单独存在，不能明确的画出这一部分是我的，那一部分是人家的，然则那里有东西可以为我所得？既已没有东西为我所得，当然亦没有东西为我所失。我只是为学问而学问，为劳动而劳动，并不是拿学问劳动等等做手段来达某种目的— 可以为我们“所得”的。所以老子说︰“生而不有，为而不持。”“既以为人，己愈有﹔既以与人，己愈多。”你想︰有这种人生观的人，还有什么得失可忧呢？总而言之，有了这种人生观，自然会觉得“天地与我并生，而万物与我为一”﹔自然会“无入而不自得。”他的生活，纯然是趣味化、艺术化。这是最高的情感教育，目的是教人做到“仁者不忧”。</p><p>怎么样才能不惧呢？有了不惑、不忧功夫，惧当然会减少许多了。但这是属于意志方面的事。一个人若是意志力薄弱，便有很丰富的知识，临时也会用不着，便有很优美的情操，临时也会变了卦。然则意志怎样才会坚强呢？头一件须要心地光明。孟子曰︰“浩然之气，至大至刚。” “行有不慊之心，则馁矣。” 曾子曰︰“自反而不缩，虽褐寛博，吾不惴焉？自反而缩，虽千万人，吾往矣。”（曾子说：自我反省，觉得是我理屈，即使对方是穿粗衣的卑贱之人，我也不会吓唬他。自我反省，觉得理直，即使对方有千万人之众，我一定要前去和他们论个是非曲直。）俗词说得好︰“生平不作亏心事，夜半敲门也不惊。”一个人要保持勇气，须要从一切行为可以公开做起，这是第一著。第二件要不为劣等欲望所牵制。论语说︰“子曰︰‘吾未见刚者。’或对曰︰‘申枨（cheng，孔子的弟子）。’子曰︰‘枨也欲，焉得刚？’”，翻译过来就是孔子说：“我没有见过刚毅不屈的人。”有人回答说：“申枨是这样的人。”孔子说：“申枨啊，他的欲望太多，怎么能刚毅不屈？”。被物质上无聊的嗜欲东拉西扯，那么，百链钢也会变为绕指柔了。总之，一个人的意志，由刚强变为薄弱极易，由薄弱返到刚强极难。一个人有了意志薄弱的毛病，这个人可就完了。自己作不起自己的主，还有什么事可做！受别人压制，做别人奴隶，自己只要肯奋斗，终能恢复自由。自己的意志做了自己嗜欲的奴隶，那么，真是万劫沉沦，永无恢复的余地，终身畏首畏尾，成了个可怜人了。孔子说︰“和而不流，强哉矫﹔中立而不倚，强哉矫﹔国有道，不变塞焉，强哉矫﹔国无道，至死不变，强哉矫。”我老实告诉诸君吧，做人不做到如此，决不会成一个人。但是做到如此真是不容易，非时时刻刻做磨练意志的工夫不可。意志磨练得到家，自然是看着自己应做的事，一点不迟疑，扛起来便做，“虽千万人吾往矣”。这样才算顶天立地做一世人，绝不会有藏头露尾、左支右绌chu的丑态。这便是意育的目的，要人做到“勇者不惧”。</p>]]></content>
    
    
    <summary type="html">知者不惑，仁者不忧，勇者不惧</summary>
    
    
    
    <category term="LifeEssay" scheme="http://amazingcoderpro.github.io/categories/LifeEssay/"/>
    
    
    <category term="sinology" scheme="http://amazingcoderpro.github.io/tags/sinology/"/>
    
    <category term="writ" scheme="http://amazingcoderpro.github.io/tags/writ/"/>
    
  </entry>
  
  <entry>
    <title>为什么要读经典</title>
    <link href="http://amazingcoderpro.github.io/2020/06/08/SoftSkills/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AF%BB%E7%BB%8F%E5%85%B8/"/>
    <id>http://amazingcoderpro.github.io/2020/06/08/SoftSkills/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AF%BB%E7%BB%8F%E5%85%B8/</id>
    <published>2020-06-08T07:29:00.000Z</published>
    <updated>2020-10-08T07:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要读经典"><a href="#为什么要读经典" class="headerlink" title="为什么要读经典"></a>为什么要读经典</h1><p>from: Day3—《我们为什么读经典》<br>听课链接：<a href="https://jcg.h5.xeknow.com/s/i5V0J">https://jcg.h5.xeknow.com/s/i5V0J</a><br>听课密码：1210<br>date: 2023-10-22 15:55</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li>书籍分三类：<ul><li>感受性读书，陶冶情操类：比如边城，无需共读，个人体验，放松的读就可以，不用逼自己，这些书籍是给你的知识体系增加底色的。</li><li>经典书，架构性读书，适合用卡片：这类书籍像是你知识体系当中的大节点，链接了很多东西，打个比喻，普通知识是葡萄，而他是葡萄藤，可能不一定提供新的知识给你，但是他帮你搭建起知识体系，可以把你已有的知识串联、升华，让你在更高的纬度去理解过往的经验和知识，常看常新，</li><li>技能工具类：这类书籍根据实际需要去读就好，属于功利性读书、增量型读书。</li></ul></li><li>如何判断是否是经典呢：<ul><li>能提高知识维度，能够串联起一堆书，比如《动机心理学》《穷查理宝典》</li><li>一个行业或领域的起源之作，比如《卓有成效的管理者》《反脆弱》《物种起源》，这类书籍诞生于行业之初，具有通识性，大家之作，反而在后来领域细分之后再难有此大家</li><li>另一个世界，但具有同构性，比如《邓小平传》《心若菩提》。虽然可能和我们的生活离得很远，但是却有共鸣，能让你从中反省自己的生活，提升自己的心性。</li></ul></li><li>知识的周期<br>![[Pasted image 20231022160819.png]]</li><li>知识工作者的全套手艺<ul><li>选书</li><li>内化</li><li>输出：</li><li>知识体系：建立自己的知识库</li><li>写作：变现<br>  -![[Pasted image 20231022161122.png]]</li></ul></li></ul><h2 id="个人体会"><a href="#个人体会" class="headerlink" title="个人体会"></a>个人体会</h2><ul><li>我有一个经验、体验、感悟、发现</li></ul><h2 id="行动指引"><a href="#行动指引" class="headerlink" title="行动指引"></a>行动指引</h2><ul><li>当。。。时候，要。。做</li><li>1.你觉得接下来应该读哪些书？ 书籍应该分为三类 工具类：我理解为“长本事的书”：它往往可以具体解决我们当下遇到的问题和困惑，带着功利性读书可以快速扩张我们的知识增量，给我们现成的好用的工具和方法。 经典性：我理解为“长知识的书”，它提供完整的知识架构，扩充知识边界且自带体系，提高知识维度串联性很强，填补我们知识体系中的空白和缺失。比如理论、教材、科学、哲学类的书籍。 陶冶性：我理解为“长见识的书”，它是一种解离体验型，我们可以进入到作者的视角去体验他人的生活和经历，它可以提供给我们知识底色，让我们体验不一样的人生，比如传记、回忆录，历史等。 2.你觉得选书和掌握一套善思会写的方法哪个更帮到你？为什么？ 1) 善思会写是一种方法论，它是把输入的信息和内容经过内化加工后，转化成输出的外化过程。 2) 通过产出知识卡片，形成无数个锚点，把自己和书籍链接起来，把自己与他人的进行链接。 3) 通过知识卡片交朋友、读精典，与巨人对话，实现脑机连接与共振，它是由内循环（自读苦修）向外循环（分享与交流）的转化，也是把外界能量反向输入给自己的一种路径。 4) 通过选书、内化、输出、知识体系、写作，做知识的创造者，而不是知识的工作者</li></ul>]]></content>
    
    
    <summary type="html">为什么要读经典</summary>
    
    
    
    <category term="SoftSkills" scheme="http://amazingcoderpro.github.io/categories/SoftSkills/"/>
    
    
    <category term="softskills" scheme="http://amazingcoderpro.github.io/tags/softskills/"/>
    
    <category term="read" scheme="http://amazingcoderpro.github.io/tags/read/"/>
    
  </entry>
  
  <entry>
    <title>为什么要写卡片</title>
    <link href="http://amazingcoderpro.github.io/2020/06/08/SoftSkills/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%A1%E7%89%87/"/>
    <id>http://amazingcoderpro.github.io/2020/06/08/SoftSkills/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%A1%E7%89%87/</id>
    <published>2020-06-08T07:29:00.000Z</published>
    <updated>2020-10-08T07:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要写卡片"><a href="#为什么要写卡片" class="headerlink" title="为什么要写卡片"></a>为什么要写卡片</h1><p>from: Day2—《用卡片实现善思会写》<br>听课链接：<a href="https://jcg.h5.xeknow.com/s/HzDLj">https://jcg.h5.xeknow.com/s/HzDLj</a><br>听课密码：1210</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li>存入越难提取越容易</li><li>卡片即知识，卡片即知识管理，卡片即写作</li><li>方便写作， </li><li>写作就是：话题、逻辑、卡片</li><li>定期按照标签进行复习，产生新的链接，进而丰富了自己的知识体系</li><li>![[Pasted image 20231022151242.png]]</li><li>![[Pasted image 20231022152923.png]]</li><li>![[Pasted image 20231022153917.png]]</li></ul><h2 id="个人体会"><a href="#个人体会" class="headerlink" title="个人体会"></a>个人体会</h2><ul><li>如何更容易的提取知识才是难点</li></ul><h2 id="行动指引"><a href="#行动指引" class="headerlink" title="行动指引"></a>行动指引</h2><ul><li>当需要写作时可以利用卡片进行填充</li><li>![[Pasted image 20231022154316.png]]</li></ul>]]></content>
    
    
    <summary type="html">为什么要写卡片</summary>
    
    
    
    <category term="SoftSkills" scheme="http://amazingcoderpro.github.io/categories/SoftSkills/"/>
    
    
    <category term="writ" scheme="http://amazingcoderpro.github.io/tags/writ/"/>
    
    <category term="softskills" scheme="http://amazingcoderpro.github.io/tags/softskills/"/>
    
  </entry>
  
  <entry>
    <title>什么是读书卡片</title>
    <link href="http://amazingcoderpro.github.io/2020/06/08/SoftSkills/%E4%BB%80%E4%B9%88%E6%98%AF%E8%AF%BB%E4%B9%A6%E5%8D%A1%E7%89%87/"/>
    <id>http://amazingcoderpro.github.io/2020/06/08/SoftSkills/%E4%BB%80%E4%B9%88%E6%98%AF%E8%AF%BB%E4%B9%A6%E5%8D%A1%E7%89%87/</id>
    <published>2020-06-08T07:29:00.000Z</published>
    <updated>2020-10-08T07:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是读书卡片"><a href="#什么是读书卡片" class="headerlink" title="什么是读书卡片"></a>什么是读书卡片</h1><p>from: 古典少侠 Day2—《用卡片实现善思会写》<br>听课链接：<a href="https://jcg.h5.xeknow.com/s/HzDLj">https://jcg.h5.xeknow.com/s/HzDLj</a><br>听课密码：1210</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li>卡片是知识理解的最小单元</li><li>是用自己的过往的生活体验去理解知识，与自己的生活进行关联，用自己的话来整理和存储知识，方便后续的提取和使用。</li><li>卡片不是复制粘贴</li><li>卡片不应该太长，应该是一个独立的概念，字数控制在100-500之间。</li><li>![[Pasted image 20231022154143.png]]</li></ul><h2 id="个人体会"><a href="#个人体会" class="headerlink" title="个人体会"></a>个人体会</h2><h2 id="行动指引"><a href="#行动指引" class="headerlink" title="行动指引"></a>行动指引</h2><ul><li>积累知识卡片</li><li>用卡片+标签搭建自己的知识体系。</li></ul>]]></content>
    
    
    <summary type="html">什么是读书卡片</summary>
    
    
    
    <category term="SoftSkills" scheme="http://amazingcoderpro.github.io/categories/SoftSkills/"/>
    
    
    <category term="softskills" scheme="http://amazingcoderpro.github.io/tags/softskills/"/>
    
    <category term="read" scheme="http://amazingcoderpro.github.io/tags/read/"/>
    
  </entry>
  
  <entry>
    <title>金字塔思维</title>
    <link href="http://amazingcoderpro.github.io/2020/06/08/SoftSkills/%E9%87%91%E5%AD%90%E5%A1%94%E6%80%9D%E7%BB%B4%20/"/>
    <id>http://amazingcoderpro.github.io/2020/06/08/SoftSkills/%E9%87%91%E5%AD%90%E5%A1%94%E6%80%9D%E7%BB%B4%20/</id>
    <published>2020-06-08T07:29:00.000Z</published>
    <updated>2020-10-08T07:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="金字塔思维"><a href="#金字塔思维" class="headerlink" title="金字塔思维"></a>金字塔思维</h1><h2 id="为什么选金字塔"><a href="#为什么选金字塔" class="headerlink" title="为什么选金字塔"></a>为什么选金字塔</h2><ul><li>它符合人类思维基本规律</li></ul><h3 id="1-序言结构的体现"><a href="#1-序言结构的体现" class="headerlink" title="1 序言结构的体现"></a>1 序言结构的体现</h3><ul><li>拉平与听众的认识</li><li>让听众有兴趣，从已知到未知</li></ul><h3 id="2-纵向结构的体现"><a href="#2-纵向结构的体现" class="headerlink" title="2 纵向结构的体现"></a>2 纵向结构的体现</h3><ul><li>能理解</li><li>自然的疑问，回答式反应</li></ul><h3 id="2-横向结构的体现"><a href="#2-横向结构的体现" class="headerlink" title="2 横向结构的体现"></a>2 横向结构的体现</h3><ul><li>记得住</li><li>分类更容易记得住</li></ul><h2 id="结构检查表"><a href="#结构检查表" class="headerlink" title="结构检查表"></a>结构检查表</h2><h3 id="1-结论先行（用TOPS法则来检查，只有一个，结论应该是解决某个原因，而不应是一个现象"><a href="#1-结论先行（用TOPS法则来检查，只有一个，结论应该是解决某个原因，而不应是一个现象" class="headerlink" title="1 结论先行（用TOPS法则来检查，只有一个，结论应该是解决某个原因，而不应是一个现象"></a>1 结论先行（用TOPS法则来检查，只有一个，结论应该是解决某个原因，而不应是一个现象</h3><h3 id="2-上下对应（每一层次的概念都应该是对下一层思想观点的概括）"><a href="#2-上下对应（每一层次的概念都应该是对下一层思想观点的概括）" class="headerlink" title="2 上下对应（每一层次的概念都应该是对下一层思想观点的概括）"></a>2 上下对应（每一层次的概念都应该是对下一层思想观点的概括）</h3><h3 id="3-分类清楚（归纳-并（独立，完整），-演绎-串（p2p还可以，一断全断））每一组的观点都应该是属于同一个范畴"><a href="#3-分类清楚（归纳-并（独立，完整），-演绎-串（p2p还可以，一断全断））每一组的观点都应该是属于同一个范畴" class="headerlink" title="3 分类清楚（归纳-并（独立，完整）， 演绎-串（p2p还可以，一断全断））每一组的观点都应该是属于同一个范畴"></a>3 分类清楚（归纳-并（独立，完整）， 演绎-串（p2p还可以，一断全断））每一组的观点都应该是属于同一个范畴</h3><h3 id="4-排序逻辑（有逻辑顺序）"><a href="#4-排序逻辑（有逻辑顺序）" class="headerlink" title="4 排序逻辑（有逻辑顺序）"></a>4 排序逻辑（有逻辑顺序）</h3><h3 id="5-最后写序言（SCQ）情景-冲突-问题，最后写更容易对全局把握的更好，更容易出采"><a href="#5-最后写序言（SCQ）情景-冲突-问题，最后写更容易对全局把握的更好，更容易出采" class="headerlink" title="5 最后写序言（SCQ）情景-冲突-问题，最后写更容易对全局把握的更好，更容易出采"></a>5 最后写序言（SCQ）情景-冲突-问题，最后写更容易对全局把握的更好，更容易出采</h3><h2 id="清晰的表达的下一步是说服"><a href="#清晰的表达的下一步是说服" class="headerlink" title="清晰的表达的下一步是说服"></a>清晰的表达的下一步是说服</h2>]]></content>
    
    
    <summary type="html">金字塔思维</summary>
    
    
    
    <category term="SoftSkills" scheme="http://amazingcoderpro.github.io/categories/SoftSkills/"/>
    
    
    <category term="softskills" scheme="http://amazingcoderpro.github.io/tags/softskills/"/>
    
  </entry>
  
</feed>
