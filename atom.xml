<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Amazing Coder</title>
  
  <subtitle>Coding the future</subtitle>
  <link href="http://amazingcoderpro.github.io/atom.xml" rel="self"/>
  
  <link href="http://amazingcoderpro.github.io/"/>
  <updated>2024-08-15T09:50:43.445Z</updated>
  <id>http://amazingcoderpro.github.io/</id>
  
  <author>
    <name>Amazing Coder</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-107-Network-20220814-%E7%BD%91%E7%BB%9C%E4%BF%AE%E7%82%BC-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-107-Network-20220814-%E7%BD%91%E7%BB%9C%E4%BF%AE%E7%82%BC-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2024-08-15T09:50:31.529Z</published>
    <updated>2024-08-15T09:50:43.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h2><h3 id="1-如果一个内网中有多台机器同时访问外部服务是做了snat之后，回包怎么确定要回到哪台呢？"><a href="#1-如果一个内网中有多台机器同时访问外部服务是做了snat之后，回包怎么确定要回到哪台呢？" class="headerlink" title="1. 如果一个内网中有多台机器同时访问外部服务是做了snat之后，回包怎么确定要回到哪台呢？"></a>1. 如果一个内网中有多台机器同时访问外部服务是做了snat之后，回包怎么确定要回到哪台呢？</h3><ul><li>在snat的时候不仅对ip做了转换，同时对于端口号也做了转换，并在网关上保存了ip+port到源ip的映射关系，虽然回包的目的ip都一样，但是通过回包的目的端口就可以区分要回给哪个内网地址。 </li><li>那如果对于没有端口号的网络协议呢，比如icmp, 用type+code的方式来区分，其他类似网络协议也是同理，通过一些特殊标记来区分</li></ul><h3 id="2-Tcp-udp最大的区别"><a href="#2-Tcp-udp最大的区别" class="headerlink" title="2. Tcp, udp最大的区别"></a>2. Tcp, udp最大的区别</h3><p><a href="https://www.youtube.com/watch?v=Iuvjwrm_O5g">https://www.youtube.com/watch?v=Iuvjwrm_O5g</a></p><ul><li><p>tcp是面向链接的，upd不是。 类别打电话和写信，在不考虑速度的情况下，他们的区别就类似tcp和udp的区别。tcp用于需要可靠链的，稳定可靠的。</p></li><li><p>tcp如何保证链接过程的有效性的呢：三次握手，传输确认， 四次挥手。</p></li><li><p>三次握手的必要性：如果换成二次握手，没有最后的ack, 那假如客户端向服务端发送一个syn1包， 然后由于网络原因这个syn包没有到达服务端， 然后客户端会重新发送一个syn2包，然后服务端收到了这个syn2包，并回复了syn+ack建起了链接 , 这时如果原来的那个syn1也到达了服务端，服务端认为是客户端又发起了一个链接请求， 会回复syn+ack , 然后建立起了一个新的链接。并等待接受数据。而在客户端认为只有一个链接，两边的状态不一致。如果在三次握手的情况下， 服务端收不到最后的ack，自然不会认为链接建立成功。所以三次握手本质上就是为了解决网络信道不可靠的问题，为了能够在不可靠的信道上建立起可靠的链接。经过三次握手后， 客户端和服务端都进入了数据传输状态。</p></li><li><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h56o45kg2fj20wo0t8tb2.jpg" alt="image-20220814223240813" style="zoom:50%;" /></li><li><p>分包之后的丢包或者乱序的问题怎么解决：通过序列号和长度。 ack可以一发一答，也可以累积多包后一次性应答。缺失了那段就要求重传哪一段。另外tcp是全双工的， 这个机制不区分客户端和服务端，都采用这个机制。</p><img src="/Users/charles/data/01_CSIG/03_工作总结/01_朝花夕拾/e6c9d24ely1h56ogt9lv1j21800u0jw1.jpg" alt="image-20220814224608503" style="zoom:50%;" /></li><li><p>四次挥手：处于链接状态的客户端和服务端都可以发起关闭链接的请求。</p><ul><li>Fin-wait-2状态，服务端还可以继续发送未完成的数据包，客户端也可以接受数据。待服务端发送完数据之后，发送一个fin包，</li><li>主动断开方进入time_wait状态后，等待超时后关闭链接。而服务端收到最后一个ack之后立刻断开链接。主动方等待超时时间是为保障对端收到了最后一个ack, 如果不等待，那么一旦ack在网络中丢失，那么对端就一直处于last-ack状态。如果等待，服务端一直收不到ack则会重发fin包， 这样客户端就可以再次响应fin，回复ack，并刷新超时时间。和三次握手一样，也是为了在不可靠的网络中进行可靠的连接断开确认。</li></ul><img src="/Users/charles/data/01_CSIG/03_工作总结/01_朝花夕拾/e6c9d24ely1h56olmh236j21kd0u0q8o.jpg" alt="image-20220814225047711" style="zoom:50%;" /></li><li><p>Udp: 非连接，无状态，简单封装后直接发出， 性能损耗少，资源占用少，稳定性若，速度快，不能保证不丢包。 udp用于速度快，不care丢包， 还有隧道网络，如vpn,vxlan.</p></li></ul><h3 id="tun网卡，只有ip没有Mac"><a href="#tun网卡，只有ip没有Mac" class="headerlink" title="tun网卡，只有ip没有Mac"></a>tun网卡，只有ip没有Mac</h3><h3 id="3-SDN介绍"><a href="#3-SDN介绍" class="headerlink" title="3. SDN介绍"></a>3. SDN介绍</h3><p><a href="https://www.youtube.com/watch?v=0_LYsGKStJI">乾颐堂大话云计算架构第二季 SDN </a></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h58vg7z764j20w10joacc.jpg" alt="image-20220816201854753"></p><p>下一步：基于意图的网络   诉求–》控制器–》设备  更平滑，不关心下面的实现，兼容更多的设备型号</p><h4 id="传统数据中心架构"><a href="#传统数据中心架构" class="headerlink" title="传统数据中心架构"></a>传统数据中心架构</h4><p>top of rack switches–&gt;aggregation layer switches<br>end of row switches<br>南北向流量n-s: 客户在北， 数据中心在南</p><h4 id="虚拟化数据中心架构"><a href="#虚拟化数据中心架构" class="headerlink" title="虚拟化数据中心架构"></a>虚拟化数据中心架构</h4><p>东西流量：web-&gt;app server-&gt;db, 服务器之间的流量<br>spine and leaf架构 扁平化。利于东西访问</p><h4 id="SDN为什么要吧数据平面和控制平面分开"><a href="#SDN为什么要吧数据平面和控制平面分开" class="headerlink" title="SDN为什么要吧数据平面和控制平面分开"></a>SDN为什么要吧数据平面和控制平面分开</h4><p>传统网络独立配置，独立控制，容易出错</p><p>集中控制， 网络可编程, 自定义</p><p>openflow 开源南向控制协议</p><h4 id="发展路线"><a href="#发展路线" class="headerlink" title="发展路线"></a>发展路线</h4><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h58s9attf6j20yq0g5q5k.jpg" alt="image-20220816182747661"></p><h4 id="overlay-underlay"><a href="#overlay-underlay" class="headerlink" title="overlay underlay"></a>overlay underlay</h4><p>Overlay: vxlan、 gre </p><p>Underlay: ospf, bgp, is-is,  路由可达即可</p><h4 id="sdn与nfv"><a href="#sdn与nfv" class="headerlink" title="sdn与nfv"></a>sdn与nfv</h4><p>Nfv: net function virtualization, not network virtualization.  把网络功能移植到标准的虚拟服务器上</p><p>网络虚拟化： vlan, vxlan, vrf</p><p>网络功能虚拟化：把某些网络功能移植到标准的虚拟服务器上， 路由器，防火墙，负载均衡等。 降低成本+现在的硬件计算能力也够</p><p>Sdn nfv区别：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h58wd3elt4j20z50e0dip.jpg" alt="image-20220816205033627"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h58wcyi8vyj20x20jndit.jpg" alt="image-20220816205000884"></p><p>Sdn 和nfv本质上是不同层面的东西。 sdn是用来控制与数据分离， nfv是用通用服务器来虚拟化特定的网络功能，比如防火墙等。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h58wi78athj20pe0luac7.jpg" alt="image-20220816205522778"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础问题&quot;&gt;&lt;a href=&quot;#基础问题&quot; class=&quot;headerlink&quot; title=&quot;基础问题&quot;&gt;&lt;/a&gt;基础问题&lt;/h2&gt;&lt;h3 id=&quot;1-如果一个内网中有多台机器同时访问外部服务是做了snat之后，回包怎么确定要回到哪台呢？&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="100_CodingSkills" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/"/>
    
    <category term="107_Network" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/107-Network/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-108-Coding-00-CodingInterview/"/>
    <id>http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-108-Coding-00-CodingInterview/</id>
    <published>2024-08-15T09:50:31.529Z</published>
    <updated>2024-08-15T09:50:43.445Z</updated>
    
    <content type="html"><![CDATA[<hr><p>00_CodingInterview<br>aliases:<br>tags: #cs#interview #coding<br>date: 2023-10-08 15:29</p><hr><p>编程题本身不考察算法掌握程度，但是考察基本的逻辑思维，把算法转换为代码的能力，以及基本的错误处理。现场面试用纸笔，白板，电脑都可以，远程面试可以用在线代码平台，比如<a href="http://collabedit.com/">collabedit</a>，<a href="https://codeshare.io/">codeshare.io</a>，<a href="https://codeinterview.io/">codeinterview.io</a><br>复杂的算法不太容易验证，二十行内能解决的不太复杂的算法题为宜，速度越快越好，代码不能有明显的语法错误和低级错误</p><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h2><h3 id="关于快速排序"><a href="#关于快速排序" class="headerlink" title="关于快速排序"></a>关于快速排序</h3><ul><li>cpp sort函数内部是什么</li></ul><p>sort函数内部使用快速排序算法实现，它的时间复杂度为O(nlogn)，是一种非常高效的排序算法。</p><ul><li><p>快排的原理</p><ul><li>选择一个基准元素。</li><li>将小于等于基准元素的元素移动到数组左边，大于基准元素的元素移动到数组右边，这个过程称为划分。</li><li>递归地对划分后的左右两个子序列进行排序。</li></ul></li><li><p>在实际实现中，sort函数还有一些优化，例如：</p><ul><li>当排序的元素个数小于一定阈值时，使用插入排序算法。</li><li>当出现大量重复元素时，使用三向划分快速排序算法。</li></ul></li><li><p>为什么选快排<br>  默认它的分布是比较随机的那种分布，然后快排在比较随机的分布上，表现的比较好，速度比较快</p></li><li></li><li></li><li><p>栈的简单实现 push pop功能</p></li><li><p>栈、队列区别，用数组实现栈</p></li><li><p>二叉树深度、广度遍历</p></li></ul><h2 id="2-上机"><a href="#2-上机" class="headerlink" title="2. 上机"></a>2. 上机</h2><h3 id="2-1-算法与数据结构"><a href="#2-1-算法与数据结构" class="headerlink" title="2.1 算法与数据结构"></a>2.1 算法与数据结构</h3><ul><li><p>c++反转单链表。</p></li><li><p>非递归实现二叉树</p></li><li><p>写一个实现字符串拷贝的函数。给定字符串拷贝函数strcpy的原型：<br>char *strcpy(char *dest,const char *src); 要求：（1）不调用任何库函数。（2）说明函数为什么返回char *.<br> <code> char *strcpy(char *dest,char *src) &#123;  if( (dest == NULL) || (src == NULL) )  &#123;  return NULL;  &#125;  char *ret_string = dest;  while( *dest ++ = *src++)!=’\0′);  return ret_string;  &#125; </code></p></li><li><p>链表逆序</p></li><li><p>二叉树求宽度&#x2F;深度</p></li><li><p>字符串处理：Split, Trim，逆序</p></li><li><p>编码：UTF8编解码，Varint编解码，十六进制编解码</p></li><li><p>数组去重，保持顺序 [1, 2, 3, 1, 2] -&gt; [1, 2, 3]</p></li><li><p>数组去重，保持顺序，后面的出现后，前面的去掉，[1, 2, 3, 2, 1] -&gt; [3, 2, 1]</p></li><li><p>位图中查找第一个设置&#x2F;未设置的位的偏移量</p></li><li><p>手写 LRU</p></li></ul><h3 id="2-2-接口设计"><a href="#2-2-接口设计" class="headerlink" title="2.2  接口设计"></a>2.2  接口设计</h3><h4 id="比如String类的接口设计（构造函数，拷贝，赋值，拼接等）"><a href="#比如String类的接口设计（构造函数，拷贝，赋值，拼接等）" class="headerlink" title="比如String类的接口设计（构造函数，拷贝，赋值，拼接等）"></a>比如String类的接口设计（构造函数，拷贝，赋值，拼接等）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">String</span>();</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* str);</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">String</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span>* str);</span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(<span class="type">const</span> String&amp; other);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接运算符</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span>* str);</span><br><span class="line">    String&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> String&amp; other);</span><br><span class="line">    <span class="keyword">friend</span> String <span class="keyword">operator</span>+(<span class="type">const</span> String&amp; lhs, <span class="type">const</span> String&amp; rhs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问字符</span></span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取长度</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为C风格字符串</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_data;</span><br><span class="line">    <span class="type">size_t</span> m_length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line">String::<span class="built_in">String</span>() : <span class="built_in">m_data</span>(<span class="literal">nullptr</span>), <span class="built_in">m_length</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">String::<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* str) &#123;</span><br><span class="line">    m_length = <span class="built_in">strlen</span>(str);</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[m_length + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">String::<span class="built_in">String</span>(<span class="type">const</span> String&amp; other) &#123;</span><br><span class="line">    m_length = other.m_length;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[m_length + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">String::~<span class="built_in">String</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值运算符</span></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span>* str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (m_data != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    &#125;</span><br><span class="line">    m_length = <span class="built_in">strlen</span>(str);</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[m_length + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, str);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="type">const</span> String&amp; other) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_data != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        &#125;</span><br><span class="line">        m_length = other.m_length;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span>[m_length + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接运算符</span></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span>* str) &#123;</span><br><span class="line">    <span class="type">size_t</span> old_length = m_length;</span><br><span class="line">    m_length += <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="type">char</span>* tmp = <span class="keyword">new</span> <span class="type">char</span>[m_length + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmp, m_data);</span><br><span class="line">    <span class="built_in">strcat</span>(tmp, str);</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    m_data = tmp;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>+=(<span class="type">const</span> String&amp; other) &#123;</span><br><span class="line">    <span class="type">size_t</span> old_length = m_length;</span><br><span class="line">    m_length += other.m_length;</span><br><span class="line">    <span class="type">char</span>* tmp = <span class="keyword">new</span> <span class="type">char</span>[m_length + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmp, m_data);</span><br><span class="line">    <span class="built_in">strcat</span>(tmp, other.m_data);</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    m_data = tmp;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String <span class="keyword">operator</span>+(<span class="type">const</span> String&amp; lhs, <span class="type">const</span> String&amp; rhs) &#123;</span><br><span class="line">    <span class="function">String <span class="title">result</span><span class="params">(lhs)</span></span>;</span><br><span class="line">    result += rhs;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问字符</span></span><br><span class="line"><span class="type">char</span>&amp; String::<span class="keyword">operator</span>[](<span class="type">size_t</span> index) &#123;</span><br><span class="line">    <span class="keyword">return</span> m_data[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>&amp; String::<span class="keyword">operator</span>[](<span class="type">size_t</span> index) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m_data[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取长度</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">String::length</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为C风格字符串</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">String::c_str</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;String.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">str1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str1: &quot;</span> &lt;&lt; str1.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    String str2 = str1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str2: &quot;</span> &lt;&lt; str2.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    str2 += <span class="string">&quot;, world!&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str2 after concatenation: &quot;</span> &lt;&lt; str2.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    String str3 = str1 + str2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str3 after concatenation: &quot;</span> &lt;&lt; str3.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>用数组实现循环队列</li><li>可以考察一些函数的实现，比如String类+&#x3D;的实现，主要关注正确性和内存泄漏和越界</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;00_CodingInterview&lt;br&gt;aliases:&lt;br&gt;tags: #cs#interview #coding&lt;br&gt;date: 2023-10-08 15:29&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;编程题本身不考察算法掌握程度，但是考察基本的逻辑思维，把算法转换</summary>
      
    
    
    
    <category term="100_CodingSkills" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/"/>
    
    <category term="108_Coding" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/108-Coding/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-107-Network-20220101-%E7%BD%91%E7%BB%9C%E4%BF%AE%E7%82%BC-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-107-Network-20220101-%E7%BD%91%E7%BB%9C%E4%BF%AE%E7%82%BC-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2024-08-15T09:50:31.528Z</published>
    <updated>2024-08-15T09:50:43.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><h3 id="ipcalc"><a href="#ipcalc" class="headerlink" title="ipcalc"></a>ipcalc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipcalc 192.168.1.0/24</span><br></pre></td></tr></table></figure><h3 id="ip-addr"><a href="#ip-addr" class="headerlink" title="ip addr"></a>ip addr</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip addr add 192.168.120.125/24 dev ens3 --添加一个网络的地址,可以指定一个网络接口名字，在示例中它的名字是 ens3。这不需要去添加一个网络前缀，在本案例中，它是 /24，但是显式地添加它并没有什么坏处。你可以使用 ip 命令去检查你的配置</span><br><span class="line">ip addr</span><br></pre></td></tr></table></figure><h3 id="route"><a href="#route" class="headerlink" title="route"></a>route</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.ip_forward -- 查看路由转发是否开启,路由器必须配置去转发数据包。数据包转发默认是禁用的</span><br><span class="line">echo 1 &gt; /proc/sys/net/ipv4/ip_forward -- 开启</span><br><span class="line">sysctl -p 让变化生效</span><br><span class="line">ip route show 查看路由</span><br><span class="line">ip route add 192.168.120.0/24 via 192.168.110.126 dev ens3 -- 增加静态路由， 主机 1 可以通过路由器接口 192.168.110.126 去访问 192.168.110.0/24 网络。看一下它们是如何工作的？主机 1 和路由器需要连接到相同的地址空间，然后路由器转发到其它的网络。</span><br><span class="line">ip route del 192.168.120.0/24 删除路由</span><br></pre></td></tr></table></figure><h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.你可以使用 lsof 命令来查看某一端口是否开放。查看端口可以这样来使用，我就以80端口为例：</span><br><span class="line">lsof -i:80</span><br><span class="line">如果有显示说明已经开放了，如果没有显示说明没有开放</span><br><span class="line">2.netstat -aptn执行看看，是否监听在0.0.0.0:3306</span><br><span class="line">3.</span><br><span class="line">netstat -nupl (UDP类型的端口)</span><br><span class="line">netstat -ntpl (TCP类型的端口)</span><br><span class="line">4.查看端口的状态</span><br><span class="line">/etc/init.d/iptables status</span><br></pre></td></tr></table></figure><h3 id="Netstat-ant"><a href="#Netstat-ant" class="headerlink" title="Netstat -ant"></a>Netstat -ant</h3><p>socket Recv-Q 是否积压，积压值较大且长时间没有清空</p><p>调大 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_rmem，如果问题不能解决说明发送端发送流量确实较大，超过了接收端的处理速度，需要分流</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Network&quot;&gt;&lt;a href=&quot;#Network&quot; class=&quot;headerlink&quot; title=&quot;Network&quot;&gt;&lt;/a&gt;Network&lt;/h2&gt;&lt;h3 id=&quot;ipcalc&quot;&gt;&lt;a href=&quot;#ipcalc&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="100_CodingSkills" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/"/>
    
    <category term="107_Network" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/107-Network/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-107-Network-202201-Linux%E7%BD%91%E7%BB%9C%E8%B0%83%E4%BC%98/"/>
    <id>http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-107-Network-202201-Linux%E7%BD%91%E7%BB%9C%E8%B0%83%E4%BC%98/</id>
    <published>2024-08-15T09:50:31.528Z</published>
    <updated>2024-08-15T09:50:43.445Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h3><h3 id="数据包封装"><a href="#数据包封装" class="headerlink" title="数据包封装"></a>数据包封装</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gybyn0vik8j30rb0gcgn2.jpg" alt="image-20220113130326966"></p><h3 id="Linux网络体系"><a href="#Linux网络体系" class="headerlink" title="Linux网络体系"></a>Linux网络体系</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gybyr6kcrtj30td0etdh8.jpg" alt="image-20220113130736982"></p><h3 id="TCP处理过程"><a href="#TCP处理过程" class="headerlink" title="TCP处理过程"></a>TCP处理过程</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gybys941qlj30vz0hijtl.jpg" alt="image-20220113130838316"></p><h2 id="Socket层"><a href="#Socket层" class="headerlink" title="Socket层"></a>Socket层</h2><p>为了解决数据传输而抽象出来的机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">man socket</span><br><span class="line">mpstat 1</span><br><span class="line">perf top </span><br><span class="line">cat /proc/sys/net/ipv4/tcp_max_tw_buckets  tcp timewait最大数，（主要是占用fd, 新建连接时回收比较慢，因为要找到那个等待时间最长的time_wait， 然后重新平衡二叉树）</span><br><span class="line">echo 4096 &gt; !$</span><br><span class="line"></span><br><span class="line">设置so_linger=no : close时直接发reset, 而不是四层挥手\</span><br><span class="line">netstat -antp</span><br><span class="line">free</span><br><span class="line">slabtop -- 内核消耗的内存</span><br><span class="line"></span><br><span class="line">cat /proc/sys/net/core/wmem_default</span><br><span class="line">cat /proc/sys/net/core/rmem_max</span><br><span class="line">so_reusetport -- 多个进程可以监听一个端口</span><br><span class="line"></span><br><span class="line">三次握手，四层挥手保证面相链接</span><br><span class="line">停止等待，保证可靠（事事有回应，等ack）---但是网络利用率很低</span><br><span class="line">滑动窗口</span><br><span class="line">拥塞控制 cubki, reno, bbr</span><br><span class="line"></span><br><span class="line">tc qd add dev ens33 root netem delay 1000ms 构建一个高延时</span><br><span class="line">TCP_CORK no push , 增加吞吐，</span><br><span class="line">TCP_NODELAY  push 标记小包也发</span><br><span class="line"></span><br><span class="line">IP_TTL</span><br><span class="line">IP_MTU</span><br><span class="line">IP_TOS</span><br><span class="line"></span><br><span class="line">cat /proc/net/nf_conntrack  防火墙跟踪</span><br><span class="line"></span><br><span class="line">网卡多队列</span><br><span class="line">多个队列分别映射给多个cpu, 提高性能</span><br><span class="line">cat /proc/interrupts | less</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyh0264o2aj317n0u0q6o.jpg" alt="image-20220117214032640"></p><p>server:iperf -s -u -p 9999<br>client: iperf -c 103.145.43.51 -u -p 9999 -b 5000000</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;网络分层&quot;&gt;&lt;a href=&quot;#网络分层&quot; class=&quot;headerlink&quot; title=&quot;网络分层&quot;&gt;&lt;/a&gt;网络分层&lt;/h3&gt;&lt;h3 id=&quot;数据包封装&quot;&gt;&lt;a href=&quot;#数据包封装&quot; class=&quot;headerlink&quot; title=&quot;数据包封装&quot;&gt;</summary>
      
    
    
    
    <category term="100_CodingSkills" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/"/>
    
    <category term="107_Network" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/107-Network/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-107-Network-00-NetworkInterview/"/>
    <id>http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-107-Network-00-NetworkInterview/</id>
    <published>2024-08-15T09:50:31.527Z</published>
    <updated>2024-08-15T09:50:43.445Z</updated>
    
    <content type="html"><![CDATA[<hr><p>00_NetworkInterview<br>aliases:<br>tags: #cs#interview #network<br>date: 2023-10-08 15:29</p><hr><h1 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h1><h2 id="1-Basic-Concept"><a href="#1-Basic-Concept" class="headerlink" title="1. Basic Concept"></a>1. Basic Concept</h2><h3 id="TCP连接中间会有什么操作"><a href="#TCP连接中间会有什么操作" class="headerlink" title="TCP连接中间会有什么操作"></a>TCP连接中间会有什么操作</h3><p>在TCP连接中，客户端和服务器之间会进行以下操作：</p><ul><li><p>握手阶段：客户端向服务器发送SYN包（同步包），请求建立连接。服务器收到SYN包后，向客户端发送SYN+ACK包（同步确认包），表示可以建立连接。客户端收到SYN+ACK包后，再向服务器发送ACK包（确认包），表示连接建立成功。</p></li><li><p>数据传输阶段：连接建立成功后，客户端和服务器之间可以进行数据的传输。客户端向服务器发送数据包，服务器接收数据包并进行处理，然后向客户端发送响应包。客户端收到响应包后，可以再次向服务器发送数据包，以此类推。</p></li><li><p>断开连接阶段：当客户端或服务器不再需要连接时，可以发送FIN包（结束包）来请求断开连接。对方收到FIN包后，也发送FIN包进行响应，表示同意断开连接。当两端都收到对方的FIN包后，连接才真正关闭。</p></li></ul><p>需要注意的是，在TCP连接中可能会出现丢包、拥塞等情况，需要进行相应的处理，例如重传丢失的数据包、调整发送窗口大小等</p><h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><ul><li>TCP 三次握手中，客户端收到的第二次握手中 ack 确认号不是自己期望的，会发生什么？是直接丢弃 or 回 RST 报文？</li><li>什么情况下会收到不正确的 ack（第二次握手中的 ack） 呢？<br>不卖关子，直接说这个问题，是<strong>回 RST 报文</strong>。过程如下图：</li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeRVaGLU0HSwicWshvgthyXukQSF6kevWWckbxxO3pOCgfYqSVl8H7icM0zFzWD6gjg5n0mI1ETeZew/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>三次握手避免历史连接</p><p>当客户端连续发送多次建立连接的 SYN 报文，然后在网络拥堵的情况，就会发生客户端收到不正确的 ack 的情况。具体过程如下：</p><ul><li><p>客户端先发送了 SYN（seq &#x3D; 90） 报文，但是被网络阻塞了，服务端并没有收到，接着客户端又重新发送了 SYN（seq &#x3D; 100） 报文，注意不是重传 SYN，重传的 SYN 的序列号是一样的。</p></li><li><p>「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端，那么此时服务端就会回一个 SYN + ACK 报文给客户端，此报文的确认号是 91（90+1）。</p></li><li><p>客户端收到后，发行自己期望收到的确认号应该是 100+1，而不是 90 + 1，于是就会回 RST 报文。</p></li><li><p>服务端收到 RST 报文后，就会中止连接。</p></li><li><p>后续最新的 SYN 抵达了服务端后，客户端与服务端就可以正常的完成三次握手了。</p></li></ul><p>上述中的「旧 SYN 报文」称为历史连接，TCP 使用三次握手建立连接的<strong>最主要原因就是防止「历史连接」初始化了连接</strong>。</p><p>我们也可以从 RFC 793 知道 TCP 连接使用三次握手的首要原因：</p><p><em>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</em></p><p>简单来说，三次握手的首要原因是为了防止旧的重复连接初始化造成混乱。RFC 给出的三次握手防止历史连接的案例图如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeRVaGLU0HSwicWshvgthyXulbVmhSyuhoYJicsSqqzlLicN8vibzkAZB3WoAw0cCYE990DtCZckUXdwQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>RFC 793</p><p>如果是两次握手连接，就无法阻止历史连接，那<strong>为什么 TCP 两次握手为什么无法阻止历史连接呢？</strong></p><p>我先直接说结论，主要是因为<strong>在两次握手的情况下，「被动发起方」没有中间状态给「主动发起方」来阻止历史连接，导致「被动发起方」可能建立一个历史连接，造成资源浪费</strong>。</p><p>你想想，两次握手的情况下，「被动发起方」在收到 SYN 报文后，就进入 ESTABLISHED 状态，意味着这时可以给对方发送数据给，但是「主动发」起方此时还没有进入 ESTABLISHED 状态，假设这次是历史连接，主动发起方判断到此次连接为历史连接，那么就会回 RST 报文来断开连接，而「被动发起方」在第一次握手的时候就进入 ESTABLISHED 状态，所以它可以发送数据的，但是它并不知道这个是历史连接，它只有在收到 RST 报文后，才会断开连接。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeRVaGLU0HSwicWshvgthyXuHS7B2sADweWDX3rVH109Hqdw5fbYbJMetYTT3xEicicBrYiaSm7KYnPfg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>两次握手无法阻止历史连接</p><p>可以看到，上面这种场景下，「被动发起方」在向「主动发起方」发送数据前，并没有阻止掉历史连接，导致「被动发起方」建立了一个历史连接，又白白发送了数据，妥妥地浪费了「被动发起方」的资源。</p><p>因此，<strong>要解决这种现象，最好就是在「被动发起方」发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手</strong>。</p><p>我说回 RST 就回 RST 吗？当然不是了，肯定得用源码证明我说的这个结论。</p><p>听到要源码分析，可能有的同学就怂了。</p><p>其实要分析我们今天这个问题，只要懂 if else 就行了，我也会用中文来表述代码的逻辑，所以单纯看我的文字也是可以的。</p><p>这次我们重点分析的是，在 SYN_SENT 状态下，收到不正确的确认号的 syn+ack 报文是如何处理的。</p><p>处于 SYN_SENT 状态下的客户端，在收到服务端的  syn+ack 报文后，最终会调用  tcp_rcv_state_process，在这里会根据 TCP 状态做对应的处理，这里我们只关注 SYN_SENT 状态。</p><p><code>// net/ipv4/tcp_ipv4.c   int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb)   &#123;    ...         int queued = 0;          ...         switch (sk-&gt;sk_state) &#123;    case TCP_CLOSE:     ...    case TCP_LISTEN:     ...    case TCP_SYN_SENT:       ....     queued = tcp_rcv_synsent_state_process(sk, skb, th);     if (queued &gt;= 0)      return queued;       ...    &#125;   </code></p><p>可以看到，接下来，会继续调用 tcp_rcv_synsent_state_process 函数。</p><p><code>static int tcp_rcv_synsent_state_process(struct sock *sk, struct sk_buff *skb,         const struct tcphdr *th)   &#123;    ....       if (th-&gt;ack) &#123;     /* rfc793:      * &quot;If the state is SYN-SENT then      *    first check the ACK bit      *      If the ACK bit is set      *   If SEG.ACK =&lt; ISS, or SEG.ACK &gt; SND.NXT, send      *        a reset (unless the RST bit is set, if so drop      *        the segment and return)&quot;      */       // ack 的确认号不是预期的     if (!after(TCP_SKB_CB(skb)-&gt;ack_seq, tp-&gt;snd_una) ||         after(TCP_SKB_CB(skb)-&gt;ack_seq, tp-&gt;snd_nxt))         //回 RST 报文      goto reset_and_undo;        ...   &#125;      </code></p><p>从上面的函数，就可以得知了，客户端在 SYN_SENT 状态下，收到不正确的确认号的 syn+ack 报文会回 RST 报文。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><blockquote><p>TCP 三次握手中，客户端收到的第二次握手中 ack 确认号不是自己期望的，会发生什么？是直接丢弃 or 回 RST 报文？</p></blockquote><p>回 RST 报文。</p><blockquote><p>什么情况下会收到不正确的 ack（第二次握手中的 ack） 呢？</p></blockquote><p>当客户端发起多次 SYN 报文，然后网络拥堵的情况下，「旧的 SYN 报文」比「新的 SYN 报文」早抵达服务端，此时服务端就会按照收到的「旧的 SYN 报文」回复 syn+ack 报文，而此报文的确认号并不是客户端期望收到的，于是客户端就会回 RST 报文。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>虽然我们在学习 TCP 挥手时，学到的是需要四次来完成 TCP 挥手，但是<strong>在一些情况下， TCP 四次挥手是可以变成 TCP 三次挥手的</strong>。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtq0WaxOzTFbA8SQ5Am8ibRL1JMdq5GibqVeXYWOXB3gtdHAMwic01mMAOSw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>而且在用 wireshark 工具抓包的时候，我们也会常看到 TCP 挥手过程是三次，而不是四次，如下图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqh59jUuDV016elb1Z9Hn0GwfCuDdZbqm1cAn3Pf8FI7RSyficSXgT8Qg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>先来回答为什么 RFC 文档里定义 TCP 挥手过程是要四次？</p><p>再来回答什么情况下，什么情况会出现三次挥手？</p><h4 id="为什么-TCP-挥手需要四次？"><a href="#为什么-TCP-挥手需要四次？" class="headerlink" title="为什么 TCP 挥手需要四次？"></a>为什么 TCP 挥手需要四次？</h4><p>TCP 四次挥手的过程如下：<br>![[Pasted image 20230518120138.png]]</p><p>具体过程：</p><ul><li><p>客户端主动调用关闭连接的函数，于是就会发送 FIN 报文，这个  FIN 报文代表客户端不会再发送数据了，进入 FIN_WAIT_1 状态；</p></li><li><p>服务端收到了 FIN 报文，然后马上回复一个 ACK 确认报文，此时服务端进入 CLOSE_WAIT 状态。在收到 FIN 报文的时候，TCP 协议栈会为 FIN 包插入一个文件结束符 EOF 到接收缓冲区中，服务端应用程序可以通过 read 调用来感知这个 FIN 包，这个 EOF 会被<strong>放在已排队等候的其他已接收的数据之后</strong>，所以必须要得继续 read 接收缓冲区已接收的数据；</p></li><li><p>接着，当服务端在 read 数据的时候，最后自然就会读到 EOF，接着 <strong>read() 就会返回 0，这时服务端应用程序如果有数据要发送的话，就发完数据后才调用关闭连接的函数，如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数</strong>，这时服务端就会发一个 FIN 包，这个  FIN 报文代表服务端不会再发送数据了，之后处于 LAST_ACK 状态；</p></li><li><p>客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进入 TIME_WAIT 状态；</p></li><li><p>服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态；</p></li><li><p>客户端经过 2MSL 时间之后，也进入 CLOSE 状态；</p></li></ul><p>你可以看到，每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。</p><h4 id="为什么-TCP-挥手需要四次呢？"><a href="#为什么-TCP-挥手需要四次呢？" class="headerlink" title="为什么 TCP 挥手需要四次呢？"></a>为什么 TCP 挥手需要四次呢？</h4><p>服务器收到客户端的 FIN 报文时，内核会马上回一个 ACK 应答报文，<strong>但是服务端应用程序可能还有数据要发送，所以并不能马上发送 FIN 报文，而是将发送 FIN 报文的控制权交给服务端应用程序</strong>：</p><ul><li><p>如果服务端应用程序有数据要发送的话，就发完数据后，才调用关闭连接的函数；</p></li><li><p>如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数，</p></li></ul><p>从上面过程可知，<strong>是否要发送第三次挥手的控制权不在内核，而是在被动关闭方（上图的服务端）的应用程序，因为应用程序可能还有数据要发送，由应用程序决定什么时候调用关闭连接的函数，当调用了关闭连接的函数，内核就会发送 FIN 报文了，</strong>所以服务端的 ACK 和 FIN 一般都会分开发送。</p><blockquote><p>FIN 报文一定得调用关闭连接的函数，才会发送吗？</p></blockquote><p>不一定。</p><p>如果进程退出了，不管是不是正常退出，还是异常退出（如进程崩溃），内核都会发送 FIN 报文，与对方完成四次挥手。</p><h4 id="粗暴关闭-vs-优雅关闭"><a href="#粗暴关闭-vs-优雅关闭" class="headerlink" title="粗暴关闭 vs 优雅关闭"></a>粗暴关闭 vs 优雅关闭</h4><p>前面介绍 TCP 四次挥手的时候，并没有详细介绍关闭连接的函数，其实关闭的连接的函数有两种函数：</p><ul><li><p>close 函数，同时 socket 关闭发送方向和读取方向，也就是 socket 不再有发送和接收数据的能力。如果有多进程&#x2F;多线程共享同一个 socket，如果有一个进程调用了 close 关闭只是让 socket 引用计数 -1，并不会导致 socket 不可用，同时也不会发出 FIN 报文，其他进程还是可以正常读写该 socket，直到引用计数变为 0，才会发出 FIN 报文。</p></li><li><p>shutdown 函数，可以指定 socket 只关闭发送方向而不关闭读取方向，也就是 socket 不再有发送数据的能力，但是还是具有接收数据的能力。如果有多进程&#x2F;多线程共享同一个 socket，shutdown 则不管引用计数，直接使得该 socket 不可用，然后发出 FIN 报文，如果有别的进程企图使用该 socket，将会受到影响。</p></li></ul><p>如果客户端是用 close 函数来关闭连接，那么在 TCP 四次挥手过程中，如果收到了服务端发送的数据，由于客户端已经不再具有发送和接收数据的能力，所以客户端的内核会回 RST 报文给服务端，然后内核会释放连接，这时就不会经历完成的 TCP 四次挥手，所以我们常说，调用 close 是粗暴的关闭。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqTKiaCezviad9jEJ6laX7YTvmNr0CNBAeFq1ibFtDo8daKnLoiaZf86QXdg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>当服务端收到 RST 后，内核就会释放连接，当服务端应用程序再次发起读操作或者写操作时，就能感知到连接已经被释放了：</p><ul><li><p>如果是读操作，则会返回 RST 的报错，也就是我们常见的Connection reset by peer。</p></li><li><p>如果是写操作，那么程序会产生 SIGPIPE 信号，应用层代码可以捕获并处理信号，如果不处理，则默认情况下进程会终止，异常退出。</p></li></ul><p>相对的，shutdown 函数因为可以指定只关闭发送方向而不关闭读取方向，所以即使在 TCP 四次挥手过程中，如果收到了服务端发送的数据，客户端也是可以正常读取到该数据的，然后就会经历完整的 TCP 四次挥手，所以我们常说，调用 shutdown 是优雅的关闭。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqjibEsjHAFttJCMw712anZwKVHb6YNvqNjib3Vy9pHQOmeibVYjDNfEnAw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>但是注意，shutdown 函数也可以指定「只关闭读取方向，而不关闭发送方向」，但是这时候内核是不会发送 FIN 报文的，因为发送 FIN 报文是意味着我方将不再发送任何数据，而 <strong>shutdown 如果指定「不关闭发送方向」，就意味着 socket 还有发送数据的能力，所以内核就不会发送 FIN</strong>。</p><h4 id="什么情况会出现三次挥手？"><a href="#什么情况会出现三次挥手？" class="headerlink" title="什么情况会出现三次挥手？"></a>什么情况会出现三次挥手？</h4><p>当被动关闭方（上图的服务端）在 TCP 挥手过程中，「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtq0WaxOzTFbA8SQ5Am8ibRL1JMdq5GibqVeXYWOXB3gtdHAMwic01mMAOSw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>然后因为 TCP 延迟确认机制是默认开启的，所以导致我们抓包时，看见三次挥手的次数比四次挥手还多。</p><blockquote><p>什么是  TCP 延迟确认机制？</p></blockquote><p>当发送没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文。</p><p>为了解决 ACK 传输效率低问题，所以就衍生出了 <strong>TCP 延迟确认</strong>。</p><p>TCP 延迟确认的策略：</p><ul><li><p>当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方</p></li><li><p>当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</p></li><li><p>如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK</p></li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqoexLQeRzR1uwXIKrH3jJ9b0NNcrbxEKo7uvPp3eZLiafZkVfiaiaibVulg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>延迟等待的时间是在 Linux 内核中定义的，如下图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqvkkq2d3h7qiaibwa8q3NghgrSVU48FFROd8ydmATAMAaMQpHiapicKTytw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>关键就需要 HZ 这个数值大小，HZ 是跟系统的时钟频率有关，每个操作系统都不一样，在我的 Linux 系统中 HZ 大小是 1000，如下图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqJzGZ8BicbA81zRB4HzbGnFrxdC9tfsZSK1uj82ZPS52d74JTRMqG4Jg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>知道了 HZ 的大小，那么就可以算出：</p><ul><li><p>最大延迟确认时间是 200 ms （1000&#x2F;5）</p></li><li><p>最短延迟确认时间是 40 ms （1000&#x2F;25）</p></li></ul><blockquote><p>怎么关闭 TCP 延迟确认机制？</p></blockquote><p>如果要关闭 TCP 延迟确认机制，可以在 Socket 设置里启用 TCP_QUICKACK，启用 TCP_QUICKACK，就相当于关闭 TCP 延迟确认机制。</p><p>&#x2F;&#x2F; 1 表示开启 TCP_QUICKACK，即关闭 TCP 延迟确认机制<br>int value &#x3D; 1;<br>setsockopt(socketfd, IPPROTO_TCP, TCP_QUICKACK, (char*)&amp; value, sizeof(int));  </p><h4 id="实验验证"><a href="#实验验证" class="headerlink" title="实验验证"></a>实验验证</h4><h5 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h5><p>接下来，来给大家做个实验，验证这个结论：</p><blockquote><p>当被动关闭方（上图的服务端）在 TCP 挥手过程中，「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p></blockquote><p>服务端的代码如下，做的事情很简单，就读取数据，然后当 read 返回 0 的时候，就马上调用 close 关闭连接。因为 TCP 延迟确认机制是默认开启的，所以不需要特殊设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;netdb.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;netinet/in.h&gt;  </span><br><span class="line">#include &lt;sys/socket.h&gt;  </span><br><span class="line">#include &lt;netinet/tcp.h&gt;  </span><br><span class="line">  </span><br><span class="line">#define MAXLINE 1024  </span><br><span class="line">  </span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line">    // 1. 创建一个监听 socket  </span><br><span class="line">    int listenfd = socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">    if(listenfd &lt; 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">        fprintf(stderr, &quot;socket error : %s\n&quot;, strerror(errno));  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 2. 初始化服务器地址和端口  </span><br><span class="line">    struct sockaddr_in server_addr;  </span><br><span class="line">    bzero(&amp;server_addr, sizeof(struct sockaddr_in));  </span><br><span class="line">    server_addr.sin_family = AF_INET;  </span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">    server_addr.sin_port = htons(8888);  </span><br><span class="line">  </span><br><span class="line">    // 3. 绑定地址+端口  </span><br><span class="line">    if(bind(listenfd, (struct sockaddr *)(&amp;server_addr), sizeof(struct sockaddr)) &lt; 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">        fprintf(stderr,&quot;bind error:%s\n&quot;, strerror(errno));  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;begin listen....\n&quot;);  </span><br><span class="line">  </span><br><span class="line">    // 4. 开始监听  </span><br><span class="line">    if(listen(listenfd, 128))  </span><br><span class="line">    &#123;  </span><br><span class="line">        fprintf(stderr, &quot;listen error:%s\n\a&quot;, strerror(errno));  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    // 5. 获取已连接的socket  </span><br><span class="line">    struct sockaddr_in client_addr;  </span><br><span class="line">    socklen_t client_addrlen = sizeof(client_addr);  </span><br><span class="line">    int clientfd = accept(listenfd, (struct sockaddr *)&amp;client_addr, &amp;client_addrlen);  </span><br><span class="line">    if(clientfd &lt; 0) &#123;  </span><br><span class="line">        fprintf(stderr, &quot;accept error:%s\n\a&quot;, strerror(errno));  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;accept success\n&quot;);  </span><br><span class="line">  </span><br><span class="line">    char message[MAXLINE] = &#123;0&#125;;  </span><br><span class="line">      </span><br><span class="line">    while(1) &#123;  </span><br><span class="line">        //6. 读取客户端发送的数据  </span><br><span class="line">        int n = read(clientfd, message, MAXLINE);  </span><br><span class="line">        if(n &lt; 0) &#123; // 读取错误  </span><br><span class="line">            fprintf(stderr, &quot;read error:%s\n\a&quot;, strerror(errno));  </span><br><span class="line">            break;  </span><br><span class="line">        &#125; else if(n == 0) &#123;  // 返回 0 ，代表读到 FIN 报文  </span><br><span class="line">            fprintf(stderr, &quot;client closed \n&quot;);  </span><br><span class="line">            close(clientfd); // 没有数据要发送，立马关闭连接  </span><br><span class="line">            break;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        message[n] = 0;   </span><br><span class="line">        printf(&quot;received %d bytes: %s\n&quot;, n, message);  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    close(listenfd);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>客户端代码如下，做的事情也很简单，与服务端连接成功后，就发送数据给服务端，然后睡眠一秒后，就调用 close 关闭连接，所以客户端是主动关闭方：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;errno.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;netdb.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;netinet/in.h&gt;  </span><br><span class="line">#include &lt;sys/socket.h&gt;  </span><br><span class="line">  </span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line">    // 1. 创建一个监听 socket  </span><br><span class="line">    int connectfd = socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">    if(connectfd &lt; 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">        fprintf(stderr, &quot;socket error : %s\n&quot;, strerror(errno));  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 2. 初始化服务器地址和端口  </span><br><span class="line">    struct sockaddr_in server_addr;  </span><br><span class="line">    bzero(&amp;server_addr, sizeof(struct sockaddr_in));  </span><br><span class="line">    server_addr.sin_family = AF_INET;  </span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);  </span><br><span class="line">    server_addr.sin_port = htons(8888);  </span><br><span class="line">      </span><br><span class="line">    // 3. 连接服务器  </span><br><span class="line">    if(connect(connectfd, (struct sockaddr *)(&amp;server_addr), sizeof(server_addr)) &lt; 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">        fprintf(stderr,&quot;connect error:%s\n&quot;, strerror(errno));  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;connect success\n&quot;);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    char sendline[64] = &quot;hello, i am xiaolin&quot;;  </span><br><span class="line">  </span><br><span class="line">    //4. 发送数据  </span><br><span class="line">    int ret = send(connectfd, sendline, strlen(sendline), 0);  </span><br><span class="line">    if(ret != strlen(sendline)) &#123;  </span><br><span class="line">        fprintf(stderr,&quot;send data error:%s\n&quot;, strerror(errno));  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;already send %d bytes\n&quot;, ret);  </span><br><span class="line">  </span><br><span class="line">    sleep(1);  </span><br><span class="line">  </span><br><span class="line">    //5. 关闭连接  </span><br><span class="line">    close(connectfd);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译服务端和客户端的代码：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqXBTTjgQPl0KLGKMq7hAz9mod0RRYpjI9AXksu0CB1qmJDJN2aSMwPg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>先启用服务端：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqia1WLRBYhBiaU7XbDCHsGKWpIibs5WdibLJy6w0G9Oec7dqkw6cMpLKnoQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>然后用 tcpdump 工具开始抓包，命令如下：</p><p>tcpdump -i lo tcp and port 8888 -s0 -w &#x2F;home&#x2F;tcp_close.pcap  </p><p>然后启用客户端，可以看到，与服务端连接成功后，发完数据就退出了。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqmnM7Byiagyo5RWxWm3LR58Zb4QdxDUQIJVa7S9GGfanHvlfTUzOBwKg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>此时，服务端的输出：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqSeF6vb50YiatBrEowxgAjYmgfy8liaL0TognAsrse1Dwm0u3GT7CENMw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>接下来，我们来看看抓包的结果。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtq48mB8VKryOjzdqyjjwy32kiakVBpvJPb1EdznqXfU2BicibY5mibccpbrA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>可以看到，TCP 挥手次数是 3 次。</p><p>所以，下面这个结论是没问题的。</p><blockquote><p>结论：当被动关闭方（上图的服务端）在 TCP 挥手过程中，「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制（默认会开启）」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p></blockquote><h5 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h5><p>我们再做一次实验，来看看<strong>关闭 TCP 延迟确认机制，会出现四次挥手吗？</strong></p><p>客户端代码保持不变，服务端代码需要增加一点东西。</p><p>在上面服务端代码中，增加了打开了 TCP_QUICKACK （快速应答）机制的代码，如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqS3Fia1ibn7iaKlicjzuPNeXibEPwKlzv9uJSsZ63RkzEOiadlLtMtic4loFXg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>编译好服务端代码后，就开始运行服务端和客户端的代码，同时用 tcpdump 进行抓包。</p><p>抓包的结果如下，可以看到是四次挥手。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeCfmfFfz8T6ngiafWRdcLtqOQ7DhUPhZMcpfqkTHHh1XMUmic3od3mHibTwKTFgHhthltE0BxNdicAug/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>所以，当被动关闭方（上图的服务端）在 TCP 挥手过程中，「<strong>没有数据要发送」，同时「关闭了 TCP 延迟确认机制」，那么就会是四次挥手。</strong></p><blockquote><p>设置 TCP_QUICKACK 的代码，为什么要放在 read 返回 0 之后？</p></blockquote><p>我也是多次实验才发现，在 bind 之前设置 TCP_QUICKACK 是不生效的，只有在 read 返回 0 的时候，设置 TCP_QUICKACK 才会出现四次挥手。</p><p>网上查了下资料说，设置 TCP_QUICKACK 并不是永久的，所以每次读取数据的时候，如果想要立刻回 ACK，那就得在每次读取数据之后，重新设置 TCP_QUICKACK。</p><p>而我这里的实验，目的是为了当收到客户端的 FIN 报文（第一次挥手）后，立马回 ACK 报文，所以就在 read 返回 0 的时候，设置 TCP_QUICKACK。</p><p>当然，实际应用中，没人会在我这个位置设置 TCP_QUICKACK，因为操作系统都通过 TCP 延迟确认机制帮我们把四次挥手优化成了三次挥手了，这本来就是一件好事呀。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>当被动关闭方在 TCP 挥手过程中，如果「没有数据要发送」，同时「没有开启 TCP_QUICKACK（默认情况就是没有开启，没有开启 TCP_QUICKACK，等于就是在使用 TCP 延迟确认机制）」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</p><p><strong>所以，出现三次挥手现象，是因为 TCP 延迟确认机制导致的。</strong></p><h3 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h3><h3 id="TCP如何保证可靠性"><a href="#TCP如何保证可靠性" class="headerlink" title="TCP如何保证可靠性"></a>TCP如何保证可靠性</h3><h3 id="TCP-拆包沾包原因"><a href="#TCP-拆包沾包原因" class="headerlink" title="TCP 拆包沾包原因"></a>TCP 拆包沾包原因</h3><p>TCP 拆包和沾包现象是由于 TCP 协议的特性以及网络传输过程中的各种因素所导致的。<br>TCP 协议是基于字节流的传输层协议，没有固定的分包边界。发送方将数据分成多个小的数据包进行传输，接收方再将这些数据包组合成完整的数据。在这个过程中，可能会出现拆包和沾包现象。<br>网络传输中的延迟和拥塞会影响数据包发送的速度和到达接收方的顺序。这可能导致数据包的拆分和组合不规律，从而出现拆包和沾包现象。<br>接收方的缓冲区大小限制。当接收方的缓冲区不足以容纳一个完整的数据包时，可能会将数据包拆分成多个部分，导致拆包现象。<br>为了解决 TCP 拆包和沾包的问题，可以采用以下方法：<br>在应用层实现数据包的边界识别，例如通过添加包头，包头中包含数据包长度等信息，使得接收方能够准确地将数据包进行拼接。<br>使用固定长度的数据包或者特殊的分隔符，以便于接收方识别数据包的边界。<br>使用更高级的传输层协议，如 WebSocket，它在 TCP 基础上增加了数据帧的概念，可以更好地解决拆包和沾包问题。</p><h3 id="TCP粘包问题怎么解决"><a href="#TCP粘包问题怎么解决" class="headerlink" title="TCP粘包问题怎么解决"></a>TCP粘包问题怎么解决</h3><ul><li><p>答：特殊标记</p></li><li><p>追问：打断，如果使用特殊标记解决会遇到什么问题</p></li><li><p>答：正文转义字符</p></li></ul><p><strong>补充：</strong></p><p>1、固定长度的消息</p><p>这种是最简单方法，即每个用户消息都是固定长度的，比如规定一个消息的长度是 64 个字节，当接收方接满 64 个字节，就认为这个内容是一个完整且有效的消息。</p><p>但是这种方式灵活性不高，实际中很少用。</p><p>2、特殊字符作为边界</p><p>我们可以在两个用户消息之间插入一个特殊的字符串，这样接收方在接收数据时，读到了这个特殊字符，就把认为已经读完一个完整的消息。</p><p>HTTP 是一个非常好的例子。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeAuWVqVBTyJ8LzTIjpaUQ9QzbZBW2SaM2whfW9cXicKVPEw0Md73ibUf4BF1nOSqRW3dvpUA0e2oOQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>图片</p><p>HTTP 通过设置回车符、换行符作为 HTTP 报文协议的边界。</p><p>有一点要注意，这个作为边界点的特殊字符，如果刚好消息内容里有这个特殊字符，我们要对这个字符转义，避免被接收方当作消息的边界点而解析到无效的数据。</p><p>3、自定义消息结构</p><p>我们可以自定义一个消息结构，由包头和数据组成，其中包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大。</p><p>比如这个消息结构体，首先 4 个字节大小的变量来表示数据长度，真正的数据则在后面。</p><p><code>struct &#123;        u_int32_t message_length;        char message_data[];    &#125; message;   </code></p><p>当接收方接收到包头的大小（比如 4 个字节）后，就解析包头的内容，于是就可以知道数据的长度，然后接下来就继续读取数据，直到读满数据的长度，就可以组装成一个完整到用户消息来处理了。</p><h3 id="输入网址后发生了什么？"><a href="#输入网址后发生了什么？" class="headerlink" title="输入网址后发生了什么？"></a>输入网址后发生了什么？</h3><p>应用层 DNS 解析，传输层 TCP 连接，网络层 IP，数据链路 MAC，真实物理层，接收到之后再一层层扒皮。</p><h3 id="http报文长度判断"><a href="#http报文长度判断" class="headerlink" title="http报文长度判断"></a>http报文长度判断</h3><h3 id="udp为啥不可靠性。"><a href="#udp为啥不可靠性。" class="headerlink" title="udp为啥不可靠性。"></a>udp为啥不可靠性。</h3><h3 id="服务端挂了，客户端的-TCP-连接会发生什么？"><a href="#服务端挂了，客户端的-TCP-连接会发生什么？" class="headerlink" title="服务端挂了，客户端的 TCP 连接会发生什么？"></a>服务端挂了，客户端的 TCP 连接会发生什么？</h3><p>如果「服务端挂掉」指的是「<strong>服务端进程崩溃</strong>」，那么这个读者猜的想法是对的，服务端的进程在发生崩溃的时候，内核会发送 FIN 报文，与客户端进行四次挥手。</p><p>但是，如果「服务端挂掉」指的是「<strong>服务端主机宕机</strong>」，那么是不会发生四次挥手的，具体后续会发生什么？还要看客户端会不会发送数据？</p><ul><li><p>如果客户端会发送数据，由于服务端已经不存在，客户端的数据报文会超时重传，当重传次数达到一定阈值后，会断开 TCP 连接；</p></li><li><p>如果客户端一直不会发送数据，再看客户端有没有开启 TCP keepalive 机制？</p></li><li><p>如果有开启，客户端在一段时间后，检测到服务端的 TCP 连接已经不存在，则会断开自身的 TCP 连接；</p></li><li><p>如果没有开启，客户端的 TCP 连接会一直存在，并不会断开。</p></li></ul><h3 id="详细介绍一下TCP的四次挥手机制，为什么要有TIME-WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE-WAIT状态如何解决"><a href="#详细介绍一下TCP的四次挥手机制，为什么要有TIME-WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE-WAIT状态如何解决" class="headerlink" title="详细介绍一下TCP的四次挥手机制，为什么要有TIME_WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE_WAIT状态如何解决"></a>详细介绍一下TCP的四次挥手机制，为什么要有TIME_WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE_WAIT状态如何解决</h3><p>当客户端要服务器断开连接时，客户端 TCP 会向服务器发送一个特殊的报文段，该报文段的 FIN 标志位会被置1，接着服务器会向客户端发送一个确认报文段。然后服务器也会客户端发送一个 FIN 标志位为1的终止报文段，随后客户端回送一个确认报文段，服务器立即断开连接。客户端等待一段时间后也断开连接。</p><p>其实四次挥手的过程是很容易理解的，由于 TCP 协议是全双工的，也就是说客户端和服务端都可以发起断开连接。两边各发起一次断开连接的申请，加上各自的两次确认，看起来就像执行了四次挥手。</p><p>为什么要有 TIME_WAIT 状态？因为客户端最后向服务器发送的确认 ACK 是有可能丢失的，当出现超时，服务端会再次发送 FIN 报文段，如果客户端已经关闭了就收不到了。还有一点是避免新旧连接混杂。</p><p>大量 CLOSE_WAIT 表示程序出现了问题，对方的 socket 已经关闭连接，而我方忙于读或写没有及时关闭连接，需要检查代码，特别是释放资源的代码，或者是处理请求的线程配置</p><p>\3. TIME_WAIT状态<br>    经过前面的铺垫，终于要讲到与本文主题相关的内容了。 ^_^<br>    从TCP状态迁移图可知，只有首先调用close()发起主动关闭的一方才会进入TIME_WAIT状态，而且是必须进入（图中左下角所示的3条状态迁移线最终均要进入该状态才能回到初始的CLOSED状态）。<br>    从图中还可看到，进入TIME_WAIT状态的TCP连接需要经过2MSL才能回到初始状态，其中，MSL是指Max<br>Segment Lifetime，即数据包在网络中的最大生存时间。每种TCP协议的实现方法均要指定一个合适的MSL值，如RFC1122给出的建议值为2分钟，又如Berkeley体系的TCP实现通常选择30秒作为MSL值。这意味着TIME_WAIT的典型持续时间为1-4分钟。<br>    TIME_WAIT状态存在的原因主要有两点：<br>    1）为实现TCP这种全双工（full-duplex）连接的可靠释放<br>    参考本文前面给出的TCP释放连接4次挥手示意图，假设发起active close的一方（图中为client）发送的ACK（4次交互的最后一个包）在网络中丢失，那么由于TCP的重传机制，执行passiveclose的一方（图中为server）需要重发其FIN，在该FIN到达client（client是active close发起方）之前，client必须维护这条连接的状态（尽管它已调用过close），具体而言，就是这条TCP连接对应的（local_ip, local_port）资源不能被立即释放或重新分配。直到romete peer重发的FIN达到，client也重发ACK后，该TCP连接才能恢复初始的CLOSED状态。如果activeclose方不进入TIME_WAIT以维护其连接状态，则当passive close方重发的FIN达到时，active close方的TCP传输层会以RST包响应对方，这会被对方认为有错误发生（而事实上，这是正常的关闭连接过程，并非异常）。<br>    2）为使旧的数据包在网络因过期而消失<br>    为说明这个问题，我们先假设TCP协议中不存在TIME_WAIT状态的限制，再假设当前有一条TCP连接：(local_ip, local_port, remote_ip,remote_port)，因某些原因，我们先关闭，接着很快以相同的四元组建立一条新连接。本文前面介绍过，TCP连接由四元组唯一标识，因此，在我们假设的情况中，TCP协议栈是无法区分前后两条TCP连接的不同的，在它看来，这根本就是同一条连接，中间先释放再建立的过程对其来说是“感知”不到的。这样就可能发生这样的情况：前一条TCP连接由local peer发送的数据到达remote peer后，会被该remot peer的TCP传输层当做当前TCP连接的正常数据接收并向上传递至应用层（而事实上，在我们假设的场景下，这些旧数据到达remote peer前，旧连接已断开且一条由相同四元组构成的新TCP连接已建立，因此，这些旧数据是不应该被向上传递至应用层的），从而引起数据错乱进而导致各种无法预知的诡异现象。作为一种可靠的传输协议，TCP必须在协议层面考虑并避免这种情况的发生，这正是TIME_WAIT状态存在的第2个原因。<br>    具体而言，local peer主动调用close后，此时的TCP连接进入TIME_WAIT状态，处于该状态下的TCP连接不能立即以同样的四元组建立新连接，即发起active close的那方占用的local port在TIME_WAIT期间不能再被重新分配。由于TIME_WAIT状态持续时间为2MSL，这样保证了旧TCP连接双工链路中的旧数据包均因过期（超过MSL）而消失，此后，就可以用相同的四元组建立一条新连接而不会发生前后两次连接数据错乱的情况。</p><p>另一比较深入的说法</p><p>TIME_WAIT状态的存在有两个理由：（1）让4次握手关闭流程更加可靠；4次握手的最后一个ACK是是由主动关闭方发送出去的，若这个ACK丢失，被动关闭方会再次发一个FIN过来。若主动关闭方能够保持一个2MSL的TIME_WAIT状态，则有更大的机会让丢失的ACK被再次发送出去。（2）防止lost duplicate对后续新建正常链接的传输造成破坏。lost duplicate在实际的网络中非常常见，经常是由于路由器产生故障，路径无法收敛，导致一个packet在路由器A，B，C之间做类似死循环的跳转。IP头部有个TTL，限制了一个包在网络中的最大跳数，因此这个包有两种命运，要么最后TTL变为0，在网络中消失；要么TTL在变为0之前路由器路径收敛，它凭借剩余的TTL跳数终于到达目的地。但非常可惜的是TCP通过超时重传机制在早些时候发送了一个跟它一模一样的包，并先于它达到了目的地，因此它的命运也就注定被TCP协议栈抛弃。另外一个概念叫做incarnation connection，指跟上次的socket pair一摸一样的新连接，叫做incarnation of previous connection。lost duplicate加上incarnation connection，则会对我们的传输造成致命的错误。大家都知道TCP是流式的，所有包到达的顺序是不一致的，依靠序列号由TCP协议栈做顺序的拼接；假设一个incarnation connection这时收到的seq&#x3D;1000, 来了一个lost duplicate为seq&#x3D;1000, len&#x3D;1000, 则tcp认为这个lost duplicate合法，并存放入了receive buffer，导致传输出现错误。通过一个2MSL TIME_WAIT状态，确保所有的lost duplicate都会消失掉，避免对新连接造成错误。</p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>从上面的图可以看到滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。</p><p>可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。</p><p>接着就讲讲什么是流量控制窗口，什么是拥塞控制窗口。</p><p>先讲流量控制：</p><p>TCP 是全双工的，客户端和服务器均可作为发送方或接收方，我们现在假设一个发送方向接收方发送数据的场景来讲解流量控制。首先我们的接收方有一块接收缓存，当数据来到时会先把数据放到缓存中，上层应用等缓存中有数据时就会到缓存中取数据。假如发送方没有限制地不断地向接收方发送数据，接收方的应用程序又没有及时把接收缓存中的数据读走，就会出现缓存溢出，数据丢失的现象，为了解决这个问题，我们引入流量控制窗口。</p><p>假设应用程序最后读走的数据序号是 lastByteRead，接收缓存中接收到的最后一个数据序号是 lastByteRcv，接收缓存的大小为 RcvSize，那么必须要满足 lastByteRcv - lastByteRead &lt;&#x3D; RcvSize 才能保证接收缓存不会溢出，所以我们定义流量窗口为接收缓存剩余的空间，也就是Rcv &#x3D; RcvSize - (lastByteRcv - lastByteRead)。只要接收方在响应 ACK 的时候把这个窗口的值带给发送方，发送方就能知道接收方的接收缓存还有多大的空间，进而设置滑动窗口的大小。</p><p>接着讲解拥塞控制：</p><p>拥塞控制是指发送方先设置一个小的窗口值作为发送速率，当成功发包并接收到ACK时，便以指数速率增大发送窗口的大小，直到遇到丢包（超时&#x2F;三个冗余ACK），才停止并调整窗口的大小。这么做能最大限度地利用带宽，又不至于让网络环境变得太过拥挤。</p><p>最终滑动窗口的值将设置为流量控制窗口和拥塞控制窗口中的较小值。</p><p>Q: 编写 TCP&#x2F;SOCK_STREAM 服务程序时，SO_REUSEADDR到底什么意思？</p><p>A: 这个套接字选项通知内核，如果端口忙，但TCP状态位于 TIME_WAIT ，可以重用端口。如果端口忙，而TCP状态位于其他状态，重用端口时依旧得到一个错误信息， 指明”地址已经使用中”。如果你的服务程序停止后想立即重启，而新套接字依旧 使用同一端口，此时 SO_REUSEADDR 选项非常有用。必须意识到，此时任何非期 望数据到达，都可能导致服务程序反应混乱，不过这只是一种可能，事实上很不可能。</p><p>　CLOSE_WAIT： 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。</p><h3 id="UDP客户端可以CONNECT不，那CONNECT和不CONNECT有啥区别"><a href="#UDP客户端可以CONNECT不，那CONNECT和不CONNECT有啥区别" class="headerlink" title="UDP客户端可以CONNECT不，那CONNECT和不CONNECT有啥区别"></a>UDP客户端可以CONNECT不，那CONNECT和不CONNECT有啥区别</h3><p>在UDP协议中，没有真正的连接（connection）的概念，因此UDP客户端不能像TCP客户端那样通过<code>connect()</code>函数来建立连接。</p><p>使用<code>connect()</code>函数的主要目的是为了简化代码和提高安全性。当TCP客户端调用<code>connect()</code>函数时，操作系统会自动为其分配一个socket文件描述符，并将该socket与远程服务器的IP地址和端口号绑定起来。这样，在之后的数据通信中，客户端只需要向该socket发送数据即可，而不必每次都指定远程服务器的IP地址和端口号。另外，<code>connect()</code>函数还可以对发送的数据进行一些验证和过滤，以提高数据传输的安全性。</p><p>在UDP协议中，由于不存在真正的连接，因此也就不需要使用<code>connect()</code>函数来建立连接。UDP客户端每次发送数据时，都需要指定远程服务器的IP地址和端口号，这样才能确保数据能够正确地被发送到目标地址。因此，在UDP协议中，没有<code>connect()</code>函数的概念。</p><p>总之，UDP客户端没有连接（connection）的概念，因此不能像TCP客户端那样使用<code>connect()</code>函数来建立连接。每次发送数据时，UDP客户端需要显式地指定远程服务器的IP地址和端口号。如果需要简化代码和提高安全性，可以使用其他技术手段，例如使用加密算法和数字证书来保证数据传输的安全性。</p><h3 id="5-讲一下HTTP与HTTPS的区别"><a href="#5-讲一下HTTP与HTTPS的区别" class="headerlink" title="5. 讲一下HTTP与HTTPS的区别"></a>5. 讲一下HTTP与HTTPS的区别</h3><p>HTTP和HTTPS的主要区别在于HTTP协议传递的是明文数据，而HTTPS传递的是加密过的数据，也就是说HTTPS更具有安全性。也正由HTTPS需要保证安全性，所以它的性能要比HTTP差一点。</p><p>单说安全性肯定是不够的，我打算扩展讲一下HTTPS是怎么解决安全性问题的，通过这些HTTP没有机制，反映出HTTPS与HTTP的区别。下面尝试把HTTPS加密的过程推导出来。推导过程不涉及复杂的实现细节：</p><h4 id="如何安全地进行数据传输？"><a href="#如何安全地进行数据传输？" class="headerlink" title="如何安全地进行数据传输？"></a>如何安全地进行数据传输？</h4><p>假设现在A和B要进行安全的通信，那么究竟怎样才算是安全的通信？很自然地会想到：A和B之间传递数据，这些数据只有A和B才看得懂，中间人就算截取了信息但也看不懂，这才算得上安全。</p><h4 id="安全通信的处理手段："><a href="#安全通信的处理手段：" class="headerlink" title="安全通信的处理手段："></a>安全通信的处理手段：</h4><p>为了能让A和B才能看懂，就必须要对数据进行加密，而且首先想到的就是对称加密。对称加密的意思是A和B各持有一个相同的密钥，它们传递信息时会用密钥给信息加密，在消息到达端给消息解密，完成安全通信。</p><p>在对称加密中又会涉及到加密算法的选择问题。现实世界中，通常是多个客户端面向一个服务器的情况，不可能让每个客户端和服务器之间都采用相同的加密算法，如果是这样那和没加密差不多。所以注定每个客户端和服务器之间都会采用不同的加密方式。</p><h4 id="如何让每个客户端与服务器之间都采用不同的加密方式？"><a href="#如何让每个客户端与服务器之间都采用不同的加密方式？" class="headerlink" title="如何让每个客户端与服务器之间都采用不同的加密方式？"></a>如何让每个客户端与服务器之间都采用不同的加密方式？</h4><p>要想对不同的机器使用不同的加密方式，最直接想到的就是使用随机数。也就说客户端和服务器之间每次都基于一个随机数产生加密算法。（具体实现时为了保证随机，用到还不止一个随机数）</p><p>这个产生加密算法的过程称之为协商，现在问题是协商的过程是透明的，也就是说中间人可以截获协商的过程，从而知道我们的加密方式。为了解决这个问题，我们需要对协商的过程进行加密。</p><h4 id="如何对协商的过程进行加密？"><a href="#如何对协商的过程进行加密？" class="headerlink" title="如何对协商的过程进行加密？"></a>如何对协商的过程进行加密？</h4><p>之所以能来到这一步，是因为我们一开始就选择使用了对称加密，也就说一开始的对称加密导致了现在的问题，所以这时我们不能再使用对称加密了，否则会陷入死循环。</p><p>在密码学领域，还有一种加密过程叫非对称加密，它的逻辑是这样的：通信双方一方持有私钥，一方持有公钥，经过私钥加密的信息，都能通过公钥进行解密。但是经过公钥加密的数据，只有私钥可以解密。</p><p>按照非对称加密的规则，我们让服务器持有私钥，让客户端持有公钥。这样就能保证客户端给服务器发送消息的时候是安全的（相反，服务器给客户端发送消息就是不安全的），我们可以把协商时重要的逻辑安排在客户端给服务器发送信息的过程中，从而保证了协商过程的安全性。</p><h4 id="客户端如何获得公钥？"><a href="#客户端如何获得公钥？" class="headerlink" title="客户端如何获得公钥？"></a>客户端如何获得公钥？</h4><p>现在用非对称加密算法解决了协商的安全问题，但是非对称加密的前提是客户端需要获得公钥，这又是一个问题了，客户端与服务器打交道之前是互不知道双方身份的，怎么才能让客户端获得公钥呢？</p><p>也就只有两种办法：</p><ol><li>客户端向服务器要公钥</li><li>客户端向一个远程的公共服务器获取公钥</li></ol><p>方法2显然是不行的，尚且不说多了一个访问节点，如何找到公共服务器的地址也是一个待解决的问题，所以还是使用方法1。</p><p>但是方法1存在一个问题：如果中间人把服务器发送给客户端的公钥调包了怎么办？也就是说客户端无法知道发送公钥的是否是正真的服务器。</p><h4 id="引入第三方机构解决问题"><a href="#引入第三方机构解决问题" class="headerlink" title="引入第三方机构解决问题"></a>引入第三方机构解决问题</h4><p>客户端无法辨识服务端和中间人的问题称为“身份验证”问题，也就是说我们需要为服务器向客户端发送公钥的过程进行加密。</p><p>这下完了，之前我们因遇到对称加密的瓶颈选择了非对称加密，现在使用非对称加密也遇到了瓶颈。显然这两种加密方式都是不可用的了，否则会再次陷入死循环。</p><p>接下来我们只好通过第三方机构的介入，解决这个问题。首先我们自己保存有第三方权威机构的公钥，然后第三方机构使用私钥对服务器将要发送给客户端的公钥进行加密，客户端接收到这个经加密的公钥后（数字证书），就能通过自己保存的第三方机构公钥进行解密。</p><blockquote><p>到这里为止，我们解释了HTTPS中使用到的对称加密，非对称加密，CA，数字证书的概念，但是还差一个叫数字签名的概念没有解释。</p></blockquote><p>在现实生活中，CA不单止会给我们正常公司发放证书，还会给中间人的坏公司发放证书，如果中间人把发放的证书调包了怎么办？这时我们仍能用CA的私钥进行解密，但是证书已经被调包了。</p><p>那么客户端怎样验证证书的真伪呢？答案是证书本身会告诉客户端如何辨认真伪。比方说证书上面有一个证书编号，还有一个如何计算证书编号的方法，客户端可以根据计算证书编号的方法计算出自己要获得的证书的编号，然后把这个编号和证书上的编号进行比对，如果一样证明没有被调包。</p><p>这里的证书编号指的就是数字签名，证书指的就是数字证书。</p><p>总结一下HTTPS：HTTPS想要保证客户端与服务器之间的通信安全，就得使用对称加密算法进行加密。协商对称加密算法的过程通过非对称加密算法来保证。在非对称加密算法中，客户端获得公钥的过程需要第三方机构（CA）通过颁发数字证书保证安全性。</p><p>总得来说通过这一系列机制协商出了一个对称加密算法后，客户端与服务器之间就能通过该算法进行安全的通信了</p><ul><li><p>TCP消息和UDP的主要区别</p></li><li><p>Epoll比起select&#x2F;poll，主要优化点在哪里？</p></li><li><p>Post和Get有什么区别？</p></li><li><p>接收时，如何确定一个HTTP消息已经读取完毕</p></li><li><p>从一个命令行下载一个网页，会涉及哪些网络协议？（DNS，TCP，HTTP，如果有ARP和SSL更好）</p></li><li><p>HTTP&#x2F;2主要优化点</p></li><li><p>\1. C++中具体是怎么实现多态的？构造函数可以是虚函数吗？构造函数可以调用虚函数吗？<br>编译器发现一个类中有虚函数，便会立即为此类生成虚函数表 vtable。虚函数表的各表项为指向对应虚函数的指针。<br>构造函数不可以是虚函数，也不能调用虚函数，因为此时虚函数表还未生成。</p><p>\2. 操作系统中进程、线程的区别，进程间通信通信的方式？<br>进程： 进程是资源（CPU、内存等）分配的基本单位，具有一定功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。<br>线程：线程是进程的一个实体，是独立运行和独立调度的基本单位（CPU上真正运行的是线程）。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。<br>进程通信的方式：管道，有名管道，信号量，消息队列，信号,共享内存,套接字.</p><p>\3. python中的多线程能充分利用多核CPU吗？如果要充分利用的话应该怎么做？<br>python的多线程不能充分利用多CPU，因为python解释器有一个全局锁；<br>要想利用多CPU只能使用多进程模型，或者使用C++</p><p>\4. http属于OSI分层协议中的哪一层？TCP&#x2F;UDP是属于哪一层？TCP的三次握手的过程是怎样的？为什么要有三次握手？<br>http属于应用层，TCP&#x2F;UDP属于传输层；</p><p>假设 A 为客户端，B 为服务器端。</p><p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p><p>A 向 B 发送连接请求报文，SYN&#x3D;1，ACK&#x3D;0，选择一个初始的序号 x。</p><p>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN&#x3D;1，ACK&#x3D;1，确认号为 x+1，同时也选择一个初始的序号 y。</p><p>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</p><p>B 收到 A 的确认后，连接建立。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><p>\5. TCP怎么实现可靠传输的？</p><p>TCP滑动窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。<br>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。<br>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p></li></ul><h3 id="不同地区的用户的请求怎么打到附近的地区呢？"><a href="#不同地区的用户的请求怎么打到附近的地区呢？" class="headerlink" title="不同地区的用户的请求怎么打到附近的地区呢？"></a>不同地区的用户的请求怎么打到附近的地区呢？</h3><p>答：讲了CDN</p><p><strong>补充：</strong></p><p>CDN 将内容资源分发到位于多个地理位置机房中的服务器上，这样我们在访问内容资源的时候，不用访问源服务器。而是直接访问离我们最近的 CDN 节点 ，这样一来就省去了长途跋涉的时间成本，从而实现了网络加速。</p><p>找到离用户最近的 CDN 节点是由 CDN 的<strong>全局负载均衡器（<em>Global Sever Load Balance，GSLB</em>）</strong>负责的。</p><p>那 GSLB 是在什么时候起作用的呢？在回答这个问题前，我们先来看看在没有 CDN 的情况下，访问域名时发生的事情。</p><p>在没有 CDN 的情况下，当我们访问域名时，DNS 服务器最终会返回源服务器的地址。</p><p>比如，当我们在浏览器输入 <a href="http://www.xiaolin.com/">www.xiaolin.com</a> 域名后，在本地 host 文件找不到域名时，客户端就会访问本地 DNS 服务器。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfg8KBLwPAE6ktepRPahjT7TyX6BwTp8IcDsOAkGvvWiaUcg2dQZc3ExHZyHr2ngzib5HfeMqvHN35g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>图片</p><p>这时候:</p><ul><li><p>如果本地 DNS 服务器有缓存该网站的地址，则直接返回网站的地址；</p></li><li><p>如果没有就通过递归查询的方式，先请求根 DNS，根 DNS 返回顶级 DNS（.com）的地址；再请求 .com 顶级 DNS 得到 xiaolin.com 的域名服务器地址，再从 xiaolin.com 的域名服务器中查询到 <a href="http://www.xiaolin.com/">www.xiaolin.com</a> 对应的 IP 地址，然后返回这个 IP 地址，同时本地 DNS 缓存该 IP 地址，这样下一次的解析同一个域名就不需要做 DNS 的迭代查询了。</p></li></ul><p><strong>但加入 CDN 后就不一样了</strong>。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfg8KBLwPAE6ktepRPahjT7Ve7FiaAianuWiaZic1anXPYAST8dccKtcwJ5uzia8ZqicxiciaWfGOlgyDpVWg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>图片</p><p>会在 xiaolin.com 这个 DNS 服务器上，设置一个 CNAME 别名，指向另外一个域名 <a href="http://www.xiaolin.cdn.com,返回给本地/">www.xiaolin.cdn.com，返回给本地</a> DNS 服务器。</p><p>接着继续解析该域名，这个时候访问的就是 xiaolin.cdn.com 这台 CDN 专用的 DNS 服务器，在这个服务器上，又会设置一个 CNAME，指向另外一个域名，这次指向的就是 CDN 的 GSLB。</p><p>接着，本地 DNS 服务器去请求 CDN 的 GSLB 的域名，GSLB 就会为用户选择一台合适的 CDN 节点提供服务，选择的依据主要有以下几点：</p><ul><li><p>看用户的 IP 地址，查表得知地理位置，找相对最近的 CDN 节点；</p></li><li><p>看用户所在的运营商网络，找相同网络的 CDN 节点；</p></li><li><p>看用户请求 URL，判断哪一台服务器上有用户所请求的资源；</p></li><li><p>查询 CDN 节点的负载情况，找负载较轻的节点；</p></li></ul><p>GSLB 会基于以上的条件进行综合分析后，找出一台最合适的 CDN 节点，并返回该 CDN 节点的 IP 地址给本地 DNS 服务器，然后本地 DNS 服务器缓存该 IP 地址，并将 IP 返回给客户端，客户端去访问这个 CDN 节点，下载资源。</p><h3 id="TCP的close-wait在哪端，如果我们场景中出现了大量的close-wait，你觉得要怎么排查"><a href="#TCP的close-wait在哪端，如果我们场景中出现了大量的close-wait，你觉得要怎么排查" class="headerlink" title="TCP的close_wait在哪端，如果我们场景中出现了大量的close_wait，你觉得要怎么排查"></a>TCP的close_wait在哪端，如果我们场景中出现了大量的close_wait，你觉得要怎么排查</h3><p>答：被动方，代码逻辑有问题，没close</p><p><strong>补充：</strong></p><p>CLOSE_WAIT 状态是「被动关闭方」才会有的状态，而且如果「被动关闭方」没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态。</p><p>所以，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接</strong>。</p><p>那什么情况会导致服务端的程序没有调用 close 函数关闭连接？这时候通常需要排查代码。</p><p>我们先来分析一个普通的 TCP 服务端的流程：</p><ol><li><p>创建服务端 socket，bind 绑定端口、listen 监听端口</p></li><li><p>将服务端 socket 注册到 epoll</p></li><li><p>epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket</p></li><li><p>将已连接的 socket 注册到 epoll</p></li><li><p>epoll_wait 等待事件发生</p></li><li><p>对方连接关闭时，我方调用 close</p></li></ol><p>可能导致服务端没有调用 close 函数的原因，如下。</p><p><strong>第一个原因</strong>：第 2 步没有做，没有将服务端 socket 注册到 epoll，这样有新连接到来时，服务端没办法感知这个事件，也就无法获取到已连接的 socket，那服务端自然就没机会对 socket 调用 close 函数了。</p><p>不过这种原因发生的概率比较小，这种属于明显的代码逻辑 bug，在前期 read view 阶段就能发现的了。</p><p><strong>第二个原因</strong>：第 3 步没有做，有新连接到来时没有调用 accpet 获取该连接的 socket，导致当有大量的客户端主动断开了连接，而服务端没机会对这些 socket 调用 close 函数，从而导致服务端出现大量 CLOSE_WAIT 状态的连接。</p><p>发生这种情况可能是因为服务端在执行 accpet 函数之前，代码卡在某一个逻辑或者提前抛出了异常。</p><p><strong>第三个原因</strong>：第 4 步没有做，通过 accpet 获取已连接的 socket 后，没有将其注册到 epoll，导致后续收到 FIN 报文的时候，服务端没办法感知这个事件，那服务端就没机会调用 close 函数了。</p><p>发生这种情况可能是因为服务端在将已连接的 socket 注册到 epoll 之前，代码卡在某一个逻辑或者提前抛出了异常。之前看到过别人解决 close_wait 问题的实践文章，感兴趣的可以看看：<a href="https://mp.weixin.qq.com/s?__biz=MzU3Njk0MTc3Ng==&mid=2247486020&idx=1&sn=f7cf41aec28e2e10a46228a64b1c0a5c&scene=21#wechat_redirect">一次 Netty 代码不健壮导致的大量 CLOSE_WAIT 连接原因分析</a></p><p><strong>第四个原因</strong>：第 6 步没有做，当发现客户端关闭连接后，服务端没有执行 close 函数，可能是因为代码漏处理，或者是在执行 close 函数之前，代码卡在某一个逻辑，比如发生死锁等等。</p><p>可以发现，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，通常都是代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用 close</strong>。</p><h3 id="服务端出现大量-TIME-WAIT-状态的原因有哪些？"><a href="#服务端出现大量-TIME-WAIT-状态的原因有哪些？" class="headerlink" title="服务端出现大量 TIME_WAIT 状态的原因有哪些？"></a>服务端出现大量 TIME_WAIT 状态的原因有哪些？</h3><p>我们先来看一下 TCP 四次挥手的流程吧，看看 TIME_WAIT 状态发生在哪一个阶段。</p><p>下面这个图，是由「客户端」作为「主动关闭方」的 TCP 四次挥手的流程。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdWrrgBYLP5VsrraBM1qVuzgibl5CZs9FKwxdu2j2In9NPx4W5wC2e91AjbyLlwL7jvEY5NNjuRr5Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>TCP 四次挥手的流程</p><p>从上面我们可以知道，<strong>TIME_WAIT 状态是「主动关闭连接方」才会出现的状态</strong>。而且 TIME_WAIT 状态会持续 2MSL 时间才会进入到 close 状态。在 Linux 上 2MSL 的时长是 60 秒，也就是说<strong>停留在 TIME_WAIT 的时间为固定的 60 秒</strong>。</p><p>为什么需要 TIME_WAIT 状态？（老八股文了，帮大家复习一波）主要有两个原因：</p><ul><li><p><strong>保证「被动关闭连接」的一方，能被正确的关闭</strong>。TCP 协议在关闭连接的四次挥手中，在主动关闭方发送的最后一个 ACK 报文，有可能丢失，这时被动方会重新发 FIN 报文, 如果这时主动方处于 CLOSE 状态 ，就会响应 RST 报文而不是 ACK 报文。所以主动方要处于 TIME_WAIT 状态，而不能是 CLOSE。</p></li><li><p><strong>防止历史连接中的数据，被后面相同四元组的连接错误的接收</strong>。TCP 报文可能由于路由器异常而 “迷路”，在迷途期间，TCP 发送端可能因确认超时而重发这个报文，迷途的报文在路由器修复后也会被送到最终目的地，这个原来的迷途报文就称为 lost duplicate。在关闭一个 TCP 连接后，马上又重新建立起一个相同的 IP 地址和端口之间的 TCP 连接，后一个连接被称为前一个连接的化身，那么有可能出现这种情况，前一个连接的迷途重复报文在前一个连接终止后出现，从而被误解成从属于新的化身。为了避免这个情 况， TIME_WAIT 状态需要持续 2MSL，因为这样就可以保证当成功建立一个 TCP 连接的时候，来自连接先前化身的重复报文已经在网络中消逝。</p></li></ul><p>很多人误解以为只有客户端才会有 TIME_WAIT 状态，这是不对的。TCP 是全双工协议，哪一方都可以先关闭连接，所以哪一方都可能会有 TIME_WAIT 状态。</p><p>总之记住，<strong>谁先关闭连接的，它就是主动关闭方，那么 TIME_WAIT 就会出现在主动关闭方</strong>。</p><h4 id="什么场景下服务端会主动断开连接呢？"><a href="#什么场景下服务端会主动断开连接呢？" class="headerlink" title="什么场景下服务端会主动断开连接呢？"></a>什么场景下服务端会主动断开连接呢？</h4><p>如果服务端出现大量的 TIME_WAIT 状态的 TCP 连接，就是<strong>说明服务端主动断开了很多 TCP 连接</strong>。</p><p>问题来了，<strong>什么场景下服务端会主动断开连接呢？</strong></p><ul><li><p>第一个场景：HTTP 没有使用长连接</p></li><li><p>第二个场景：HTTP 长连接超时</p></li><li><p>第三个场景：HTTP 长连接的请求数量达到上限</p></li></ul><p>接下来，分别介绍下。</p><h5 id="第一个场景：HTTP-没有使用长连接"><a href="#第一个场景：HTTP-没有使用长连接" class="headerlink" title="第一个场景：HTTP 没有使用长连接"></a>第一个场景：HTTP 没有使用长连接</h5><p>我们先来看看 HTTP 长连接（Keep-Alive）机制是怎么开启的。</p><p>在 HTTP&#x2F;1.0 中默认是关闭的，如果浏览器要开启 Keep-Alive，它必须在请求的 header 中添加：</p><p><code>Connection: Keep-Alive   </code></p><p>然后当服务器收到请求，作出回应的时候，它也被添加到响应中 header 里：</p><p><code>Connection: Keep-Alive   </code></p><p>这样做，TCP 连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个 TCP 连接。这一直继续到客户端或服务器端提出断开连接。</p><p><strong>从 HTTP&#x2F;1.1 开始， 就默认是开启了 Keep-Alive</strong>，现在大多数浏览器都默认是使用 HTTP&#x2F;1.1，所以 Keep-Alive 都是默认打开的。一旦客户端和服务端达成协议，那么长连接就建立好了。</p><p>如果要关闭 HTTP Keep-Alive，需要在 HTTP 请求或者响应的 header 里添加 <code>Connection:close</code> 信息，也就是说，<strong>只要客户端和服务端任意一方的 HTTP header 中有 <code>Connection:close</code> 信息，那么就无法使用 HTTP 长连接的机制</strong>。</p><p>关闭 HTTP 长连接机制后，每次请求都要经历这样的过程：建立 TCP -&gt; 请求资源 -&gt; 响应资源 -&gt; 释放连接，那么此方式就是 <strong>HTTP 短连接</strong>，如下图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdWrrgBYLP5VsrraBM1qVuz6Mbyn1OB5sHE3A6HarVbjvNt8Wuoz4bIktXZ4uAQicFlHtVnEibfviaAg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>HTTP 短连接</p><p>在前面我们知道，只要任意一方的 HTTP header 中有 <code>Connection:close</code> 信息，就无法使用 HTTP 长连接机制，这样在完成一次 HTTP 请求&#x2F;处理后，就会关闭连接。</p><p>问题来了，<strong>这时候是客户端还是服务端主动关闭连接呢？</strong></p><p>在 RFC 文档中，并没有明确由谁来关闭连接，<strong>请求和响应的双方都可以主动关闭 TCP 连接。</strong></p><p>不过，<strong>根据大多数 Web 服务的实现，不管哪一方禁用了 HTTP Keep-Alive，都是由服务端主动关闭连接</strong>，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p><blockquote><p>客户端禁用了 HTTP Keep-Alive，服务端开启 HTTP Keep-Alive，谁是主动关闭方？</p></blockquote><p>当客户端禁用了 HTTP Keep-Alive，这时候 HTTP 请求的 header 就会有 <code>Connection:close</code> 信息，这时服务端在发完 HTTP 响应后，就会主动关闭连接。</p><p>为什么要这么设计呢？HTTP 是请求-响应模型，发起方一直是客户端，HTTP Keep-Alive 的初衷是<strong>为客户端后续的请求重用连接</strong>，如果我们<strong>在某次 HTTP 请求-响应模型中，请求的 header 定义了 <code>connection：close</code> 信息，那不再重用这个连接的时机就只有在服务端了</strong>，所以我们在 HTTP 请求-响应这个周期的「末端」关闭连接是合理的。</p><blockquote><p>客户端开启了 HTTP Keep-Alive，服务端禁用了 HTTP Keep-Alive，谁是主动关闭方？</p></blockquote><p>当客户端开启了 HTTP Keep-Alive，而服务端禁用了 HTTP Keep-Alive，这时服务端在发完 HTTP 响应后，服务端也会主动关闭连接。</p><p>为什么要这么设计呢？在服务端主动关闭连接的情况下，只要调用一次 close() 就可以释放连接，剩下的工作由内核 TCP 栈直接进行了处理，整个过程只有一次 syscall；如果是要求 客户端关闭，则服务端在写完最后一个 response 之后需要把这个 socket 放入 readable 队列，调用 select &#x2F; epoll 去等待事件；然后调用一次 read() 才能知道连接已经被关闭，这其中是两次 syscall，多一次用户态程序被激活执行，而且 socket 保持时间也会更长。</p><p>因此，<strong>当服务端出现大量的 TIME_WAIT 状态连接的时候，可以排查下是否客户端和服务端都开启了 HTTP Keep-Alive</strong>，因为任意一方没有开启  HTTP Keep-Alive，都会导致服务端在处理完一个 HTTP 请求后，就主动关闭连接，此时服务端上就会出现大量的 TIME_WAIT 状态的连接。</p><p>针对这个场景下，解决的方式也很简单，让客户端和服务端都开启 HTTP Keep-Alive 机制。</p><h5 id="第二个场景：HTTP-长连接超时"><a href="#第二个场景：HTTP-长连接超时" class="headerlink" title="第二个场景：HTTP 长连接超时"></a>第二个场景：HTTP 长连接超时</h5><p>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p><p>HTTP 长连接可以在同一个 TCP 连接上接收和发送多个 HTTP 请求&#x2F;应答，避免了连接建立和释放的开销。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdWrrgBYLP5VsrraBM1qVuzJOMM2YOyn0hibsGmKnTveXVtdAueyHib140mgZgFCN1kX8LRF4VXexpA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>可能有的同学会问，如果使用了 HTTP 长连接，如果客户端完成一个 HTTP 请求后，就不再发起新的请求，此时这个 TCP 连接一直占用着不是挺浪费资源的吗？</p><p>对没错，所以为了避免资源浪费的情况，web 服务软件一般都会提供一个参数，用来指定 HTTP 长连接的超时时间，比如 nginx 提供的 keepalive_timeout 参数。</p><p>假设设置了 HTTP 长连接的超时时间是 60 秒，nginx 就会启动一个「定时器」，<strong>如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，定时器的时间一到，nginx 就会触发回调函数来关闭该连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接</strong>。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdWrrgBYLP5VsrraBM1qVuz5pHQCUACibMOoaNEuB6JqQHEST9cpyZutary8DxnB1joDHybV0ibWBOw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>HTTP 长连接超时</p><p>当服务端出现大量 TIME_WAIT 状态的连接时，如果现象是有大量的客户端建立完 TCP 连接后，很长一段时间没有发送数据，那么大概率就是因为 HTTP 长连接超时，导致服务端主动关闭连接，产生大量处于 TIME_WAIT 状态的连接。</p><p>可以往网络问题的方向排查，比如是否是因为网络问题，导致客户端发送的数据一直没有被服务端接收到，以至于 HTTP 长连接超时。</p><h5 id="第三个场景：HTTP-长连接的请求数量达到上限"><a href="#第三个场景：HTTP-长连接的请求数量达到上限" class="headerlink" title="第三个场景：HTTP 长连接的请求数量达到上限"></a>第三个场景：HTTP 长连接的请求数量达到上限</h5><p>Web 服务端通常会有个参数，来定义一条 HTTP 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接。</p><p>比如 nginx 的 keepalive_requests 这个参数，这个参数是指一个 HTTP 长连接建立之后，nginx 就会为这个连接设置一个计数器，记录这个 HTTP 长连接上已经接收并处理的客户端请求的数量。<strong>如果达到这个参数设置的最大值时，则 nginx 会主动关闭这个长连接</strong>，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p><p>keepalive_requests 参数的默认值是 100 ，意味着每个 HTTP 长连接最多只能跑 100  次请求，这个参数往往被大多数人忽略，因为当 QPS (每秒请求数) 不是很高时，默认值 100 凑合够用。</p><p>但是，<strong>对于一些 QPS 比较高的场景，比如超过 10000 QPS，甚至达到 30000 , 50000 甚至更高，如果 keepalive_requests 参数值是 100，这时候就 nginx 就会很频繁地关闭连接，那么此时服务端上就会出大量的 TIME_WAIT 状态</strong>。</p><p>针对这个场景下，解决的方式也很简单，调大 nginx 的 keepalive_requests 参数就行。</p><h4 id="TIME-WAIT-状态过多有什么危害？"><a href="#TIME-WAIT-状态过多有什么危害？" class="headerlink" title="TIME_WAIT 状态过多有什么危害？"></a>TIME_WAIT 状态过多有什么危害？</h4><p>过多的 TIME-WAIT 状态主要的危害有两种：</p><ul><li><p>第一是占用系统资源，比如文件描述符、内存资源、CPU 资源等；</p></li><li><p>第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为 <code>32768～61000</code>，也可以通过 <code>net.ipv4.ip_local_port_range</code>参数指定范围。</p></li></ul><p>客户端和服务端 TIME_WAIT 过多，造成的影响是不同的。</p><p><strong>如果客户端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT」都一样的服务端发起连接了，但是被使用的端口，还是可以继续对另外一个服务端发起连接的。具体可以看我这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247517946&idx=1&sn=a3d88d7ac73792c5031ccf8422066f7c&scene=21#wechat_redirect">客户端的端口可以重复使用吗？</a></p><p>因此，客户端（发起连接方）都是和「目的 IP+ 目的 PORT 」都一样的服务端建立连接的话，当客户端的 TIME_WAIT 状态连接过多的话，就会受端口资源限制，如果占满了所有端口资源，那么就无法再跟「目的 IP+ 目的 PORT」都一样的服务端建立连接了。</p><p>不过，即使是在这种场景下，只要连接的是不同的服务端，端口是可以重复使用的，所以客户端还是可以向其他服务端发起连接的，这是因为内核在定位一个连接的时候，是通过四元组（源IP、源端口、目的IP、目的端口）信息来定位的，并不会因为客户端的端口一样，而导致连接冲突。</p><p><strong>如果服务端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接，但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源等。</p><h4 id="如何优化-TIME-WAIT-状态？"><a href="#如何优化-TIME-WAIT-状态？" class="headerlink" title="如何优化 TIME_WAIT 状态？"></a>如何优化 TIME_WAIT 状态？</h4><p>这里给出优化 TIME-WAIT 的几个方式，都是有利有弊：</p><ul><li><p>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；</p></li><li><p>net.ipv4.tcp_max_tw_buckets</p></li><li><p>程序中使用 SO_LINGER ，应用强制使用 RST 关闭。</p></li></ul><p><em>方式一：net.ipv4.tcp_tw_reuse 和 tcp_timestamps</em></p><p>开启 tcp_tw_reuse，则可以<strong>复用处于 TIME_WAIT 的 socket 为新的连接所用</strong>。</p><p>有一点需要注意的是，<strong>tcp_tw_reuse 功能只能用客户端（连接发起方），因为开启了该功能，在调用 connect() 函数时，内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复用。</strong></p><p><code>net.ipv4.tcp_tw_reuse = 1   </code></p><p>使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持，即</p><p><code>net.ipv4.tcp_timestamps=1（默认即为 1）   </code></p><p>这个时间戳的字段是在 TCP 头部的「选项」里，它由一共 8 个字节表示时间戳，其中第一个 4 字节字段用来保存发送该数据包的时间，第二个 4 字节字段用来保存最近一次接收对方发送到达数据的时间。</p><p>由于引入了时间戳，可以使得重复的数据包会因为时间戳过期被自然丢弃，因此 TIME_WAIT 状态才可以被复用。</p><p><em>方式二：net.ipv4.tcp_max_tw_buckets</em></p><p>这个值默认为 18000，<strong>当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接状态重置</strong>，这个方法比较暴力。</p><p><code>net.ipv4.tcp_max_tw_buckets = 18000   </code></p><p><em>方式三：程序中使用 SO_LINGER</em></p><p>我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。</p><p><code>struct linger so_linger;   so_linger.l_onoff = 1;   so_linger.l_linger = 0;   setsockopt(s, SOL_SOCKET, SO_LINGER, &amp;so_linger,sizeof(so_linger));   </code></p><p>如果<code>l_onoff</code>为非 0， 且<code>l_linger</code>值为 0，那么调用<code>close</code>后，会立该发送一个<code>RST</code>标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了<code>TIME_WAIT</code>状态，直接关闭。</p><p>但这为跨越<code>TIME_WAIT</code>状态提供了一个可能，不过是一个非常危险的行为，不值得提倡。</p><p>前面介绍的方法都是试图越过 <code>TIME_WAIT</code>状态的，这样其实不太好。虽然 TIME_WAIT 状态持续的时间是有一点长，显得很不友好，但是它被设计来就是用来避免发生乱七八糟的事情。</p><p>《UNIX网络编程》一书中却说道：<strong>TIME_WAIT 是我们的朋友，它是有助于我们的，不要试图避免这个状态，而是应该弄清楚它</strong>。</p><p><strong>如果服务端要避免过多的 TIME_WAIT 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT</strong>。</p><h3 id="服务端出现大量-CLOSE-WAIT-状态的原因有哪些？"><a href="#服务端出现大量-CLOSE-WAIT-状态的原因有哪些？" class="headerlink" title="服务端出现大量 CLOSE_WAIT 状态的原因有哪些？"></a>服务端出现大量 CLOSE_WAIT 状态的原因有哪些？</h3><p>还是拿这张图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdWrrgBYLP5VsrraBM1qVuzgibl5CZs9FKwxdu2j2In9NPx4W5wC2e91AjbyLlwL7jvEY5NNjuRr5Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>TCP 四次挥手的流程</p><p>从上面这张图我们可以得知，CLOSE_WAIT 状态是「被动关闭方」才会有的状态，而且如果「被动关闭方」没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态。</p><p>所以，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接</strong>。</p><p>那什么情况会导致服务端的程序没有调用 close 函数关闭连接？这时候通常需要排查代码。</p><p>我们先来分析一个普通的 TCP 服务端的流程：</p><ol><li><p>创建服务端 socket，bind 绑定端口、listen 监听端口</p></li><li><p>将服务端 socket 注册到 epoll</p></li><li><p>epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket</p></li><li><p>将已连接的 socket 注册到 epoll</p></li><li><p>epoll_wait 等待事件发生</p></li><li><p>对方连接关闭时，我方调用 close</p></li></ol><p>可能导致服务端没有调用 close 函数的原因，如下。</p><p><strong>第一个原因</strong>：第 2 步没有做，没有将服务端 socket 注册到 epoll，这样有新连接到来时，服务端没办法感知这个事件，也就无法获取到已连接的 socket，那服务端自然就没机会对 socket 调用 close 函数了。</p><p>不过这种原因发生的概率比较小，这种属于明显的代码逻辑 bug，在前期 read view 阶段就能发现的了。</p><p><strong>第二个原因</strong>：第 3 步没有做，有新连接到来时没有调用 accpet 获取该连接的 socket，导致当有大量的客户端主动断开了连接，而服务端没机会对这些 socket 调用 close 函数，从而导致服务端出现大量 CLOSE_WAIT 状态的连接。</p><p>发生这种情况可能是因为服务端在执行 accpet  函数之前，代码卡在某一个逻辑或者提前抛出了异常。</p><p><strong>第三个原因</strong>：第 4 步没有做，通过 accpet 获取已连接的 socket 后，没有将其注册到 epoll，导致后续收到 FIN 报文的时候，服务端没办法感知这个事件，那服务端就没机会调用 close 函数了。</p><p>发生这种情况可能是因为服务端在将已连接的 socket 注册到 epoll 之前，代码卡在某一个逻辑或者提前抛出了异常。之前看到过别人解决 close_wait 问题的实践文章，感兴趣的可以看看：<a href="https://mp.weixin.qq.com/s?__biz=MzU3Njk0MTc3Ng==&mid=2247486020&idx=1&sn=f7cf41aec28e2e10a46228a64b1c0a5c&scene=21#wechat_redirect">一次 Netty 代码不健壮导致的大量 CLOSE_WAIT 连接原因分析</a></p><p><strong>第四个原因</strong>：第 6 步没有做，当发现客户端关闭连接后，服务端没有执行 close 函数，可能是因为代码漏处理，或者是在执行 close 函数之前，代码卡在某一个逻辑，比如发生死锁等等。</p><p>可以发现，<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，通常都是代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用 close</strong>。<br>面试问题</p><p>1）TCP&#x2F;IP协议<br>    1）三次握手&#x2F;四次挥手过程<br>    2）TIME_WAIT状态<br>        1）主动关闭&#x2F;被动关闭<br>        2）需要的原因<br>        3）缓解措施<br>        4）有没有方式不出现TIME_WAIT状态<br>    3）RST出现的场景<br>    4）滑动窗口<br>2）网络编程<br>    1）EPOLL&#x2F;SELECT的区别<br>    2）边沿触发&#x2F;水平触发<br>    3）事件触发的场景<br>        1）读事件 有哪些场景<br>        2）写事件 有哪些场景<br>    4）READ调用返回值场景<br>        1）0<br>        2）-1<br>        3）&gt;0<br>    5）UDP客户端可以CONNECT不，那CONNECT和不CONNECT有啥区别<br>3）后台编程<br>    1）FORK的用途，FORK区分父子进程方式<br>    2）进程间通信方式<br>    3）僵尸进程<br>    4）内存模型，有哪些段构成<br>    5）进程&#x2F;线程&#x2F;协程的区别<br>4）常见中间件<br>    1）MYSQL<br>        1）为啥不建议SELECT *<br>        2）覆盖索引<br>        3）分页优化<br>    2）ZOOKEEPER<br>        1）有哪些WATCH以及对应唤醒事件<br>    3）KAFKA<br>        1）分区分服<br>        2）生产者<br>        3）消费者<br>5）语言<br>    1）JAVA语言<br>        1）内存管理<br>6）设计模式<br>    1）单例模式<br>7）项目中的难点、挑战点</p><p>22989-腾讯云网络后台开发工程师(CSIG全资子公司)（西安）</p><p>建议用online ddl（网上可以查）修改，就是逗号后面的参数<br>另外，添加字段要加上after，根据表结构看看fromWanIp适合在哪个字段后<br>ALTER TABLE cEip ALTER COLUMN ispId SET DEFAULT -1, ALGORITHM&#x3D;INPLACE, LOCK&#x3D;NONE;</p><h3 id="HTTP-长连接和-TCP-长连接有什么区别？"><a href="#HTTP-长连接和-TCP-长连接有什么区别？" class="headerlink" title="HTTP 长连接和 TCP 长连接有什么区别？"></a>HTTP 长连接和 TCP 长连接有什么区别？</h3><p>其实就是HTTP 的 Keep-Alive 和 TCP 的 Keepalive 有什么区别？<br>事实上，<strong>这两个完全是两样不同东西</strong>，实现的层面也不同：</p><ul><li><p>HTTP 的 Keep-Alive，是由<strong>应用层（用户态）</strong> 实现的，称为 HTTP 长连接；</p></li><li><p>TCP 的 Keepalive，是由 <strong>TCP 层（内核态）</strong> 实现的，称为 TCP 保活机制；</p></li></ul><p>接下来，分别说说它们。</p><h4 id="HTTP-的-Keep-Alive"><a href="#HTTP-的-Keep-Alive" class="headerlink" title="HTTP 的 Keep-Alive"></a>HTTP 的 Keep-Alive</h4><p>HTTP 协议采用的是「请求-应答」的模式，也就是客户端发起了请求，服务端才会返回响应，一来一回这样子。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcicwmSuxnPJ1qyiaohMl86ibZhnSbPF3JPicyAmYmy8jQZb5zFKD8tGSDQGkCsrbPD7jJLicqRVet6vrA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>请求-应答</p><p>由于 HTTP 是基于 TCP 传输协议实现的，客户端与服务端要进行 HTTP 通信前，需要先建立 TCP 连接，然后客户端发送 HTTP  请求，服务端收到后就返回响应，至此「请求-应答」的模式就完成了，随后就会释放 TCP 连接。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcicwmSuxnPJ1qyiaohMl86ibZcOoBjt1XmlEoAWTf4V6musIJQE5nxsRRe5gjciaDLPJUZbhZowzibMibQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>一个 HTTP 请求</p><p>如果每次请求都要经历这样的过程：建立 TCP -&gt; 请求资源 -&gt; 响应资源 -&gt; 释放连接，那么此方式就是 <strong>HTTP 短连接</strong>，如下图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcicwmSuxnPJ1qyiaohMl86ibZ3ulicF0AUhTNPjyHE5Dur1sI8cda110PRsPmYEenOIBHpZnayHUFkow/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>HTTP 短连接</p><p>这样实在太累人了，一次连接只能请求一次资源。</p><p>能不能在第一个 HTTP 请求完后，先不断开 TCP 连接，让后续的 HTTP 请求继续使用此连接？</p><p>当然可以，HTTP 的 Keep-Alive 就是实现了这个功能，可以使用同一个 TCP 连接来发送和接收多个 HTTP 请求&#x2F;应答，避免了连接建立和释放的开销，这个方法称为 <strong>HTTP 长连接</strong>。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcicwmSuxnPJ1qyiaohMl86ibZAJAJPbK9xMB5j9nTzs87SwRibAU52mG4ILuB3XvpXNll4gKYazoYUaw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>HTTP 长连接</p><p>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p><p>怎么才能使用 HTTP 的 Keep-Alive 功能？</p><p>在 HTTP 1.0 中默认是关闭的，如果浏览器要开启 Keep-Alive，它必须在请求的包头中添加：</p><p><code>Connection: Keep-Alive   </code></p><p>然后当服务器收到请求，作出回应的时候，它也添加一个头在响应中：</p><p><code>Connection: Keep-Alive   </code></p><p>这样做，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接。这一直继续到客户端或服务器端提出断开连接。</p><p><strong>从 HTTP 1.1 开始， 就默认是开启了 Keep-Alive</strong>，如果要关闭 Keep-Alive，需要在 HTTP 请求的包头里添加：</p><p><code>Connection:close   </code></p><p>现在大多数浏览器都默认是使用 HTTP&#x2F;1.1，所以 Keep-Alive 都是默认打开的。一旦客户端和服务端达成协议，那么长连接就建立好了。</p><p>HTTP 长连接不仅仅减少了 TCP 连接资源的开销，而且这给 <strong>HTTP 流水线</strong>技术提供了可实现的基础。</p><p>所谓的 HTTP 流水线，是<strong>客户端可以先一次性发送多个请求，而在发送过程中不需先等待服务器的回应</strong>，可以减少整体的响应时间。</p><p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。HTTP 流水线机制则允许客户端同时发出 A 请求和 B 请求。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcicwmSuxnPJ1qyiaohMl86ibZy8Ha8LtNZHu3672NVwlpK4iaf9TibSkhbPfHKZHeruKPYdZ87utlcIIw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>右边为 HTTP 流水线机制</p><p>但是<strong>服务器还是按照顺序响应</strong>，先回应 A 请求，完成后再回应 B 请求。</p><p>而且要等服务器响应完客户端第一批发送的请求后，客户端才能发出下一批的请求，也就说如果服务器响应的过程发生了阻塞，那么客户端就无法发出下一批的请求，此时就造成了「队头阻塞」的问题。</p><p>可能有的同学会问，如果使用了 HTTP 长连接，如果客户端完成一个 HTTP 请求后，就不再发起新的请求，此时这个 TCP 连接一直占用着不是挺浪费资源的吗？</p><p>对没错，所以为了避免资源浪费的情况，web 服务软件一般都会提供 <code>keepalive_timeout</code> 参数，用来指定 HTTP 长连接的超时时间。</p><p>比如设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会<strong>启动一个定时器</strong>，如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，<strong>定时器的时间一到，就会触发回调函数来释放该连接。</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcicwmSuxnPJ1qyiaohMl86ibZlTIRFic7L5E39WAIhnL2EibUTRwYIqCReFq4J6RKfcmozBP9agZCundA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>HTTP 长连接超时</p><h4 id="TCP-的-Keepalive"><a href="#TCP-的-Keepalive" class="headerlink" title="TCP 的 Keepalive"></a>TCP 的 Keepalive</h4><p>TCP 的 Keepalive 这东西其实就是 <strong>TCP 的保活机制</strong>，它的工作原理我之前的文章写过，这里就直接贴下以前的内容。</p><p>如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。</p><ul><li><p>如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</p></li><li><p>如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</p></li></ul><p>所以，TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活，这个工作是在内核完成的。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcicwmSuxnPJ1qyiaohMl86ibZHmAI3j2722ibjS7IibNtaiaZibbDpMpBPC8OWbfHsEHwcacE0ZRjgc8pibg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>TCP 保活机制</p><p>注意，应用程序若想使用 TCP 保活机制需要通过 socket 接口设置 <code>SO_KEEPALIVE</code> 选项才能够生效，如果没有设置，那么就无法使用 TCP 保活机制。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>HTTP 的 Keep-Alive 也叫 HTTP 长连接，该功能是由「应用程序」实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求&#x2F;应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销。</p><p>TCP 的 Keepalive 也叫 TCP 保活机制，该功能是由「内核」实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。</p><h3 id="HTTPS-一定安全可靠吗？"><a href="#HTTPS-一定安全可靠吗？" class="headerlink" title="HTTPS 一定安全可靠吗？"></a>HTTPS 一定安全可靠吗？</h3><p>客户端通过浏览器向服务端发起 HTTPS 请求时，被「假基站」转发到了一个「中间人服务器」，于是客户端是和「中间人服务器」完成了 TLS 握手，然后这个「中间人服务器」再与真正的服务端完成 TLS 握手。</p><p>具体过程如下：<br>![[Pasted image 20230517164728.png]]</p><ul><li><p>客户端向服务端发起 HTTPS 建立连接请求时，然后被「假基站」转发到了一个「中间人服务器」，接着中间人向服务端发起 HTTPS 建立连接请求，此时客户端与中间人进行 TLS 握手，中间人与服务端进行 TLS 握手；</p></li><li><p>在客户端与中间人进行 TLS 握手过程中，中间人会发送自己的公钥证书给客户端，<strong>客户端验证证书的真伪</strong>，然后从证书拿到公钥，并生成一个随机数，用公钥加密随机数发送给中间人，中间人使用私钥解密，得到随机数，此时双方都有随机数，然后通过算法生成对称加密密钥（A），后续客户端与中间人通信就用这个对称加密密钥来加密数据了。</p></li><li><p>在中间人与服务端进行 TLS 握手过程中，服务端会发送从 CA 机构签发的公钥证书给中间人，从证书拿到公钥，并生成一个随机数，用公钥加密随机数发送给服务端，服务端使用私钥解密，得到随机数，此时双方都有随机数，然后通过算法生成对称加密密钥（B），后续中间人与服务端通信就用这个对称加密密钥来加密数据了。</p></li><li><p>后续的通信过程中，中间人用对称加密密钥（A）解密客户端的 HTTPS 请求的数据，然后用对称加密密钥（B）加密 HTTPS 请求后，转发给服务端，接着服务端发送 HTTPS 响应数据给中间人，中间人用对称加密密钥（B）解密 HTTPS 响应数据，然后再用对称加密密钥（A）加密后，转发给客户端。</p></li></ul><p>从客户端的角度看，其实并不知道网络中存在中间人服务器这个角色。</p><p>那么中间人就可以解开浏览器发起的 HTTPS 请求里的数据，也可以解开服务端响应给浏览器的 HTTPS 响应数据。相当于，中间人能够 “偷看” 浏览器与服务端之间的 HTTPS 请求和响应的数据。</p><p>但是要发生这种场景是有前提的，<strong>前提是用户点击接受了中间人服务器的证书。</strong></p><p>中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0Dm1SNmvUayxCflHTROibNzricwiaRlwzuc1CUqXYTYEapwDNUybxhiaWfofHt7LSuzC4cFdYvwcJoA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>如果用户执意点击「继续浏览此网站」，相当于用户接受了中间人伪造的证书，那么后续整个 HTTPS 通信都能被中间人监听了。</p><p>所以，这其实并不能说 HTTPS 不够安全，毕竟浏览器都已经提示证书有问题了，如果用户坚决要访问，那<strong>不能怪 HTTPS ，得怪自己手贱</strong>。</p><h4 id="客户端是如何验证证书的？"><a href="#客户端是如何验证证书的？" class="headerlink" title="客户端是如何验证证书的？"></a>客户端是如何验证证书的？</h4><p>接下来，详细说一下实际中数字证书签发和验证流程。</p><p>如下图图所示，为数字证书签发和验证流程：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0Dm1SNmvUayxCflHTROibNMxlSGIfI1kiav1TwxTK6ZtGiaCiaygM3g0fFnPYo3n9atZlbhvpkWt77Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">当服务端向 CA 机构申请证书的时候，CA 签发证书的过程，如上图左边部分：</p><ul><li><p>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</p></li><li><p>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</p></li><li><p>最后将 Certificate Signature 添加在文件证书上，形成数字证书；</p></li></ul><p>客户端校验服务端的数字证书的过程，如上图右边部分：</p><ul><li><p>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</p></li><li><p>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</p></li><li><p>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</p></li></ul><p>但事实上，证书的验证过程中<strong>还存在一个证书信任链的问题</strong>，因为我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的，比如百度的证书，从下图你可以看到，证书的层级有三级：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0Dm1SNmvUayxCflHTROibNVINCkWDhqk7OiaibpvuUnYAt2GXtShM9z5bWCG1TSZH6LzzylakSk83w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>对于这种三级层级关系的证书的验证过程如下：</p><ul><li><p>客户端收到 baidu.com 的证书后，发现这个证书的签发者不是根证书，就无法根据本地已有的根证书中的公钥去验证 baidu.com 证书是否可信。于是，客户端根据 baidu.com 证书中的签发者，找到该证书的颁发机构是 “GlobalSign Organization Validation CA - SHA256 - G2”，然后向 CA 请求该中间证书。</p></li><li><p>请求到证书后发现 “GlobalSign Organization Validation CA - SHA256 - G2” 证书是由 “GlobalSign Root CA” 签发的，由于 “GlobalSign Root CA” 没有再上级签发机构，说明它是根证书，也就是自签证书。应用软件会检查此证书有否已预载于根证书清单上，如果有，则可以利用根证书中的公钥去验证 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，如果发现验证通过，就认为该中间证书是可信的。</p></li><li><p>“GlobalSign Organization Validation CA - SHA256 - G2” 证书被信任后，可以使用 “GlobalSign Organization Validation CA - SHA256 - G2” 证书中的公钥去验证 baidu.com 证书的可信性，如果验证通过，就可以信任 baidu.com 证书。</p></li></ul><p>在这四个步骤中，最开始客户端只信任根证书 GlobalSign Root CA 证书的，然后 “GlobalSign Root CA” 证书信任 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，而 “GlobalSign Organization Validation CA - SHA256 - G2” 证书又信任 baidu.com 证书，于是客户端也信任 baidu.com 证书。总括来说，由于用户信任 GlobalSign，所以由 GlobalSign 所担保的 baidu.com 可以被信任，另外由于用户信任操作系统或浏览器的软件商，所以由软件商预载了根证书的 GlobalSign 都可被信任。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0Dm1SNmvUayxCflHTROibNIPhXyF7S1WDIbuUbGwgLjwr47iau48ape1H3GYg8B0hDEKeqdz7xZgg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>操作系统里一般都会内置一些根证书，比如我的 MAC 电脑里内置的根证书有这么多：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0Dm1SNmvUayxCflHTROibNloHzrlsep6vZgNvz8sA8LDBHnAWyErqcpicRM6kovSB5L3IQcjdD5aw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>这样的一层层地验证就构成了一条信任链路，整个证书信任链验证流程如下图所示：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0Dm1SNmvUayxCflHTROibNFruFDENMpzLgnfRH9T8uN0TAOItwoqia9mXLNLsE7UErltjyBu2zicNQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>如果你的电脑中毒了，被恶意导入了中间人的根证书，那么在验证中间人的证书的时候，由于你操作系统信任了中间人的根证书，那么等同于中间人的证书是合法的。</p><p>这种情况下，浏览器是不会弹出证书存在问题的风险提醒的。</p><p>这其实也不关 HTTPS 的事情，是你电脑中毒了才导致 HTTPS 数据被中间人劫持的。</p><p>所以，<strong>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全。</strong></p><h4 id="为什么抓包工具能截取-HTTPS-数据？"><a href="#为什么抓包工具能截取-HTTPS-数据？" class="headerlink" title="为什么抓包工具能截取 HTTPS 数据？"></a>为什么抓包工具能截取 HTTPS 数据？</h4><p>抓包工具 Fiddler 之所以可以明文看到 HTTPS 数据，工作原理与中间人一致的。</p><p>对于 HTTPS 连接来说，中间人要满足以下两点，才能实现真正的明文代理:</p><ol><li><p>中间人，作为客户端与真实服务端建立连接这一步不会有问题，因为服务端不会校验客户端的身份；</p></li><li><p>中间人，作为服务端与真实客户端建立连接，这里会有客户端信任服务端的问题，也就是服务端必须有对应域名的私钥；</p></li></ol><p>中间人要拿到私钥只能通过如下方式：</p><ol><li><p>去网站服务端拿到私钥；</p></li><li><p>去CA处拿域名签发私钥；</p></li><li><p>自己签发证书，且被浏览器信任；</p></li></ol><p>不用解释，抓包工具只能使用第三种方式取得中间人的身份。</p><p>使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装 Fiddler 的根证书，这里实际上起认证中心（CA）的作用。</p><p>Fiddler 能够抓包的关键是客户端会往系统受信任的根证书列表中导入 Fiddler 生成的证书，而这个证书会被浏览器信任，也就是 Fiddler 给自己创建了一个认证中心 CA。</p><p>客户端拿着中间人签发的证书去中间人自己的 CA 去认证，当然认为这个证书是有效的。</p><h4 id="如何避免被中间人抓取数据？"><a href="#如何避免被中间人抓取数据？" class="headerlink" title="如何避免被中间人抓取数据？"></a>如何避免被中间人抓取数据？</h4><p>我们要保证自己电脑的安全，不要被病毒乘虚而入，而且也不要点击任何证书非法的网站，这样 HTTPS 数据就不会被中间人截取到了。</p><p>当然，我们还可以通过 HTTPS 双向认证来避免这种问题。</p><p>一般我们的 HTTPS 是单向认证，客户端只会验证了服务端的身份，但是服务端并不会验证客户端的身份。</p><p>如果用了双向认证方式，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZf0Dm1SNmvUayxCflHTROibNccBibe4MEf260dWmCfGnvHgz7iaZza3s1Sq6UwibbuGickDfMIcwAlGBGQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。</p><h3 id="客户端连接一个不存在的-IP-地址，会发生什么？客户端连接一个存在的-IP-地址但是端口不存在，会发生什么？"><a href="#客户端连接一个不存在的-IP-地址，会发生什么？客户端连接一个存在的-IP-地址但是端口不存在，会发生什么？" class="headerlink" title="客户端连接一个不存在的 IP 地址，会发生什么？客户端连接一个存在的 IP 地址但是端口不存在，会发生什么？"></a>客户端连接一个不存在的 IP 地址，会发生什么？客户端连接一个存在的 IP 地址但是端口不存在，会发生什么？</h3><p>PS：这里的「连接」指的是 TCP 连接。</p><blockquote><p>Q1：客户端连接一个不存在的 IP 地址，会发生什么？</p></blockquote><p>这个问题要分两种情况来思考，不同的情况得到的结论是不同的。</p><p><em>第一个情况：目标 IP 地址和客户端的 IP 地址是同一个局域网（网络号相同）。</em></p><p>第一种情况，客户端无法发出 SYN 报文，主要卡在数据链路层。</p><p>因为目标地址不存在 IP 地址，客户端的内核在发 arp 请求的时候，广播询问这个目标 IP 地址是谁的，由于网络中不存在该目标 IP 地址，所以没有设备应答客户端的 arp 请求。</p><p>由于<strong>客户端无法拿到目标设备的 MAC，这样就没办法组装 MAC 头的信息，所以 SYN 报文无法发送出去</strong>。</p><p><em>第二个情况：目标 IP 地址和客户端的 IP 地址不在同一个局域网（网络号不同）。</em></p><p>第二种情况，客户端会先将 SYN 报文发给路由器，然后路由器会继续转发。</p><p>由于目标 IP 地址是不存在的，该 SYN 报文会在网络中消亡，因此客户端是不会收到对 SYN 报文的确认报文的，接着<strong>客户端会触发超时重传，重传 SYN 报文，直到重传的次数达到最大次数后，客户端的连接就会被释放</strong>。</p><p>可能有的同学好奇，为什么这种情况客户端的 SYN 报文可以发出来？</p><p>因为当目标 IP 地址和客户端 IP 地址不在同一个局域网时，客户端客通过路由表的判断，判断到下一步是要将网络报文发送给路由器。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfm4PfB688v0rxFhJb6z15lQyA1upkFc3DxHn6sJ50fuyvdBMNTQUZ1FK1d5qM2C9ibWQP0eOKpcaw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>这时候数据链路层的 arp 请求，会广播询问 IP 地址（路由器 IP 地址）是谁的，路由器发现是自己的 IP 地址，于是就会将自己的 MAC 地址告诉客户端。</p><p>然后客户端的网络报文中 MAC 头的「目标 MAC 地址」填入的就是路由器的 MAC 地址，于是 SYN 报文就可以发送出去了。</p><p>由于目标 MAC 地址是路由器的，所以就会被路由器接收，然后路由器继续通过路由表的判断，转发给下一个路由器，直到找到目标设备。</p><blockquote><p>Q2：客户端连接一个存在的 IP 地址但是端口不存在，会发生什么？</p></blockquote><p>客户端连接的目标 IP 地址是存在的，那么 SYN 报文就能正确的抵达到目标设备。</p><p>目标设备收到 SYN 报文后，发现端口号并没有被进程监听，这时候目标设备的内核就会回 RST 报文。</p><p>客户端收到 RST 报文后，就会释放连接。</p><p>…….</p><p>至此，结论已说完。</p><p>不知道你们会不会觉得信息量很大，如果你觉得信息量大，那么你该补补网络知识啦。</p><p>第二题不难，难在的是第一题，如果你没有把两台电脑之间是怎么通信的搞清楚，那么你是无从下手回答的，所以建立好体系化的网络知识，面对这类的场景题目，就能做到举一反三了。</p><p>最近比较忙，偷懒了，没有画图，如果哪里没理解的，可以先看我以前写的这篇文章：<a href="http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247483989&idx=1&sn=7e2ed852770743d3955ef9d5561fcef3&chksm=f98e46ffcef9cfe98e6c753afac86125b0d5891ca5e63968b5f3a8da4905d14274088f40c34e&scene=21#wechat_redirect">探究！一个数据包在网络中的心路历程</a>，有详细讲解每一层是怎么封装头部的，以及路由表是怎么判断的。</p><p><strong>最后再提一个问题：****客户端发送了一个目标 IP 地址存在但是</strong>端口不存在的 UDP 报文<strong>，UDP 没有像 TCP 那样的 RST 报文，此时会发生什么？</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;00_NetworkInterview&lt;br&gt;aliases:&lt;br&gt;tags: #cs#interview #network&lt;br&gt;date: 2023-10-08 15:29&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;Network&quot;&gt;&lt;a href=&quot;#Networ</summary>
      
    
    
    
    <category term="100_CodingSkills" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/"/>
    
    <category term="107_Network" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/107-Network/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-106-Cpp-00-CppInterview/"/>
    <id>http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-106-Cpp-00-CppInterview/</id>
    <published>2024-08-15T09:50:31.526Z</published>
    <updated>2024-08-15T09:50:43.445Z</updated>
    
    <content type="html"><![CDATA[<hr><p>00_CppInterview<br>aliases:<br>tags: #cs#interview #cpp<br>date: 2023-10-08 15:29</p><hr><h2 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h2><h3 id="对new和malloc的理解"><a href="#对new和malloc的理解" class="headerlink" title="对new和malloc的理解"></a>对new和malloc的理解</h3><p>new和malloc都是动态内存分配函数。其中，new是C++中的操作符，malloc是C语言中的函数。new会调用对象的构造函数，而malloc不会。使用new可以简化代码，并且更加类型安全。<br><strong>new和malloc区别：</strong></p><ul><li><p><strong>分配内存的位置</strong>：malloc是从堆上动态分配内存，new是从自由存储区为对象动态分配内存。自由存储区的位置取决于operator new的实现。自由存储区不仅可以为堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。</p></li><li><p><strong>返回类型安全性</strong>：malloc内存分配成功后返回void*，然后再强制类型转换为需要的类型；new操作符分配内存成功后返回与对象类型相匹配的指针类型；因此new是符合类型安全的操作符。</p></li><li><p><strong>内存分配失败返回值</strong>：malloc内存分配失败后返回NULL。new分配内存失败则会抛异常（bac_alloc）。</p></li><li><p><strong>分配内存的大小的计算</strong>：使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。</p></li><li><p><strong>是否可以被重载</strong>：opeartor new &#x2F;operator delete可以被重载。而malloc&#x2F;free则不能重载。</p></li></ul><p><strong>new是在内存上哪一块去分配的内存</strong></p><p>堆</p><p><strong>补充：</strong></p><p>new所申请的内存区域在C++中称为自由存储区。很多编译器的new&#x2F;delete都是以malloc&#x2F;free为基础来实现的，所以通常都是借由堆实现来实现自由存储，这时候就可以说new所申请的内存区域在堆上。</p><p><strong>如果new内存失败了会是怎么样？</strong></p><p>会抛出std::bad_alloc异常。</p><p><strong>补充：</strong></p><p>如果加上std::nothrow关键字，A* p &#x3D; new (std::nothrow) A;，new 就不会抛出异常而是会返回空指针。</p><h3 id="析构函数为什么通常是会做成一个虚函数呢"><a href="#析构函数为什么通常是会做成一个虚函数呢" class="headerlink" title="析构函数为什么通常是会做成一个虚函数呢"></a>析构函数为什么通常是会做成一个虚函数呢</h3><p>如果一个类有虚函数，就应该为其定义一个虚析构函数。这是因为在使用delete操作符释放一个指向派生类对象的基类指针时，如果基类的析构函数不是虚函数，那么只会调用基类的析构函数，而不会调用派生类的析构函数，这样就会导致内存泄漏和未定义行为的问题。通过将析构函数定义为虚函数，可以确保在释放派生类对象时，先调用派生类的析构函数，再调用基类的析构函数，从而避免内存泄漏和未定义行为的问题。</p><h3 id="右值引用有什么作用"><a href="#右值引用有什么作用" class="headerlink" title="右值引用有什么作用"></a>右值引用有什么作用</h3><p>右值引用是C++11引入的特性，它是指对右值进行引用的一种方式。右值引用的作用主要有两个：</p><ul><li>在传递一个对象时，如果使用的是左值引用，那么会调用对象的拷贝构造函数。但是如果该对象只需要被移动而不需要进行复制，就会浪费时间和内存。右值引用可以通过std::move将一个左值转换为右值，从而调用对象的移动构造函数，实现了移动语义，避免了不必要的拷贝操作，提高了程序的效率。</li><li>右值引用还可以用于完美转发。在函数模板中，通过使用右值引用类型的形参来接收参数，可以实现完美转发，即保持原参数的值类别（左值还是右值），将参数传递给另一个函数。</li></ul><h3 id="智能指针相关"><a href="#智能指针相关" class="headerlink" title="智能指针相关"></a>智能指针相关</h3><p><strong>定义</strong><br>智能指针是C++中的一种特殊指针，它是一个对象，用来管理另一个指针所指向的对象的生命周期。智能指针可以自动地分配和释放内存，避免手动管理内存的麻烦和出错风险。</p><p>C++标准库提供了三种智能指针：</p><ul><li>shared_ptr：多个智能指针可以共享同一个对象，当最后一个指针被销毁时，它会释放对象的内存。</li><li>unique_ptr：独占式智能指针，不能共享同一个对象，当智能指针被销毁时，它会释放对象的内存。</li><li>weak_ptr：弱引用智能指针，不会增加对象的引用计数，用于避免shared_ptr循环引用时的内存泄漏问题。</li></ul><p><strong>在哪些场景下会应用智能指针</strong></p><p>我自己是在在动态内存管理中，使用智能指针可以避免手动管理内存的麻烦和出错风险。</p><h3 id="如果遇到内存泄漏这种问题，你一般是怎么去解决"><a href="#如果遇到内存泄漏这种问题，你一般是怎么去解决" class="headerlink" title="如果遇到内存泄漏这种问题，你一般是怎么去解决"></a>如果遇到内存泄漏这种问题，你一般是怎么去解决</h3><ul><li>在程序中加入必要的错误处理代码，避免程序因为异常情况而导致内存泄漏。</li><li>使用智能指针等RAII机制，自动管理内存，避免手动管理内存的麻烦和出错风险。</li><li>使用内存分析工具，检测程序中的内存泄漏，并进行相应的修复</li></ul><h3 id="shared-ptr的原理"><a href="#shared-ptr的原理" class="headerlink" title="shared_ptr的原理"></a>shared_ptr的原理</h3><p>答：内部的共享数据和引用计数实现</p><p><strong>补充：</strong></p><p>shared_ptr多个指针指向相同的对象。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。</p><p>shared_ptr的一个最大的陷阱是循环引用，循环引用会导致堆内存无法正确释放，导致内存泄漏，可以通过 weak_ptr 来解决这个问题。</p><h3 id="多线程怎么保证引用计数的安全的"><a href="#多线程怎么保证引用计数的安全的" class="headerlink" title="多线程怎么保证引用计数的安全的"></a>多线程怎么保证引用计数的安全的</h3><p>答：引用计数这个变量是std::atomic，操作时自带锁</p><h3 id="常见的锁有哪些"><a href="#常见的锁有哪些" class="headerlink" title="常见的锁有哪些"></a>常见的锁有哪些</h3><p>答：读写锁、互斥锁这些，再就是一些锁思想，比如乐观锁、悲观锁、自旋锁</p><h3 id="valotile关键字的用处"><a href="#valotile关键字的用处" class="headerlink" title="valotile关键字的用处"></a>valotile关键字的用处</h3><p><code>volatile</code>是C和C++中的一个关键字，用于告诉编译器，所修饰的变量在程序执行期间可能会被意外地改变，因此不能进行优化。下面是几个<code>volatile</code>关键字的用处：</p><ol><li>防止编译器进行优化 当使用<code>volatile</code>关键字修饰变量时，编译器就不会对这个变量进行优化，因为这个变量可能会在程序运行期间被其他程序或者硬件进行修改。例如：</li></ol><p><code>volatile int* ptr = ...; int a = *ptr;</code></p><p>如果<code>ptr</code>所指向的内存是由硬件设备直接控制，则编译器不能对其进行优化。</p><ol start="2"><li><p>多线程访问同一个变量 在多线程编程中，如果多个线程都需要访问同一个变量，并且该变量可能会被其他线程修改，则应该使用<code>volatile</code>来修饰这个变量，以确保每个线程都能正确读取变量的最新值。</p></li><li><p>访问硬件寄存器 当程序需要访问硬件寄存器时，应该使用<code>volatile</code>来修饰寄存器，因为寄存器的值可能会被其他程序或者硬件进行修改。</p></li></ol><p>总之，<code>volatile</code>关键字用于告诉编译器，所修饰的变量在程序执行期间可能会被意外地改变，因此不能进行优化。在多线程编程和访问硬件寄存器时，应该使用<code>volatile</code>来修饰变量，以确保程序能够正确地读取最新的值。</p><ul><li>数组、指针和引用的区别</li><li>类成员和方法，说出方法匹配顺序、默认参数</li><li>继承 构造函数和析构函数 调用顺序</li><li>const、static的使用场景</li><li>多态的实现、虚表实现多态机制</li><li>虚函数、纯虚函数、抽象类概念，抽象类为什么不能实例化</li></ul><h3 id="vector和list区别，-内存分别，-不同的使用场景，"><a href="#vector和list区别，-内存分别，-不同的使用场景，" class="headerlink" title="vector和list区别， 内存分别， 不同的使用场景，"></a>vector和list区别， 内存分别， 不同的使用场景，</h3><p><code>vector</code>和<code>list</code>都是C++ STL（Standard Template Library）中的容器。它们在存储数据时的内存分配方式不同，具有以下几点区别：</p><ol><li><p>存储方式 <code>vector</code>采用连续的动态数组存储元素，因此在访问元素时可以随机访问，速度较快。而<code>list</code>采用双向链表存储元素，因此在访问元素时只能顺序访问，速度相对较慢。</p></li><li><p>内存分配 由于<code>vector</code>采用连续的动态数组存储元素，因此需要预分配一块连续的内存空间。当插入元素时，如果当前内存空间不足，则需要重新分配一块更大的内存空间，并将原有元素复制到新的内存空间中。而<code>list</code>则是通过链表进行存储，每个节点存储一个元素，因此在插入或者删除元素时，只需要修改相应的链表指针即可。</p></li><li><p>内存占用 由于<code>vector</code>需要预分配一段连续的内存空间，因此在存储大量元素时可能会浪费一定的内存空间。而<code>list</code>则是通过链表进行存储，每个节点只存储一个元素和两个指针，因此在存储大量元素时占用的内存空间相对较小。</p></li><li><p>插入、删除操作 由于<code>vector</code>采用连续的动态数组存储元素，因此在插入或者删除元素时需要移动其它元素，并且可能需要重新分配内存空间。而<code>list</code>则是通过链表进行存储，每个节点只需要修改指针即可进行插入或者删除操作。</p></li></ol><p>总之，<code>vector</code>和<code>list</code>是C++ STL中的常用容器，它们在存储数据时的内存分配方式不同，具有各自的优缺点。在使用时需要根据具体情况选择合适的容器，并结合实际场景进行性能分析和测试，以确保程序的高效运行。</p><h3 id="swap实现快速删除"><a href="#swap实现快速删除" class="headerlink" title="swap实现快速删除"></a>swap实现快速删除</h3><h3 id="vector和list区别"><a href="#vector和list区别" class="headerlink" title="vector和list区别"></a><code>vector</code>和list区别</h3><p>都是C++ STL（Standard Template Library）中的容器。它们在存储数据时的内存分配方式不同，具有以下几点区别：</p><ol><li><p>存储方式 <code>vector</code>采用连续的动态数组存储元素，因此在访问元素时可以随机访问，速度较快。而<code>list</code>采用双向链表存储元素，因此在访问元素时只能顺序访问，速度相对较慢。</p></li><li><p>内存分配 由于<code>vector</code>采用连续的动态数组存储元素，因此需要预分配一块连续的内存空间。当插入元素时，如果当前内存空间不足，则需要重新分配一块更大的内存空间，并将原有元素复制到新的内存空间中。而<code>list</code>则是通过链表进行存储，每个节点存储一个元素，因此在插入或者删除元素时，只需要修改相应的链表指针即可。</p></li><li><p>内存占用 由于<code>vector</code>需要预分配一段连续的内存空间，因此在存储大量元素时可能会浪费一定的内存空间。而<code>list</code>则是通过链表进行存储，每个节点只存储一个元素和两个指针，因此在存储大量元素时占用的内存空间相对较小。</p></li><li><p>插入、删除操作 由于<code>vector</code>采用连续的动态数组存储元素，因此在插入或者删除元素时需要移动其它元素，并且可能需要重新分配内存空间。而<code>list</code>则是通过链表进行存储，每个节点只需要修改指针即可进行插入或者删除操作。</p></li></ol><p>总之，<code>vector</code>和<code>list</code>是C++ STL中的常用容器，它们在存储数据时的内存分配方式不同，具有各自的优缺点。在使用时需要根据具体情况选择合适的容器，并结合实际场景进行性能分析和测试，以确保程序的高效运行。</p><ul><li><p>map实现，map.find时间复杂度</p></li><li><p>gdb的使用， 如何调试多线程</p></li><li><p>浅拷贝、深拷贝，如何通过自定义拷贝构造函数实现深拷贝</p></li><li><p>map、unorder_map区别，了解使用场景</p></li><li><p>new、delete过程，继承情况下调用顺序</p></li><li><p>全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？<br>  <code>  可以，在不同的C文件中以static形式来声明同名全局变量。可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错.  </code></p></li><li><p>static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？Static函数与普通函数有什么区别？<br>  <code>  (1)把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。    全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。(2)把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。(3)static函数与普通函数作用域不同,仅在本文件。    综上所述:     static全局变量与普通的全局变量有什么区别：    static全局变量只初使化一次，防止在其他文件单元中被引用;    static局部变量和普通局部变量有什么区别：    static局部变量只被初始化一次，下一次依据上一次结果值；    static函数与普通函数有什么区别：    static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝  </code></p></li><li><p>以下代码存在的问题？<br>  <code>  char string[] = “Linux C”;   char *p = “Linux C”;   string[0] = &#39;a&#39;;   p[0] = &#39;a&#39;;   注：”Linux C”是一个字符串常量。C语言对于字符串常量通常是这样处理的：在内存中开辟一个字符数组来存储该字符串常量，并把开辟出的字符数组的首地址赋给p.   注：string[0] = ‘a’是可以的，而p[0] = ‘a’是非法的，因为p指向的是字符串常量，常量的内容不可改变。把p指向一个字符串常量或字符数组时合法的，例如：p = “Hello World!”; p= string;</code></p></li><li><p>什么函数不能声明为虚函数？<br>  <code>构造函数</code></p></li><li><p>不能做switch()的参数类型<br>  <code>switch的参数不能为实型。</code></p></li><li><p>如何引用一个已经定义过的全局变量？<br>  <code>可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变量，假定你将那个变量写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。</code></p></li><li><p>C++中虚函数的意义<br>  &#96;&#96;<br>  C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数；在派生类中对基类定义的虚函数进行重写时，需要再派生类中声明该方法为虚方法。当子类重新定义了父类的虚函数后，当父类的指针指向子类对象的地址时，[即B b; A a &#x3D; &amp;b;] 父类指针根据赋给它的不同子类指针，动态的调用子类的该函数，而不是父类的函数（如果不使用virtual方法，请看后面★*），且这样的函数调用发生在运行阶段，而不是发生在编译阶段，称为动态联编。而函数的重载可以认为是多态，只不过是静态的。注意，非虚函数静态联编，效率要比虚函数高，但是不具备动态联编能力。</p><p>  如果使用了virtual关键字，程序将根据引用或指针指向的 对 象 类 型 来选择方法，否则使用引用类型或指针类型来选择方法。<br>  编译器处理虚函数的方法是：为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，称为虚表指针（vptr），这种数组成为虚函数表（virtual function table, vtbl），即，每个类使用一个虚函数表，每个类对象用一个虚表指针。<br>  举个例子：基类对象包含一个虚表指针，指向基类中所有虚函数的地址表。派生类对象也将包含一个虚表指针，指向派生类虚函数表。看下面两种情况：<br>  如果派生类重写了基类的虚方法，该派生类虚函数表将保存重写的虚函数的地址，而不是基类的虚函数地址。<br>  如果基类中的虚方法没有在派生类中重写，那么派生类将继承基类中的虚方法，而且派生类中虚函数表将保存基类中未被重写的虚函数的地址。注意，如果派生类中定义了新的虚方法，则该虚函数的地址也将被添加到派生类虚函数表中。</p><p>  &#96;&#96;</p></li><li><p>参见《Effective C++》 条款09：绝不在构造函数或析构函数中调用虚函数。<br>  <code>原因分析：１.　从语法上讲，调用完全没有问题。２.　但是从效果上看，往往不能达到需要的目的。Effective 的解释是：派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。同样，进入基类析构函数时，对象也是基类类型。所以，虚函数始终仅仅调用基类的虚函数（如果是基类调用虚函数），不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果。</code></p></li><li><p>一个C++对象的大小由哪些因素决定？基类，成员，内存对齐，虚函数。</p></li><li><p>C++对象的成员函数对对象大小有什么影响？是否有虚函数，虚函数的个数多少对对象大小有什么影响？</p></li><li><p>一个C++对象的初始化顺序是什么？</p></li><li><p>虚析构函数有什么用途？</p></li><li><p>new operator和operator new什么区别和联系？</p></li><li><p>什么是placement new？</p></li><li><p>STL迭代器按照支持的操作分为哪几类？</p></li><li><p>Map和UnorderedMap的主要区别是什么？如何选择？</p></li><li><p>UnorderedMap如何解决Hash冲突？</p></li><li><p>Deque和Vector有什么区别？</p></li><li><p>什么是RAII机制？</p></li><li><p>在C++中，如何避免内存泄漏？</p></li><li><p>智能指针有哪些？什么用途？</p></li></ul><p>面试问题</p><p>1）TCP&#x2F;IP协议<br>    1）三次握手&#x2F;四次挥手过程<br>    2）TIME_WAIT状态<br>        1）主动关闭&#x2F;被动关闭<br>        2）需要的原因<br>        3）缓解措施<br>        4）有没有方式不出现TIME_WAIT状态<br>    3）RST出现的场景<br>    4）滑动窗口<br>2）网络编程<br>    1）EPOLL&#x2F;SELECT的区别<br>    2）边沿触发&#x2F;水平触发<br>    3）事件触发的场景<br>        1）读事件 有哪些场景<br>        2）写事件 有哪些场景<br>    4）READ调用返回值场景<br>        1）0<br>        2）-1<br>        3）&gt;0<br>    5）UDP客户端可以CONNECT不，那CONNECT和不CONNECT有啥区别<br>3）后台编程<br>    1）FORK的用途，FORK区分父子进程方式<br>    2）进程间通信方式<br>    3）僵尸进程<br>    4）内存模型，有哪些段构成<br>    5）进程&#x2F;线程&#x2F;协程的区别<br>4）常见中间件<br>    1）MYSQL<br>        1）为啥不建议SELECT *<br>        2）覆盖索引<br>        3）分页优化<br>    2）ZOOKEEPER<br>        1）有哪些WATCH以及对应唤醒事件<br>    3）KAFKA<br>        1）分区分服<br>        2）生产者<br>        3）消费者<br>5）语言<br>    1）JAVA语言<br>        1）内存管理<br>6）设计模式<br>    1）单例模式<br>7）项目中的难点、挑战点</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;00_CppInterview&lt;br&gt;aliases:&lt;br&gt;tags: #cs#interview #cpp&lt;br&gt;date: 2023-10-08 15:29&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;1-基本语法&quot;&gt;&lt;a href=&quot;#1-基本语法&quot; class=&quot;</summary>
      
    
    
    
    <category term="100_CodingSkills" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/"/>
    
    <category term="106_Cpp" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/106-Cpp/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-105-Python-%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98-20210908-%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    <id>http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-105-Python-%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98-20210908-%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/</id>
    <published>2024-08-15T09:50:31.526Z</published>
    <updated>2024-08-16T02:52:23.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据挖掘-2"><a href="#数据挖掘-2" class="headerlink" title="数据挖掘 2"></a>数据挖掘 2</h1><h2 id="四大块"><a href="#四大块" class="headerlink" title="四大块"></a>四大块</h2><p><img src="/../../../../images/data_dig.jpg" alt="image-20210908195234323"></p><p><a href="https://blog.csdn.net/weixin_44623752/article/details/118975075">https://blog.csdn.net/weixin_44623752/article/details/118975075</a></p><p>1，给定一个样本特征 , 我们希望预测其对应的属性值 , 如果 是离散的, 那么这就是一个分类问题，反之，如果 是连续的实数, 这就是一个回归问题。<br>2，如果给定一组样本特征 , 我们没有对应的属性值 , 而是想发掘这组样本在 二维空间的分布, 比如分析哪些样本靠的更近，哪些样本之间离得很远, 这就是属于聚类问题。<br>3，如果我们想用维数更低的子空间来表示原来高维的特征空间, 那么这就是降维问题。</p><p>无论是分类还是回归，都是想建立一个预测模型 ，给定一个输入 , 可以得到一个输出，<strong>不同的只是在分类问题中,</strong> <strong>是离散的; 而在回归问题中</strong> <strong>是连续的</strong></p><h2 id="分类-classification"><a href="#分类-classification" class="headerlink" title="分类 classification"></a>分类 classification</h2><p>有监督学习的两大应用之一，产生离散的结果</p><p><strong>分类问题最常用的学习算法包括 SVM (支持向量机) , SGD (随机梯度下降算法), Bayes (贝叶斯估计), Ensemble, KNN 等。</strong>而<strong>回归问题也能使用 SVR, SGD, Ensemble 等算</strong>法，以及其它线性回归算法。</p><p>例如向模型输入人的各种数据的训练样本，产生“输入一个人的数据，判断是否患有癌症”的结果，结果必定是离散的，只有“是”或“否”。（即有目标和标签，能判断目标特征是属于哪一个类型）</p><h2 id="回归-regression"><a href="#回归-regression" class="headerlink" title="回归 regression"></a>回归 regression</h2><p>有监督学习的两大应用之一，产生连续的结果。</p><p>例如向模型输入人的各种数据的训练样本，产生“输入一个人的数据，判断此人20年后今后的经济能力”的结果，结果是连续的，往往得到一条回归曲线。当输入自变量不同时，输出的因变量非离散分布（不仅仅是一条线性直线，多项曲线也是回归曲线）。<br>classification &amp; regression：分类与回归</p><h2 id="聚类-clustering"><a href="#聚类-clustering" class="headerlink" title="聚类 clustering"></a>聚类 clustering</h2><p>聚类也是分析样本的属性, 有点类似classification, 不同的就是classification 在预测之前是知道  的范围, 或者说知道到底有几个类别, 而聚类是不知道属性的范围的。所以 classification 也常常被称为 supervised learning, 而clustering就被称为unsupervised learning。<br>clustering 事先不知道样本的属性范围，只能凭借样本在特征空间的分布来分析样本的属性。这种问题一般更复杂。而常用的算法包括 k-means (K-均值), GMM (高斯混合模型) 等。</p><p>无监督学习的结果。聚类的结果将产生一组集合，集合中的对象与同集合中的对象彼此相似，与其他集合中的对象相异。</p><h2 id="降维-dimensionality-reduction"><a href="#降维-dimensionality-reduction" class="headerlink" title="降维 dimensionality reduction"></a>降维 dimensionality reduction</h2><p>降维是机器学习另一个重要的领域, 降维有很多重要的应用, **特征的维数过高, 会增加训练的负担与存储空间, 降维就是希望去除特征的冗余, 用更加少的维数来表示特征.**降维算法最基础的就是PCA了, 后面的很多算法都是以PCA为基础演化而来。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据挖掘-2&quot;&gt;&lt;a href=&quot;#数据挖掘-2&quot; class=&quot;headerlink&quot; title=&quot;数据挖掘 2&quot;&gt;&lt;/a&gt;数据挖掘 2&lt;/h1&gt;&lt;h2 id=&quot;四大块&quot;&gt;&lt;a href=&quot;#四大块&quot; class=&quot;headerlink&quot; title=&quot;四大块</summary>
      
    
    
    
    <category term="100_CodingSkills" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/"/>
    
    <category term="105_Python" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/105-Python/"/>
    
    <category term="数据挖掘" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/105-Python/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-105-Python-201904-Python%E9%97%AD%E5%8C%85/"/>
    <id>http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-105-Python-201904-Python%E9%97%AD%E5%8C%85/</id>
    <published>2024-08-15T09:50:31.524Z</published>
    <updated>2024-08-15T09:50:43.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于Python闭包（Closures）的那点事"><a href="#关于Python闭包（Closures）的那点事" class="headerlink" title="关于Python闭包（Closures）的那点事"></a>关于Python闭包（Closures）的那点事</h1><hr><h2 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h2><p>类比一下对象，对象是封装了方法的数据，闭包是封装了数据的方法。</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def outer(x):</span><br><span class="line">  # 1</span><br><span class="line">  def inner(y):</span><br><span class="line">    print(x)</span><br><span class="line">    return x+y</span><br><span class="line">  return inner  # 2</span><br><span class="line">g = outer(5)  # 3</span><br><span class="line">print(g.__closure__)  # 4</span><br><span class="line">print(g(6))   # 5</span><br></pre></td></tr></table></figure><p>请问上面的代码能够顺利执行吗？</p><p>上面的代码执行没有任何问题。<br>但我相信第一次接触闭包的同学肯定会对x的作用域有疑问，在这段代码中x是一个outer函数内部的<br>局部变量， 生命周期应该从入参到 # 1到 # 2才对， 所以当#3执行完后x已经被释放了， 当执行#5时<br>innner函数被触发，但此时应该访问不到x，应该会抛出一个x未定义的异常才对，但是这一些都没有发生，<br>inner函数依旧正常执行，打印了x。</p><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&lt;cell at 0x7efd66558108: int object at 0xa67b40&gt;,)</span><br><span class="line">5</span><br><span class="line">11</span><br></pre></td></tr></table></figure><h2 id="分析一下"><a href="#分析一下" class="headerlink" title="分析一下"></a>分析一下</h2><p><strong>Python支持一种特性叫做函数闭包（function closures）：在非全局（global）作用域中定义inner函数（即嵌套函数）时，会记录下它的嵌套函数namespaces（嵌套函数作用域的locals），可以称作：定义时状态，可以通过__closure__ 这个属性来获得inner函数的外层嵌套函数的namespaces。(如上例中#5，打印了func_closure ，里面保存了一个int对象，这个int对象就是x)</strong></p><p>在这个例子中，我们能看到闭包实际上是记录了外层嵌套函数作用域中的local变量</p><h2 id="闭包的应用场景"><a href="#闭包的应用场景" class="headerlink" title="闭包的应用场景"></a>闭包的应用场景</h2><ul><li>替换硬编码常量</li><li>终结全局</li><li>提供一致的功能签名</li><li>实现面向对象</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://ynniv.com/blog/2007/08/closures-in-python.html">http://ynniv.com/blog/2007/08/closures-in-python.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于Python闭包（Closures）的那点事&quot;&gt;&lt;a href=&quot;#关于Python闭包（Closures）的那点事&quot; class=&quot;headerlink&quot; title=&quot;关于Python闭包（Closures）的那点事&quot;&gt;&lt;/a&gt;关于Python闭包（Clo</summary>
      
    
    
    
    <category term="100_CodingSkills" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/"/>
    
    <category term="105_Python" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/105-Python/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-105-Python-201911-%E7%8E%A9%E8%BD%ACPython/"/>
    <id>http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-105-Python-201911-%E7%8E%A9%E8%BD%ACPython/</id>
    <published>2024-08-15T09:50:31.524Z</published>
    <updated>2024-08-15T09:50:43.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-基础篇"><a href="#Python-基础篇" class="headerlink" title="Python 基础篇"></a>Python 基础篇</h1><h1 id="Python-进阶"><a href="#Python-进阶" class="headerlink" title="Python 进阶"></a>Python 进阶</h1><h1 id="Python-Web"><a href="#Python-Web" class="headerlink" title="Python Web"></a>Python Web</h1><h1 id="Python-爬虫"><a href="#Python-爬虫" class="headerlink" title="Python 爬虫"></a>Python 爬虫</h1><h1 id="Python-数据分析"><a href="#Python-数据分析" class="headerlink" title="Python 数据分析"></a>Python 数据分析</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python-基础篇&quot;&gt;&lt;a href=&quot;#Python-基础篇&quot; class=&quot;headerlink&quot; title=&quot;Python 基础篇&quot;&gt;&lt;/a&gt;Python 基础篇&lt;/h1&gt;&lt;h1 id=&quot;Python-进阶&quot;&gt;&lt;a href=&quot;#Python-进阶&quot; c</summary>
      
    
    
    
    <category term="100_CodingSkills" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/"/>
    
    <category term="105_Python" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/105-Python/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-105-Python-201904-CentOS7-%E5%AE%89%E8%A3%85Python3/"/>
    <id>http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-105-Python-201904-CentOS7-%E5%AE%89%E8%A3%85Python3/</id>
    <published>2024-08-15T09:50:31.524Z</published>
    <updated>2024-08-15T09:50:43.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CentOS7-安装Python3"><a href="#CentOS7-安装Python3" class="headerlink" title="CentOS7 安装Python3"></a>CentOS7 安装Python3</h1><hr><p><strong>本文主要介绍在CentOS7上通过源码编译的方式案头Python3, 文中用到的是CentOS7.2, Python版本是3.6.7,其他类似版本的处理也是大致相同的.</strong></p><p>在安装Python3之前需要解决两个问题：</p><ul><li><strong>一是 开发环境安装，比如gcc等</strong></li><li><strong>二是 openssl的安装， 因为CentOS自带的openssl版本比较低，导致Python3安装完后，在python命令行中执行import ssl会报错：ImportError: No module named _ssl。</strong></li></ul><p>特别是第二个ssl错误，相信很多人都遇到过，我自己也在这个问题上纠缠了很长时间， 现在将亲测有效的解决方案分享给大家。</p><h2 id="1-安装开发环境依赖"><a href="#1-安装开发环境依赖" class="headerlink" title="1.安装开发环境依赖"></a>1.安装开发环境依赖</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y groupinstall development</span><br><span class="line">sudo yum -y install zlib-devel</span><br><span class="line">sudo yum -y install libffi-devel</span><br></pre></td></tr></table></figure><h2 id="2-更新openssl"><a href="#2-更新openssl" class="headerlink" title="2.更新openssl"></a>2.更新openssl</h2><p>先通过命令看看筷的openssl版本，如果返回是0.9.x， 那肯定需要升级了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl version</span><br></pre></td></tr></table></figure><p>按照如下方式升级openssl</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.openssl.org/source/openssl-1.0.2e.tar.gz</span><br><span class="line">tar xvzf openssl-1.0.2e.tar.gz</span><br><span class="line">cd openssl-1.0.2e</span><br><span class="line">./config --prefix=/usr/local/openssl --openssldir=/usr/local/openssl</span><br><span class="line">make</span><br><span class="line">make test</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>到这openssl安装完成了， 接下来可以开始编译安装Python3了， 注意我们指定的openssl安装路径是在&#x2F;usr&#x2F;local&#x2F;openssl， 这个后面要用到。</p><h2 id="3-安装Python3"><a href="#3-安装Python3" class="headerlink" title="3.安装Python3"></a>3.安装Python3</h2><ul><li><p>先下载解压Python3.6.7安装包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.python.org/ftp/python/3.6.7/Python-3.6.7.tgz</span><br><span class="line">tar xvzf Python-3.6.7.tgz</span><br><span class="line">cd Python-3.6.7</span><br></pre></td></tr></table></figure></li><li><p>然后修改Setup.dist, 指定ssl位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi Modules/Setup.dist</span><br></pre></td></tr></table></figure><p>搜索ssl, 取消以下几行注释， 并且修改SSL的值为我们实际安装openssl的值， 即：&#x2F;usr&#x2F;local&#x2F;openssl</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_socket socketmodule.c</span><br><span class="line"></span><br><span class="line"># Socket module helper for SSL support; you must comment out the other</span><br><span class="line"># socket line above, and possibly edit the SSL variable:</span><br><span class="line">SSL=/usr/local/openssl</span><br><span class="line">_ssl _ssl.c \</span><br><span class="line"> -DUSE_SSL -I$(SSL)/include -I$(SSL)/include/openssl \</span><br><span class="line"> -L$(SSL)/lib -lssl -lcrypto</span><br></pre></td></tr></table></figure><p><em>注： 网上很多说在.&#x2F;configure 后面加–with-openssl的方法来指定openssl的方法自测无效， 通过修改Setup.dist方才生效。</em></p></li><li><p>完成以上修改后，即可开始编译Python3, 命令如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-验证Python3"><a href="#4-验证Python3" class="headerlink" title="4.验证Python3"></a>4.验证Python3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3</span><br><span class="line">import ssl</span><br></pre></td></tr></table></figure><p>正常不会报错， 则Python3安装成功。<br>另外，给大家推荐一个Python虚拟环境的包pipenv, 强大又好用， 大家可以试试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install pipenv</span><br></pre></td></tr></table></figure><p>至此，CentOS7上安装Python3完毕。<br>这个是我参考的文章，感谢前人的分享！<a href="https://techglimpse.com/install-python-openssl-support-tutorial/#check-python-for-openssl-support">How to Compile and Install Python with OpenSSL Support?</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CentOS7-安装Python3&quot;&gt;&lt;a href=&quot;#CentOS7-安装Python3&quot; class=&quot;headerlink&quot; title=&quot;CentOS7 安装Python3&quot;&gt;&lt;/a&gt;CentOS7 安装Python3&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;&lt;stro</summary>
      
    
    
    
    <category term="100_CodingSkills" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/"/>
    
    <category term="105_Python" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/105-Python/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-105-Python-%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98-20210905-%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%981/"/>
    <id>http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-105-Python-%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98-20210905-%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%981/</id>
    <published>2024-08-15T09:50:31.524Z</published>
    <updated>2024-08-16T02:32:36.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据挖掘-1"><a href="#数据挖掘-1" class="headerlink" title="数据挖掘 1"></a>数据挖掘 1</h1><h2 id="1-岗位信息"><a href="#1-岗位信息" class="headerlink" title="1 岗位信息"></a>1 岗位信息</h2><p><a href="http://bole.oa.com/BoLe/PostAdmin/PostDetail?postId=82793">http://bole.oa.com/BoLe/PostAdmin/PostDetail?postId=82793</a> </p><p><a href="http://bole.oa.com/BoLe/PostAdmin/PostDetail?postId=80555">http://bole.oa.com/BoLe/PostAdmin/PostDetail?postId=80555</a></p><p>1、计算机、机器学习、统计等相关专业，本科及以上学历，3年以上相关工作经验。<br>2、有较强的算法基础和编码能力，熟练掌握Python、SQL、Java、Scala等至少一门语言。<br>3、熟练掌握常见的特征处理方法和机器学习算法，熟练使用各类常见的机器学习算法库，例如sklearn、tensorflow、pytorch、spark mllib等。<br>4、熟悉金融领域（银行、券商、保险等）的常见业务流程与业务问题，有相关建模经验者优先。 5、善于沟通，工作积极主动，责任心强，具备良好的团队协作能力。 通过腾讯云从业资格证或同等资格认证的优先录取<br>1、针对客户实际业务问题，负责大规模数据场景下的数据分析和建模工作。<br>2、针对各类常见的具体业务问题，负责相关案例和应用在产品侧的沉淀与积累。 </p><h3 id="岗位要求"><a href="#岗位要求" class="headerlink" title="岗位要求"></a>岗位要求</h3><p>1、计算机或者相关专业本科以上学历，硕士三年，本科五年以上工作经验；</p><p>2、具有扎实的数据结构和算法功底，能熟练应用各类机器学习模型（逻辑回归、聚类、树模型、图网络等）； </p><p>3、对数据分析和数据挖掘有深入理解，有相关项目经验； </p><p>4、能够运用hadoop、spark等大数据计算平台进行数据分析挖掘，熟练掌握python、hivesql、sparkscala，有相关项目经验；</p><p> 5、有较强学习能力和逻辑思维能力，具备良好的问题分析与解决能力；</p><p> 6、善于沟通，工作积极主动，责任心强，具备良好的团队协作能力；</p><p>7、有toB+toC业务数据分析经验者优先。 通过腾讯云从业资格证或同等资格认证的优先录取。 备注：此岗位为腾讯集团旗下全资子公司编制岗位  </p><h3 id="岗位职责"><a href="#岗位职责" class="headerlink" title="岗位职责"></a>岗位职责</h3><p>1、负责腾讯会议的数据仓库、数据建模、数据分析、数据可视化开发工作； </p><p>2、负责优化现有业务数据分析工具，通过科学方法持续优化数据分析效能； </p><p>3、负责提升产品&amp;运营团队基于数据驱动决策的效率和准确性，针对各行业数据的指标进行体系化梳理和建设； </p><p>4、负责腾讯会议数据治理，通过数据入库、校验、清洗，保证数据质量； </p><p>5、负责腾讯会议的数据标签挖掘、运营模型搭建工作； </p><p>6、持续产出行业洞察，跟踪分析竞争对手、行业趋势等，形成商业分析并洞察其中的商业机会。</p><h2 id="2-技术能力点整理"><a href="#2-技术能力点整理" class="headerlink" title="2 技术能力点整理"></a>2 技术能力点整理</h2><ul><li>数据仓库， 数据建模，数据分析，数据可视化， 数据标签挖掘， 运营模型搭建，行业趋势，商业机会</li><li>大数据：spark, hadoop, Sql, hivesql, python, sparkscala, </li><li>统计学：AB test</li><li>机器学习：逻辑回归、聚类、树模型、图网络， 决策树， 随机森林， xgboost</li><li>数据预处理：缺失、重复、冲突， 清洗</li><li>数据入库</li><li>数据挖掘：tensoflow, keras, pytorch, </li><li>模型搭建</li><li>可视化：tableau, power_bi</li><li>网页抓取</li><li>数仓工具Hive、MR、Flink、Mysql</li><li>数仓建模理论，数仓分层、星形模型、雪花模型等，有大规模业务数仓实践经验优</li><li>握数据etl过程，熟悉spark&#x2F;hadoop&#x2F;Hbase&#x2F;es等大数据处理框架；</li><li>探索和抽象通用的数据分析方法，如流失预测，归因分析，路径分析，用户分群</li><li>从事过机器学习平台研发或参加kaggle等比赛获得优异成绩者优先</li></ul><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul><li>做版本规划的时候，如何设立指标来进行功能验证？</li><li>功能上线后，如何做数据复盘？</li><li>如何通过数据来快速定位问题？</li><li>在众多的数据中如何识别哪些是需要呈现的重要数据</li><li>通过数据仅能让你找到局部最大值，而更高的山峰只会建立在你更广阔的视野与深厚的认知上。</li></ul><h2 id="3-技术学习"><a href="#3-技术学习" class="headerlink" title="3 技术学习"></a>3 技术学习</h2><h3 id="3-1数据分析流程梳理"><a href="#3-1数据分析流程梳理" class="headerlink" title="3.1数据分析流程梳理"></a>3.1数据分析流程梳理</h3><p>数据分析：用适当的统计方法对收集来的数据进行分析，以求最大化的开发数据资料的功能， 发挥数据的作用， 是为了提取有用的信息和形成结论而对数据加以详细研究和概括总结的过程。<br>数据挖掘：从海量的数据库中选择、探索、识别出有效的、新颖的、具有潜在效用的乃至最终可理解的模式以获取商业利益的非平凡的过程</p><h4 id="定义挖掘目标：问题和想达到的效果，-明确分析的目的和思路"><a href="#定义挖掘目标：问题和想达到的效果，-明确分析的目的和思路" class="headerlink" title="定义挖掘目标：问题和想达到的效果， 明确分析的目的和思路"></a>定义挖掘目标：问题和想达到的效果， 明确分析的目的和思路</h4><ul><li>为什么展开数据分析，遇到什么问题，有没有其他更好的办法</li><li>方法：逻辑树分析法， 5w2h, 4p营销理论， PEST分析法</li><li>想多一点点</li></ul><p>####数据取样：相关性， 可靠性，有效性</p><ul><li>来自：数据库，问卷，互联网，公开出版物</li></ul><p>####数据探索：异常值分析， 缺失值分析， 相关性分析，周期分析</p><p>####数据预处理：筛选， 变量转换， 缺失值处理，坏数据处理，数据标准化， 主成分分析，属性选择， 数据规约</p><ul><li>数据清洗–》数据加工</li><li>从业务角度检查数据：不完整性， 噪音数据， 类型冲突， 单位冲突</li><li>从技术角度检查数据：统计描述， 箱体图，直方图， 散点图——》 数据预分析过程</li><li>数据分析方法： 对比分析， 交叉分析， 漏斗图分析， 矩阵关联分析，综合评价分析，杜邦分析<ul><li>对比分析：将两个或两个以上的数据进行比较， 分析他们的差异， 从而揭示这些数据所代表的事务发展变化情况和规律性。 特地昂是非常直观的看出事务某方面的变化和差距， 并且可以准确、量化的表示出这种变化或者差距是多少。 例如列出国内各省的人均消费金额，对比差异</li><li>交叉分析：通常用于分析两个变量之间的关系，即同时将两个有一定联系的变量及其值交叉排列在一张表格内，是各个变量值成为不同变量的交叉节点， 形成交叉表， 从而分析交叉表中变量之间的关系。比如每月星巴克卖出的咖啡中白咖啡和黑咖啡的占比</li><li>漏斗分析：漏斗图是一个适合业务流程比较规范、周期比较长、各流程环节涉及复杂业务过程比较多的管理分析工具。是对业务流程最直观的一种表现形式， 可以快速发现业务流程中存在问题的环节。比如浏览商品-》放入购物车-》生成订单-》支付订单-》完成交易，每一步的转换率怎样</li><li>矩阵关联分析：是指根据事务的两个重要属性作为横纵轴， 组成一个坐标系， 在两坐标轴上分辨按某一标准进行刻度划分，构成四个象限， 将要分析的每个事务对应投身至这四个象限内， 直观的将两个属性的关联性表现出来， 进而分析每一个事务在这两个属性上的表现， 为决策者提供重要的参考依据。</li></ul></li></ul><p>####挖掘建模：根据哪类问题（分类，聚类，关联规则， 时序模式， 智能推荐），选择合适的算法</p><ul><li>常用的数据挖掘的方法：回归分析，关联分析，决策树，聚类分析， 因子分析，神经网络<ul><li>回归分析：线性回归， 非线性回归， logistic回归</li><li>关联分析：推荐系统常用</li><li>决策树：决策树中最顶部的结点称为根结点， 是整个决策树的开始。 每个决策结点代表一个问题或者决策，结点连线代表某个属性满足的条件， 每个叶结点代表一种分类结果。</li><li>聚类分析：根据研究对象多个变量取值情况利用分类算法将研究对象划分到相对同质的多个群组， 使得群组内对象之间具有较高相似度，不通群组间对象之间差异较大——层次聚类法， k-means均值聚类法：随机选择k个对象，每个对象初试的代表一个类的平均值或者中心， 对剩余每个对象，根据其到各类中心的欧式距离，被划分到最近的类；然后重新计算每个类的中心值。不断重复这个过程，直到所有的样本都不能再分到任何一类为止。</li></ul></li></ul><p>####模型评价：对比</p><p>####模型发布</p><h4 id="数据展示"><a href="#数据展示" class="headerlink" title="数据展示"></a>数据展示</h4><ul><li>a picture is worth a thousand words;</li><li>表格、图表（成分图、排序（直方图），频率分布（直方图、折线图）， 相关性（矩阵、散点）， 多位图（多重数据比较））、词云图、 地域分布图、艺术图</li><li>Excel, spss, sas, matlab, stata,  T</li></ul><h4 id="撰写报告"><a href="#撰写报告" class="headerlink" title="撰写报告"></a>撰写报告</h4><ul><li>分析的目的和背景：目的，数据来源</li><li>主要分析结果：1，2， x</li><li>总结与建议：</li><li>详细分析：1XXXX，图表，结果， 2xxxx, 图表，结果</li><li>附录：参考数据，模型说明等</li></ul><h4 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h4><ul><li>分析的关键在于从起伏跌宕中发现规律和信息</li><li>宁缺毋滥，切记过度推理</li></ul><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><ul><li>Hadoop, sqlserver, mysql, TDW(腾讯大数据平台)</li><li><a href="http://www.199it.com/">http://www.199it.com/</a> 中文互联网数据咨询</li></ul><h3 id="3-2-常见的数据分析、挖掘模型"><a href="#3-2-常见的数据分析、挖掘模型" class="headerlink" title="3.2 常见的数据分析、挖掘模型"></a>3.2 常见的数据分析、挖掘模型</h3><p>分类模型：解决的是事务自动学习，然后进行类别判定的问题</p><p>聚类模型：解决的是将数据对象自动组成对象划定为不同类族</p><p>预测模型：解决根据已有实测规律，预测下一周期数据的问题</p><p>关联模型：解决大规模数据集中，寻找有关联关系的数据的问题</p><p>推荐模型：解决基于现有数据进行有效推荐</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gu5s2bkoh3j60u00vc79o02.jpg" alt="image-20210905152118574"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gu5s25ck0qj60u00w978t02.jpg" alt="image-20210905152046493"></p><h3 id="3-3-机器学习"><a href="#3-3-机器学习" class="headerlink" title="3.3 机器学习"></a>3.3 机器学习</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gu5ryxbfsuj616q0gcabo02.jpg" alt="image-20210905151807121"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gu5s039ve8j615q0l8whp02.jpg" alt="image-20210905151911506"></p><h4 id="有监督学习"><a href="#有监督学习" class="headerlink" title="有监督学习"></a>有监督学习</h4><p>K-近邻算法</p><p>决策树</p><p>逻辑回归</p><p>svm</p><p>朴素贝叶斯</p><h4 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h4><p>K-means, </p><p>PCA</p><p>FP-growth</p><p>关联规则</p><p>PageRank</p><h4 id="分类模型常用算法"><a href="#分类模型常用算法" class="headerlink" title="分类模型常用算法"></a>分类模型常用算法</h4><p>朴素贝叶斯</p><p>svm</p><p>k-近邻</p><p>逻辑回归</p><p>决策树</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gu5sayuwk5j60u30u0wj702.jpg" alt="image-20210905152920275"></p><h4 id="聚类模型常用算法"><a href="#聚类模型常用算法" class="headerlink" title="聚类模型常用算法"></a>聚类模型常用算法</h4><p>对大量未标注的数据集进行特征处理–》按照数据内在相似性将数据集划分为多个类别–》使类别内的数据相似度较大，而类别间的数据相似度较小</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gu5sfrzjz6j612u0lgn0r02.jpg" alt="image-20210905153257764"></p><h3 id="3-4-spark"><a href="#3-4-spark" class="headerlink" title="3.4 spark"></a>3.4 spark</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gu5he7me2kj60qe0eawfh02.jpg" alt="image-20210905091213160"></p><p><img src="http://ntsapps.oa.com/note/api/web/attachment!getImageByUrl?url=a1df78b3-499e-4a11-9596-2856f317e4d6.png" alt="img"></p><p><strong>4.分析方法</strong><br>1）拆解<br>①树形拆解<br>适合构成类数据分析，每一个数据由多个子项构成<br>下一层是上一层的支撑和论据</p><p>②线性拆解<br>适合流程分析，挖掘用户操作流程中的问题点<br>关注相邻项间的转化和用户流失情况<br>优化方向：去掉过程步骤等</p><h3 id="3-3数据分析技术点梳理"><a href="#3-3数据分析技术点梳理" class="headerlink" title="3.3数据分析技术点梳理"></a>3.3数据分析技术点梳理</h3><h4 id="数据清洗和特征处理"><a href="#数据清洗和特征处理" class="headerlink" title="数据清洗和特征处理"></a>数据清洗和特征处理</h4><p><a href="https://tech.meituan.com/2015/02/10/machinelearning-data-feature-process.html">https://tech.meituan.com/2015/02/10/machinelearning-data-feature-process.html</a></p><p><a href="https://www.cnblogs.com/jasonfreak/p/5448385.html">https://www.cnblogs.com/jasonfreak/p/5448385.html</a></p><p>其本质是一项工程活动，目的是最大限度地从原始数据中提取特征以供算法和模型使用</p><p>数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已</p><p>数据清洗&#x3D;&gt;特征</p><p>标注数据生成&#x3D;&gt;模型学习&#x3D;&gt;模型应用</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu71kd0dz7j61cu0oa40e02.jpg" alt="image-20210906173529837"></p><p>蓝色–离线</p><p>绿色-在线</p><p>主要的区别在于1.不需要清洗标注数据，只需要处理得到特征数据，在线模型使用特征数据预测出样本可能的标签。2.最终生成数据的用处，最终生成的数据主要用于模型的预测，而不是训练。 在离线的处理部分，可以进行较多的实验和迭代，尝试不同的样本采样、样本权重、特征处理方法、特征组合方法等，最终得到一个最优的方法，在离线评估得到好的结果后，最终将确定的方案在线上使用。 另外，由于在线和离线环境不同，存储数据、获取数据的方法存在较大的差异。例如离线数据获取可以将数据存储在Hadoop，批量地进行分析处理等操作，并且容忍一定的失败。而在线服务获取数据需要稳定、延时小等，可以将数据建入索引、存入KV存储系统等。</p><p>离线我们用常用的衡量排序结果的AUC指标，在线的我们通过ABTest来测试算法对下单率、用户转化率等指标的影响。</p><ul><li><p>模型评价: 离线AUC, 在线ABTest</p><ul><li>AUC:AUC值为ROC曲线下的面积，是一个概率值，越大越好。简单来说这个指标的含义其实就是随机抽出一对样本（一个正样本，一个负样本），然后用训练得到的分类器来对这两个样本进行预测，预测得到正样本的概率大于负样本概率的概率。AUC是一个二分类模型的评价指标，还有很多其他指标比如logloss，accuracy，precision。在数据挖掘比赛中，AUC和logloss比accuracy更常用。因为很多机器学习的模型对分类问题的预测结果都是概率，如果要计算accuracy，需要先把概率转化成类别，这就需要手动设置一个阈值，如果对一个样本的预测概率高于阈值，那该样本就被预测为正样本，低于这个阈值，则为负样本。所以这个阈值很大程度上影响了accuracy的计算。然而，使用AUC和logloss可以避免把预测概率转换成类别。</li><li>Logloss: logloss越小越好，物理意义为：衡量预估ctr与实际ctr的拟合程度。</li></ul></li><li><p>数据获取：准确性， 难度、数据量大小</p><ul><li>数据采样：随机采样，固定比例采样<ul><li>1.结合业务情况进行数据的过滤，例如去除crawler抓取，spam，作弊等数据。 </li><li>2.异常点检测，采用异常点检测算法对样本进行分析，常用的异常点检测算法包括 - 偏差检测，例如聚类，最近邻等。 - 基于统计的异常点检测算法 例如极差，四分位数间距，均差，标准差等，这种方法适合于挖掘单变量的数值型数据。全距(Range)，又称极差，是用来表示统计资料中的变异量数(measures of variation) ，其最大值与最小值之间的差距；四分位距通常是用来构建箱形图，以及对概率分布的简要图表概述。 - 基于距离的异常点检测算法，主要通过距离方法来检测异常点，将数据集中与大多数点之间距离大于某个阈值的点视为异常点，主要使用的距离度量方法有绝对距离 ( 曼哈顿距离 ) 、欧氏距离和马氏距离等方法。 - 基于密度的异常点检测算法，考察当前点周围密度，可以发现局部异常点，例如LOF算法</li></ul></li></ul></li><li><p>特征分类</p><ul><li>离线特征获取方案 离线可以使用海量的数据，借助于分布式文件存储平台，例如HDFS等，使用例如MapReduce，Spark等处理工具来处理海量的数据等</li><li>在线特征获取方案 在线特征比较注重获取数据的延时，由于是在线服务，需要在非常短的时间内获取到相应的数据，对查找性能要求非常高，可以将数据存储在索引、kv存储等。而查找性能与数据的数据量会有矛盾，需要折衷处理，我们使用了<strong>特征分层获取方案</strong></li><li>特征数据只有在和标注数据合并之后，才能用来做为模型的训练</li><li>可以将特征分为(1)Low level特征和High level特征。(2)稳定特征与动态特征。(3)二值特征、连续特征、枚举特征。<ul><li>Low level特征是较低级别的特征，主要是原始特征，不需要或者需要非常少的人工处理和干预，例如文本特征中的词向量特征，图像特征中的像素点，用户id，商品id等。Low level特征一般维度比较高，不能用过于复杂的模型。High level特征是经过较复杂的处理，结合部分业务逻辑或者规则、模型得到的特征，例如人工打分，模型打分等特征，可以用于较复杂的非线性模型。Low level 比较针对性，覆盖面小。长尾样本的预测值主要受high level特征影响。 高频样本的预测值主要受low level特征影响。</li><li>稳定特征是变化频率(更新频率)较少的特征，例如评价平均分，团购单价格等，在较长的时间段内都不会发生变化。动态特征是更新变化比较频繁的特征，有些甚至是实时计算得到的特征，例如距离特征，2小时销量等特征。或者叫做实时特征和非实时特征。针对两类特征的不同可以针对性地设计特征存储和更新方式，例如对于稳定特征，可以建入索引，较长时间更新一次，如果做缓存的话，缓存的时间可以较长。对于动态特征，需要实时计算或者准实时地更新数据，如果做缓存的话，缓存过期时间需要设置的较短。</li><li>二值特征主要是0&#x2F;1特征，即特征只取两种值：0或者1，例如用户id特征：目前的id是否是某个特定的id，词向量特征：某个特定的词是否在文章中出现等等。连续值特征是取值为有理数的特征，特征取值个数不定，例如距离特征，特征取值为是0~正无穷。枚举值特征主要是特征有固定个数个可能值，例如今天周几，只有7个可能值：周1，周2，…，周日。在实际的使用中，我们可能对不同类型的特征进行转换，例如将枚举特征或者连续特征处理为二值特征。枚举特征处理为二值特征技巧：将枚举特征映射为多个特征，每个特征对应一个特定枚举值，例如今天周几，可以把它转换成7个二元特征：今天是否是周一，今天是否是周二，…，今天是否是周日。连续值处理为二值特征方法：先将连续值离散化（后面会介绍如何离散化)，再将离散化后的特征切分为N个二元特征，每个特征代表是否在这个区间内。</li></ul></li></ul></li><li><p>特征选择</p><p>特征选择的目标是寻找最优特征子集。特征选择能剔除不相关(irrelevant)或冗余(redundant )的特征，从而达到减少特征个数，提高模型精确度，减少运行时间的目的。另一方面，选取出真正相关的特征简化模型，协助理解数据产生的过程。 特征选择的一般过程如下图所示：主要分为产生过程，评估过程，停止条件和验证过程</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu75c9l5jij60m8090t8v02.jpg" alt="image-20210906194618468"></p><ul><li><p>特征抽取和归一化之后，如果发现特征太多，导致模型无法训练，或很容易导致模型过拟合，则需要对特征进行选择，挑选有价值的特征。</p><ul><li>Filter：</li></ul><p>假设特征子集对模型预估的影响互相独立，选择一个特征子集，分析该子集和数据Label的关系，如果存在某种正相关，则认为该特征子集有效。衡量特征子集和数据Label关系的算法有很多，如Chi-square，Information Gain。</p><ul><li>Wrapper：</li></ul><p>选择一个特征子集加入原有特征集合，用模型进行训练，比较子集加入前后的效果，如果效果变好，则认为该特征子集有效，否则认为无效。</p><ul><li>Embedded：</li></ul><p>将特征选择和模型训练结合起来，如在损失函数中加入L1 Norm ，L2 Norm。</p></li><li><p>完全搜索(Complete)</p><ul><li>广度优先搜索( Breadth First Search ) 广度优先遍历特征子空间。枚举所有组合，穷举搜索，实用性不高。</li><li>分支限界搜索( Branch and Bound ) 穷举基础上加入分支限界。例如：剪掉某些不可能搜索出比当前最优解更优的分支。 其他，如定向搜索 (Beam Search )，最优优先搜索 ( Best First Search )等</li></ul></li><li><p>启发式搜索(Heuristic)</p><ul><li>序列前向选择( SFS ， Sequential Forward Selection ) 从空集开始，每次加入一个选最优。</li><li>序列后向选择( SBS ， Sequential Backward Selection ) 从全集开始，每次减少一个选最优。</li><li>增L去R选择算法 ( LRS ， Plus-L Minus-R Selection ) 从空集开始，每次加入L个，减去R个，选最优（L&gt;R)或者从全集开始，每次减去R个，增加L个，选最优(L&lt;R)。</li></ul><p>其他如双向搜索( BDS ， Bidirectional Search )，序列浮动选择( Sequential Floating Selection )等</p></li><li><p>随机搜索(Random)</p><ul><li>随机产生序列选择算法(RGSS， Random Generation plus Sequential Selection) 随机产生一个特征子集，然后在该子集上执行SFS与SBS算法。</li><li>模拟退火算法( SA， Simulated Annealing ) 以一定的概率来接受一个比当前解要差的解，而且这个概率随着时间推移逐渐降低</li><li>遗传算法( GA， Genetic Algorithms ) 通过交叉、突变等操作繁殖出下一代特征子集，并且评分越高的特征子集被选中参加繁殖的概率越高。</li></ul></li></ul><p>随机算法共同缺点:依赖随机因素，有实验结果难重现。</p><ul><li><p>特征选择—相关性</p><ul><li><p>对特征的有效性进行分析，得到各个特征的特征权重，根据是否与模型有关可以分为1.与模型相关特征权重，使用所有的特征数据训练出来模型，看在模型中各个特征的权重，由于需要训练出模型，模型相关的权重与此次学习所用的模型比较相关。不同的模型有不同的模型权重衡量方法。例如线性模型中，特征的权重系数等。2.与模型无关特征权重。主要分析特征与label的相关性，这样的分析是与这次学习所使用的模型无关的。与模型无关特征权重分析方法包括(1)交叉熵，(2)Information Gain，(3)Odds ratio，(4)互信息，(5)KL散度等</p></li><li><p>于重要的特征进行监控与有效性分析，了解模型所用的特征是否存在问题，当某个特别重要的特征出问题时，需要做好备案，防止灾难性结果</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu87fcjo1qj60cz05ljre02.jpg" alt="image-20210907174359312"></p></li></ul></li><li><p>特征选择–距离</p><ul><li>运用距离度量进行特征选择是基于这样的假设：好的特征子集应该使得属于同一类的样本距离尽可能小，属于不同类的样本之间的距离尽可能远。常用的距离度量（相似性度量）包括欧氏距离、标准化欧氏距离、马氏距离等。</li></ul></li><li><p>特征选择–一致性</p><ul><li>若样本1与样本2属于不同的分类，但在特征A、 B上的取值完全一样，那么特征子集{A，B}不应该选作最终的特征集</li></ul></li></ul></li><li><p>特征处理</p><ul><li><p>无量纲化</p><ul><li><p>标准化：标准化需要计算特征的均值和标准差，公式表达为， 代码from sklearn.preprocessing import StandardScaler</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu7xd85n2zj60c204ggle02.jpg" alt="image-20210907115558235"></p></li><li><p>区间缩放法：区间缩放法的思路有多种，常见的一种为利用两个最值进行缩放，公式表达为,代码from sklearn.preprocessing import MinMaxScaler</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu7xehjni2j60ls06s74502.jpg" alt="image-20210907115709789"></p></li><li><p>特征归一化： Normalizer</p><ul><li>主要用于单个特征的处理。 - 归一化 不同的特征有不同的取值范围，在有些算法中，例如线性模型或者距离相关的模型像聚类模型、knn模型等，特征的取值范围会对最终的结果产生较大影响，例如二元特征的取值范围为[0，1]，而距离特征取值可能是[0，正无穷)，在实际使用中会对距离进行截断，例如[0，3000000]，但是这两个特征由于取值范围不一致导致了模型可能会更偏向于取值范围较大的特征，为了平衡取值范围不一致的特征，需要对特征进行归一化处理，将特征取值归一化到［0，1］区间。常用的归一化方法包括1.函数归一化，通过映射函数将特征取值映射到［0，1］区间，例如最大最小值归一化方法，是一种线性的映射。还有通过非线性函数的映射，例如log函数等。</li><li>2.分维度归一化，可以使用最大最小归一化方法，但是最大最小值选取的是所属类别的最大最小值，即使用的是局部最大最小值，不是全局的最大最小值。</li><li>3.排序归一化，不管原来的特征取值是什么样的，将特征按大小排序，根据特征所对应的序给予一个新的值。</li></ul></li><li><p>标准化和归一化的区别：简单来说，标准化是依照特征矩阵的列处理数据，其通过求z-score（标准分数）的方法，将样本的特征值转换到同一量纲下。归一化是依照特征矩阵的行处理数据，其目的在于样本向量在点乘运算或其他核函数计算相似性时，拥有统一的标准，也就是说都转化为“单位向量”。规则为l2的归一化公式如下：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu7xm5diasj60am05kjr702.jpg" alt="image-20210907120434906"></p></li></ul></li><li><p>对定量特征二值化：定量特征二值化的核心在于设定一个阈值，大于阈值的赋值为1，小于等于阈值的赋值为0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Binarizer</span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> <span class="comment">#二值化，阈值设置为3，返回值为二值化后的数据</span></span><br><span class="line"><span class="number">4</span> Binarizer(threshold=<span class="number">3</span>).fit_transform(iris.data)</span><br></pre></td></tr></table></figure></li><li><p>对定性特征亚编码</p><ul><li><p>one-hot独热编码介绍 <a href="https://blog.csdn.net/qq_41853758/article/details/81252174">https://blog.csdn.net/qq_41853758/article/details/81252174</a></p><p> 独热码，在英文文献中称做 one-hot code, 又称独热编码、一位有效编码,直观来说就是有多少个状态就有多少比特，而且只有一个比特为1，其他全为0的一种码制。其方法是使用N位状态寄存器来对N个状态进行编码，每个状态都有它独立的寄存器位，并且在任意时候，其中只有一位有效。</p><pre><code>自然状态码为：000,001,010,011,100,101独热编码为：000001,000010,000100,001000,010000,100000</code></pre></li></ul></li><li><p>离散化–等值划分，等量划分</p><ul><li><p>离散化 在上面介绍过连续值的取值空间可能是无穷的，为了便于表示和在模型中处理，需要对连续值特征进行离散化处理。常用的离散化方法包括等值划分和等量划分。等值划分是将特征按照值域进行均分，每一段内的取值等同处理。例如某个特征的取值范围为[0，10]，我们可以将其划分为10段，[0，1)，[1，2)，…，[9，10)。等量划分是根据样本总数进行均分，每段等量个样本划分为1段。例如距离特征，取值范围［0，3000000］，现在需要切分成10段，如果按照等比例划分的话，会发现绝大部分样本都在第1段中。使用等量划分就会避免这种问题，最终可能的切分是[0，100)，[100，300)，[300，500)，..，[10000，3000000]，前面的区间划分比较密，后面的比较稀疏。正如上文所言，独热编码（哑变量 dummy variable）是因为大部分算法是基于向量空间中的度量来进行计算的，为了使非偏序关系的变量取值不具有偏序性，并且到圆点是等距的。使用one-hot编码，将离散特征的取值扩展到了欧式空间，离散特征的某个取值就对应欧式空间的某个点。将离散型特征使用one-hot编码，会让特征之间的距离计算更加合理。离散特征进行one-hot编码后，编码后的特征，其实每一维度的特征都可以看做是连续的特征。就可以跟对连续型特征的归一化方法一样，对每一维特征进行归一化。比如归一化到[-1,1]或归一化到均值为0,方差为1。       </p><pre><code>为什么特征向量要映射到欧式空间？将离散特征通过one-hot编码映射到欧式空间，是因为，在回归，分类，聚类等机器学习算法中，特征之间距离的计算或相似度的计算是非常重要的，而我们常用的距离或相似度的计算都是在欧式空间的相似度计算，计算余弦相似性，基于的就是欧式空间。</code></pre></li></ul></li><li><p>缺省值处理 from sklearn.preprocessing import Imputer</p><ul><li>有些特征可能因为无法采样或者没有观测值而缺失，例如距离特征，用户可能禁止获取地理位置或者获取地理位置失败，此时需要对这些特征做特殊的处理，赋予一个缺省值。缺省值如何赋予，也有很多种方法。例如单独表示，众数，平均值等</li></ul></li><li><p>数据变换：常见的数据变换有基于多项式的、基于指数函数的、基于对数函数的</p></li><li><p>特征降维</p><ul><li><p>在介绍特征降维之前，先介绍下特征升维。在机器学习中，有一个VC维理论。根据VC维理论，VC维越高，打散能力越强，可容许的模型复杂度越高。在低维不可分的数据，映射到高维是可分。可以想想，给你一堆物品，人脑是如何对这些物品进行分类，依然是找出这些物品的一些特征，例如：颜色，形状，大小，触感等等，然后根据这些特征对物品做以归类，这其实就是一个先升维，后划分的过程。比如我们人脑识别香蕉。可能首先我们发现香蕉是黄色的。这是在颜色这个维度的一个切分。但是很多东西都是黄色的啊，例如哈密瓜。那么怎么区分香蕉和哈密瓜呢？我们发现香蕉形状是弯曲的。而哈密瓜是圆形的，那么我们就可以用形状来把香蕉和哈密瓜划分开了，即引入一个新维度：形状，来区分。这就是一个从“颜色”一维特征升维到二维特征的例子。</p></li><li><p>那问题来了，既然升维后模型能力能变强，那么是不是特征维度越高越好呢？为什么要进行特征降维&amp;特征选择？主要是出于如下考虑：1. 特征维数越高，模型越容易过拟合，此时更复杂的模型就不好用。2. 相互独立的特征维数越高，在模型不变的情况下，在测试集上达到相同的效果表现所需要的训练样本的数目就越大。 3. 特征数量增加带来的训练、测试以及存储的开销都会增大。4.在某些模型中，例如基于距离计算的模型KMeans，KNN等模型，在进行距离计算时，维度过高会影响精度和性能。5.可视化分析的需要。在低维的情况下，例如二维，三维，我们可以把数据绘制出来，可视化地看到数据。当维度增高时，就难以绘制出来了。在机器学习中，有一个非常经典的维度灾难的概念。用来描述当空间维度增加时，分析和组织高维空间，因体积指数增加而遇到各种问题场景。例如，100个平均分布的点能把一个单位区间以每个点距离不超过0.01采样；而当维度增加到10后，如果以相邻点距离不超过0.01小方格采样单位超一单位超正方体，则需要10^20 个采样点。</p></li><li><p>正是由于高维特征有如上描述的各种各样的问题，所以我们需要进行特征降维和特征选择等工作。特征降维常用的算法有PCA，LDA等。特征降维的目标是将高维空间中的数据集映射到低维空间数据，同时尽可能少地丢失信息，或者降维后的数据点尽可能地容易被区分 .是对数据在高维空间下的一个投影转换，通过一定的投影规则将原来从一个角度看到的多个维度映射成较少的维度</p><ul><li><p>PCA算法 (主成分分析)通过协方差矩阵的特征值分解能够得到数据的主成分，以二维特征为例，两个特征之间可能存在线性关系（例如运动的时速和秒速度），这样就造成了第二维信息是冗余的。PCA的目标是发现这种特征之间的线性关系，并去除。</p><p>出发思想不同。PCA主要是从特征的协方差角度，去找到比较好的投影方式，即选择样本点投影具有最大方差的方向.在信号处理中认为信号具有较大的方差，噪声有较小的方差，信噪比就是信号与噪声的方差比，越大越好</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu765xm3u3j61aw0u0wic02.jpg" alt="image-20210906201409411"></p></li><li><p>LDA算法(线性判别分析) 考虑label，降维后的数据点尽可能地容易被区分. LDA则更多的是考虑了分类标签信息，寻求投影后不同类别之间数据点距离更大化以及同一类别数据点距离最小化，即选择分类性能最好的方向.  LDA的思想可以用一句话概括，就是“投影后类内方差最小，类间方差最大”</p></li><li><p>降维后可用维度数量不同。LDA降维后最多可生成C-1维子空间（分类标签数-1），因此LDA与原始维度N数量无关，只有数据标签分类数量有关；而PCA最多有n维度可用，即最大可以选择全部可用维度。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu76732bgwj61dg0j075d02.jpg" alt="image-20210906201553629"></p></li></ul></li></ul><p>  上图左侧是PCA的降维思想，它所作的只是将整组数据整体映射到最方便表示这组数据的坐标轴上，映射时没有利用任何数据内部的分类信息。因此，虽然PCA后的数据在表示上更加方便（降低了维数并能最大限度的保持原有信息），但在分类上也许会变得更加困难；上图右侧是LDA的降维思想，可以看到LDA充分利用了数据的分类信息，将两组数据映射到了另外一个坐标轴上，使得数据更易区分了（在低维上就可以区分，减少了运算量）。</p></li></ul></li></ul><p>线性判别分析LDA算法由于其简单有效性在多个领域都得到了广泛地应用，是目前机器学习、数据挖掘领域经典且热门的一个算法；但是算法本身仍然存在一些局限性：</p><p>​当样本数量远小于样本的特征维数，样本与样本之间的距离变大使得距离度量失效，使LDA算法中的类内、类间离散度矩阵奇异，不能得到最优的投影方向，在人脸识别领域中表现得尤为突出</p><p>​LDA不适合对非高斯分布的样本进行降维</p><p>​LDA在样本分类信息依赖方差而不是均值时，效果不好</p><p>​LDA可能过度拟合数据</p><p>LDA用于降维，和PCA有很多相同，也有很多不同的地方，因此值得好好的比较一下两者的降维异同点。<br>首先我们看看相同点：<br>　　1）两者均可以对数据进行降维。<br>　　2）两者在降维时均使用了矩阵特征分解的思想。<br>　　3）两者都假设数据符合高斯分布。<br>我们接着看看不同点：<br>　　1）LDA是有监督的降维方法，而PCA是无监督的降维方法<br>　　2）LDA降维最多降到类别数k-1的维数，而PCA没有这个限制。<br>　　3）LDA除了可以用于降维，还可以用于分类。<br>　　4）LDA选择分类性能最好的投影方向，而PCA选择样本点投影具有最大方差的方向。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当特征选择完成后，可以直接训练模型了，但是可能由于特征矩阵过大，导致计算量大，训练时间长的问题，因此降低特征矩阵维度也是必不可少的。常见的降维方法除了以上提到的基于L1惩罚项的模型以外，另外还有主成分分析法（PCA）和线性判别分析（LDA），线性判别分析本身也是一个分类模型。PCA和LDA有很多的相似点，其本质是要将原始的样本映射到维度更低的样本空间中，但是PCA和LDA的映射目标不一样：</span><br><span class="line"></span><br><span class="line">PCA是为了让映射后的样本具有最大的发散性；</span><br><span class="line">而LDA是为了让映射后的样本有最好的分类性能。</span><br><span class="line">所以说PCA是一种无监督的降维方法，而LDA是一种有监督的降维方法。</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu76d0evyej612m0q6jtl02.jpg" alt="image-20210906202056458"></p><h4 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h4><p>当数据预处理完成后，我们需要选择有意义的特征输入机器学习的算法和模型进行训练。通常来说，从两个方面考虑来选择特征：</p><ul><li>特征是否发散：如果一个特征不发散，例如方差接近于0，也就是说样本在这个特征上基本上没有差异，这个特征对于样本的区分并没有什么用。</li><li>特征与目标的相关性：这点比较显见，与目标相关性高的特征，应当优选选择。除方差法外，本文介绍的其他方法均从相关性考虑。</li></ul><p>　　根据特征选择的形式又可以将特征选择方法分为3种：</p><ul><li>Filter：过滤法，按照发散性或者相关性对各个特征进行评分，设定阈值或者待选择阈值的个数，选择特征。</li><li>Wrapper：包装法，根据目标函数（通常是预测效果评分），每次选择若干特征，或者排除若干特征。</li><li>Embedded：嵌入法，先使用某些机器学习的算法和模型进行训练，得到各个特征的权值系数，根据系数从大到小选择特征。类似于Filter方法，但是是通过训练来确定特征的优劣。</li></ul><p>　　我们使用sklearn中的feature_selection库来进行特征选择。</p><h5 id="方差选择法"><a href="#方差选择法" class="headerlink" title="方差选择法"></a>方差选择法</h5><p>用方差选择法，先要计算各个特征的方差，然后根据阈值，选择方差大于阈值的特征。使用feature_selection库的VarianceThreshold类来选择特征的代码如下：</p><h3 id="sklearn进行数据挖掘"><a href="#sklearn进行数据挖掘" class="headerlink" title="sklearn进行数据挖掘"></a>sklearn进行数据挖掘</h3><p><a href="https://www.cnblogs.com/jasonfreak/p/5448462.html">https://www.cnblogs.com/jasonfreak/p/5448462.html</a></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu87lsl5g2j61d40ikac002.jpg" alt="image-20210907175015539"></p><h4 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h4><p>　　并行处理，流水线处理，自动化调参，持久化是使用sklearn优雅地进行数据挖掘的核心。并行处理和流水线处理将多个特征处理工作，甚至包括模型训练工作组合成一个工作（从代码的角度来说，即将多个对象组合成了一个对象）。在组合的前提下，自动化调参技术帮我们省去了人工调参的反锁。训练好的模型是贮存在内存中的数据，持久化能够将这些数据保存在文件系统中，之后使用时无需再进行训练，直接从文件系统中加载即可</p><ul><li>并行处理：并行处理使得多个特征处理工作能够并行地进行。根据对特征矩阵的读取方式不同，可分为整体并行处理和部分并行处理。整体并行处理，即并行处理的每个工作的输入都是特征矩阵的整体；部分并行处理，即可定义每个工作需要输入的特征矩阵的列</li><li>部分并行处理： 整体并行处理有其缺陷，在一些场景下，我们只需要对特征矩阵的某些列进行转换，而不是所有列。pipeline并没有提供相应的类（仅OneHotEncoder类实现了该功能），需要我们在FeatureUnion的基础上进行优化</li><li>流水线处理：　　pipeline包提供了Pipeline类来进行流水线处理。流水线上除最后一个工作以外，其他都要执行fit_transform方法，且上一个工作输出作为下一个工作的输入。最后一个工作必须实现fit方法，输入为上一个工作的输出；但是不限定一定有transform方法，因为流水线的最后一个工作可能是训练！</li><li>自动化调参：网格搜索为自动化调参的常见技术之一，grid_search包提供了自动化调参的工具，包括GridSearchCV类。<strong>穷举搜索</strong>：在所有候选的参数选择中，通过循环遍历，尝试每一种可能性，表现最好的参数就是最终的结果。其原理就像是在数组里找最大值。<ul><li>存在问题：原始数据集划分成训练集和测试集以后，其中测试集除了用作调整参数，也用来测量模型的好坏；这样做导致最终的评分结果比实际效果要好。 耗时</li><li>对训练集再进行一次划分，分成训练集和验证集，这样划分的结果就是：原始数据划分为3份，分别为：训练集、验证集和测试集；其中训练集用来模型训练，验证集用来调整参数，而测试集用来衡量模型表现好坏。</li></ul></li><li>持久化：　externals.joblib包提供了dump和load方法来持久化和加载内存数据：</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据挖掘-1&quot;&gt;&lt;a href=&quot;#数据挖掘-1&quot; class=&quot;headerlink&quot; title=&quot;数据挖掘 1&quot;&gt;&lt;/a&gt;数据挖掘 1&lt;/h1&gt;&lt;h2 id=&quot;1-岗位信息&quot;&gt;&lt;a href=&quot;#1-岗位信息&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="100_CodingSkills" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/"/>
    
    <category term="105_Python" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/105-Python/"/>
    
    <category term="数据挖掘" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/105-Python/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-104-MiddleWare-00-MiddleWareInterview/"/>
    <id>http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-104-MiddleWare-00-MiddleWareInterview/</id>
    <published>2024-08-15T09:50:31.523Z</published>
    <updated>2024-08-15T09:50:43.445Z</updated>
    
    <content type="html"><![CDATA[<hr><p>00_MiddleWareInterview<br>aliases:<br>tags: #cs#interview #mysql<br>date: 2023-10-08 15:29</p><hr><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="1-Basic-Concept"><a href="#1-Basic-Concept" class="headerlink" title="1. Basic Concept"></a>1. Basic Concept</h2><h3 id="mysql的事务是什么"><a href="#mysql的事务是什么" class="headerlink" title="mysql的事务是什么"></a>mysql的事务是什么</h3><p>在数据库中，事务（Transaction）是一组操作单元，这些操作单元要么全部执行成功，要么全部执行失败。事务是保证数据库一致性的重要机制之一，它可以将一系列的操作看作一个整体，从而保证数据库的完整性和正确性。</p><p>事务具有四个特性，即ACID：</p><ul><li><p>原子性（Atomicity）：事务中的所有操作要么全部执行成功，要么全部执行失败，不会出现部分执行的情况。</p></li><li><p>一致性（Consistency）：事务执行前后数据库的状态是一致的，即数据库中的约束和规则都得到了保持。</p></li><li><p>隔离性（Isolation）：多个事务并发执行时，相互之间不会影响彼此的执行结果。</p></li><li><p>持久性（Durability）：事务执行完成后，对数据库所作的修改将被永久保存到数据库中。</p></li></ul><p>MySQL是一种常见的关系型数据库，支持事务的机制。在MySQL中，事务可以</p><p>通过使用事务控制语句（Transaction Control Statements）来进行管理，包括以下三个语句：</p><ul><li><p>START TRANSACTION：开始一个事务。</p></li><li><p>COMMIT：提交一个事务，使之生效。</p></li><li><p>ROLLBACK：回滚一个事务，使之失效。</p></li></ul><p>在MySQL中，事务默认是关闭的，需要通过设置autocommit参数为0来启用事务。启用事务后，可以通过执行SQL语句来进行事务操作，</p><h3 id="数据库的事务的4个特性是什么？并发事务会带来什么问题？"><a href="#数据库的事务的4个特性是什么？并发事务会带来什么问题？" class="headerlink" title="数据库的事务的4个特性是什么？并发事务会带来什么问题？"></a>数据库的事务的4个特性是什么？并发事务会带来什么问题？</h3><ol><li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li><li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><p>并发事务的问题：</p><ul><li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li><li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A&#x3D;20，事务2也读取A&#x3D;20，事务1修改A&#x3D;A-1，事务2也修改A&#x3D;A-1，最终结果A&#x3D;19，事务1的修改被丢失。</li><li><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li><li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li></ul><p>事务隔离的级别：</p><ul><li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li><li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li><li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。（MySQL默认）</li><li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li></ul><h3 id="一条语句，问怎么加索引比较好？什么情况应该加索引，什么情况不应该加？"><a href="#一条语句，问怎么加索引比较好？什么情况应该加索引，什么情况不应该加？" class="headerlink" title="一条语句，问怎么加索引比较好？什么情况应该加索引，什么情况不应该加？"></a>一条语句，问怎么加索引比较好？什么情况应该加索引，什么情况不应该加？</h3><p>在 MySQL 中，创建索引可以提高查询性能。为了给某个列添加索引，我们可以使用以下语句：<br>CREATE INDEX index_name ON table_name(column_name);<br>在这里，index_name是你为索引指定的名称，table_name是你要添加索引的表名，而column_name是你要添加索引的列名。<br>在选择要添加索引的列时，请考虑以下几点：<br>对于经常用于查询条件的列，添加索引可以提高查询速度。<br>对于具有许多重复值的列，添加索引的性能提升可能不明显。<br>尽量避免在非常大的表上创建过多索引，因为这会影响插入和更新操作的性能。</p><p>面试问题</p><p>1）TCP&#x2F;IP协议<br>    1）三次握手&#x2F;四次挥手过程<br>    2）TIME_WAIT状态<br>        1）主动关闭&#x2F;被动关闭<br>        2）需要的原因<br>        3）缓解措施<br>        4）有没有方式不出现TIME_WAIT状态<br>    3）RST出现的场景<br>    4）滑动窗口<br>2）网络编程<br>    1）EPOLL&#x2F;SELECT的区别<br>    2）边沿触发&#x2F;水平触发<br>    3）事件触发的场景<br>        1）读事件 有哪些场景<br>        2）写事件 有哪些场景<br>    4）READ调用返回值场景<br>        1）0<br>        2）-1<br>        3）&gt;0<br>    5）UDP客户端可以CONNECT不，那CONNECT和不CONNECT有啥区别<br>3）后台编程<br>    1）FORK的用途，FORK区分父子进程方式<br>    2）进程间通信方式<br>    3）僵尸进程<br>    4）内存模型，有哪些段构成<br>    5）进程&#x2F;线程&#x2F;协程的区别<br>4）常见中间件<br>    1）MYSQL<br>        1）为啥不建议SELECT *<br>        2）覆盖索引<br>        3）分页优化<br>    2）ZOOKEEPER<br>        1）有哪些WATCH以及对应唤醒事件<br>    3）KAFKA<br>        1）分区分服<br>        2）生产者<br>        3）消费者<br>5）语言<br>    1）JAVA语言<br>        1）内存管理<br>6）设计模式<br>    1）单例模式<br>7）项目中的难点、挑战点</p><p>22989-腾讯云网络后台开发工程师(CSIG全资子公司)（西安）</p><p>建议用online ddl（网上可以查）修改，就是逗号后面的参数<br>另外，添加字段要加上after，根据表结构看看fromWanIp适合在哪个字段后<br>ALTER TABLE cEip ALTER COLUMN ispId SET DEFAULT -1, ALGORITHM&#x3D;INPLACE, LOCK&#x3D;NONE;</p><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="1-Basic-Concept-1"><a href="#1-Basic-Concept-1" class="headerlink" title="1. Basic Concept"></a>1. Basic Concept</h2><h3 id="微博上的热度排行榜用什么数据结构"><a href="#微博上的热度排行榜用什么数据结构" class="headerlink" title="微博上的热度排行榜用什么数据结构"></a>微博上的热度排行榜用什么数据结构</h3><p>答：Zset，讲了讲zrangebyscore</p><p><strong>补充：</strong></p><p>Zset 类型（Sorted Set，有序集合） 可以根据元素的权重来排序，我们可以自己来决定每个元素的权重值。比如说，我们可以根据元素插入 Sorted Set 的时间确定权重值，先插入的元素权重小，后插入的元素权重大。</p><p>在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，可以优先考虑使用 Sorted Set。</p><p>有序集合比较典型的使用场景就是排行榜。例如学生成绩的排名榜、游戏积分排行榜、视频播放排名、电商系统中商品的销量排名等。</p><p>我们以博文点赞排名为例，小林发表了五篇博文，分别获得赞为 200、40、100、50、150。</p><p>&#96;# arcticle:1 文章获得了200个赞  </p><blockquote><p> ZADD user:xiaolin:ranking 200 arcticle:1   (integer) 1<br> # arcticle:2 文章获得了40个赞   &gt; ZADD user:xiaolin:ranking 40 arcticle:2   (integer) 1   # arcticle:3 文章获得了100个赞   &gt; ZADD user:xiaolin:ranking 100 arcticle:3   (integer) 1   # arcticle:4 文章获得了50个赞   &gt; ZADD user:xiaolin:ranking 50 arcticle:4   (integer) 1   # arcticle:5 文章获得了150个赞   &gt; ZADD user:xiaolin:ranking 150 arcticle:5   (integer) 1   &#96;</p></blockquote><p>文章 arcticle:4 新增一个赞，可以使用 ZINCRBY 命令（为有序集合key中元素member的分值加上increment）：</p><p><code>&gt; ZINCRBY user:xiaolin:ranking 1 arcticle:4   &quot;51&quot;   </code></p><p>查看某篇文章的赞数，可以使用 ZSCORE 命令（返回有序集合key中元素个数）：</p><p><code>&gt; ZSCORE user:xiaolin:ranking arcticle:4   &quot;50&quot;   </code></p><p>获取小林文章赞数最多的 3 篇文章，可以使用 ZREVRANGE 命令（倒序获取有序集合 key 从start下标到stop下标的元素）：</p><p><code># WITHSCORES 表示把 score 也显示出来   &gt; ZREVRANGE user:xiaolin:ranking 0 2 WITHSCORES   1) &quot;arcticle:1&quot;   2) &quot;200&quot;   3) &quot;arcticle:5&quot;   4) &quot;150&quot;   5) &quot;arcticle:3&quot;   6) &quot;100&quot;   </code></p><p>获取小林 100 赞到 200 赞的文章，可以使用 ZRANGEBYSCORE 命令（返回有序集合中指定分数区间内的成员，分数由低到高排序）：</p><p><code>&gt; ZRANGEBYSCORE user:xiaolin:ranking 100 200 WITHSCORES   1) &quot;arcticle:3&quot;   2) &quot;100&quot;   3) &quot;arcticle:5&quot;   4) &quot;150&quot;   5) &quot;arcticle:1&quot;   6) &quot;200&quot;   </code></p><h3 id="rehash的过程讲一下"><a href="#rehash的过程讲一下" class="headerlink" title="rehash的过程讲一下"></a>rehash的过程讲一下</h3><p>答：新旧表双写，逐渐迁移</p><p><strong>补充：</strong></p><p>为了避免 rehash 在数据迁移过程中，因拷贝数据的耗时，影响 Redis 性能的情况，所以 Redis 采用了<strong>渐进式 rehash</strong>，也就是将数据的迁移的工作不再是一次性迁移完成，而是分多次迁移。</p><p>渐进式 rehash 步骤如下：</p><ul><li><p>给「哈希表 2」 分配空间，一般会比「哈希表 1」 大 2 倍；</p></li><li><p>在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺序将「哈希表 1 」中索引位置上的所有 key-value 迁移到「哈希表 2」 上；</p></li><li><p>随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间点会把「哈希表 1 」的所有 key-value 迁移到「哈希表 2」，从而完成 rehash 操作。</p></li></ul><p>这样就巧妙地把一次性大量数据迁移工作的开销，分摊到了多次处理请求的过程中，避免了一次性 rehash 的耗时操作。</p><p>在进行渐进式 rehash 的过程中，会有两个哈希表，所以在渐进式 rehash 进行期间，哈希表元素的删除、查找、更新等操作都会在这两个哈希表进行。</p><p>比如，查找一个 key 的值的话，先会在「哈希表 1」 里面进行查找，如果没找到，就会继续到哈希表 2 里面进行找到。</p><p>另外，在渐进式 rehash 进行期间，新增一个 key-value 时，会被保存到「哈希表 2 」里面，而「哈希表 1」 则不再进行任何添加操作，这样保证了「哈希表 1 」的 key-value 数量只会减少，随着 rehash 操作的完成，最终「哈希表 1 」就会变成空表。</p><h3 id="迁移过程中老表是什么时候释放，怎么知道老表可以释放了"><a href="#迁移过程中老表是什么时候释放，怎么知道老表可以释放了" class="headerlink" title="迁移过程中老表是什么时候释放，怎么知道老表可以释放了"></a>迁移过程中老表是什么时候释放，怎么知道老表可以释放了</h3><p>答：通过数据长度</p><p><strong>补充：</strong></p><p>每个 hash table 都有存着一个 used 字段，每次单步 rehash 完成的时候，最后都会检查老表即  ht[0].used 是否变成了 0，变成 0 后，就说明老的哈希表里已经没有数据了，此时就会去 free 掉老表，交换老表新表的指针，rehashidx 置为 -1，然后就完成了整个 rehash。</p><h1 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h1><h2 id="1-Basic-Concept-2"><a href="#1-Basic-Concept-2" class="headerlink" title="1. Basic Concept"></a>1. Basic Concept</h2><h3 id="protobuf的使用"><a href="#protobuf的使用" class="headerlink" title="protobuf的使用"></a>protobuf的使用</h3><p>Protobuf 是用于数据序列化和反序列化的格式，类似于 json。但它们有以下几点区别：</p><ul><li><p>数据大小：Protobuf是一种二进制格式，相对于JSON来说，数据大小更小，序列化和反序列化的效率更高，因此在网络传输和存储方面具有一定的优势。</p></li><li><p>性能：由于Protobuf是二进制格式，相对于JSON来说，解析速度更快，占用的CPU和内存资源更少，因此在高并发场景下，性能更优。</p></li><li><p>可读性：JSON是一种文本格式，可读性更好，易于调试和排查问题。而Protobuf是一种二进制格式，可读性较差。</p></li></ul><p>Protobuf适用于高性能、大数据量、高并发等场景，而JSON适用于数据交换、易读性要求高的场景。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;00_MiddleWareInterview&lt;br&gt;aliases:&lt;br&gt;tags: #cs#interview #mysql&lt;br&gt;date: 2023-10-08 15:29&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;MySQL&quot;&gt;&lt;a href=&quot;#MySQL&quot; </summary>
      
    
    
    
    <category term="100_CodingSkills" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/"/>
    
    <category term="104_MiddleWare" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/104-MiddleWare/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-105-Python-00-PythonInterview/"/>
    <id>http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-105-Python-00-PythonInterview/</id>
    <published>2024-08-15T09:50:31.523Z</published>
    <updated>2024-08-15T09:50:43.445Z</updated>
    
    <content type="html"><![CDATA[<hr><p>00_PythonInterview<br>aliases:<br>tags: #cs#interview #python<br>date: 2023-10-08 15:29</p><hr><h2 id="1-基础语法"><a href="#1-基础语法" class="headerlink" title="1. 基础语法"></a>1. 基础语法</h2><ul><li>可变类型与不可变类型，如何判断一个变量是可变还是不可变</li><li>python的函数传参是值传递还是引用传递</li><li>逻辑表达式中，哪些值是假？（0，空串，空容器，False，None）</li><li>列表和元组有什么不同？</li><li>range和xrange有什么区别？</li><li>for循环如何同时遍历索引和值</li><li>什么是静态方法，如何定义</li><li>静态方法和类方法的区别是什么？</li><li>list如何去重？</li><li>如何判断字符串是否含有某个字串（in比str.find好）为什么？</li><li>is None和&#x3D;&#x3D; None有什么区别？</li><li>什么是GIL, 多线程多进程</li><li>type isinstance区别</li><li>字符串拼接用 join和+的区别</li><li>list、set、tuple 区别，实现细节、效率</li><li>python中的封装、继承、多态</li></ul><h2 id="2-python编码"><a href="#2-python编码" class="headerlink" title="2. python编码"></a>2. python编码</h2><ul><li>python实现单例（多种）</li><li>python实现带参数、带返回值的装饰器（统计函数执行时间为例等，函数名覆盖问题）  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;func.__name__&#125;</span> took <span class="subst">&#123;end_time - start_time:<span class="number">.6</span>f&#125;</span>s.&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">    </span><br><span class="line"><span class="meta">@timer </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>(<span class="params">x, y</span>): </span><br><span class="line">time.sleep(<span class="number">1</span>) </span><br><span class="line"><span class="keyword">return</span> x + y </span><br><span class="line">result = my_func(<span class="number">3</span>, <span class="number">4</span>) <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></li></ul><p>如果需要传递额外参数给装饰器，可以在装饰器外层再添加一层函数，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repeat</span>(<span class="params">n=<span class="number">3</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                result = func(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@repeat(<span class="params">n=<span class="number">5</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>(<span class="params">x, y</span>):</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">result = my_func(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>repeat是一个外层函数，用于接收额外参数n，并返回一个内层函数decorator。decorator函数则是真正的装饰器函数，接受一个函数作为参数，并返回一个内部函数wrapper。wrapper函数接受任意数量的位置参数和关键字参数，并调用原函数，重复执行n次，并返回最后一次函数执行结果。</p><p>总之，Python的装饰器是一种强大的语法特性，可以用于对函数进行增强、统计函数执行时间等操作，提高程序的可维护性和可扩展性。在使用装饰器时，应该注意保留原函数名，避免装饰器对函数名造成覆盖。</p><ul><li>合并两个数组、排序</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;00_PythonInterview&lt;br&gt;aliases:&lt;br&gt;tags: #cs#interview #python&lt;br&gt;date: 2023-10-08 15:29&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;1-基础语法&quot;&gt;&lt;a href=&quot;#1-基础语法&quot; c</summary>
      
    
    
    
    <category term="100_CodingSkills" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/"/>
    
    <category term="105_Python" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/105-Python/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-104-MiddleWare-202204-MYSQ%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9CL/"/>
    <id>http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-104-MiddleWare-202204-MYSQ%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9CL/</id>
    <published>2024-08-15T09:50:31.523Z</published>
    <updated>2024-08-15T09:50:43.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-数据库操作"><a href="#1-数据库操作" class="headerlink" title="1 数据库操作"></a>1 数据库操作</h2><h3 id="字符集切换"><a href="#字符集切换" class="headerlink" title="字符集切换"></a>字符集切换</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> names utf8; </span><br><span class="line"><span class="keyword">set</span> names latin1;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="知道字段名，反查在哪张表"><a href="#知道字段名，反查在哪张表" class="headerlink" title="知道字段名，反查在哪张表"></a>知道字段名，反查在哪张表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_schema <span class="operator">=</span> <span class="string">&#x27;库名&#x27;</span> <span class="keyword">and</span> column_name<span class="operator">=</span><span class="string">&#x27;字段名&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="知道表名，反查在哪个库里"><a href="#知道表名，反查在哪个库里" class="headerlink" title="知道表名，反查在哪个库里"></a>知道表名，反查在哪个库里</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table_schema <span class="keyword">FROM</span> information_schema.TABLES <span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;表名&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename <span class="keyword">table</span> MyClass <span class="keyword">to</span> YouClass;</span><br></pre></td></tr></table></figure><h3 id="备份表"><a href="#备份表" class="headerlink" title="备份表"></a>备份表</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h10.18.110.12 -umysql_user -pmysql_passwd -P22001 tgwoss_apd tb_isp &gt; tb_isp.sql</span><br><span class="line"></span><br><span class="line">mysqldump -h10.18.110.12 -umysql_user -pmysql_passwd -P22001 tgwoss_apd &lt; tb_isp.sql</span><br></pre></td></tr></table></figure><h3 id="导出数据库"><a href="#导出数据库" class="headerlink" title="导出数据库"></a>导出数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">导出整个数据库结构和数据</span><br><span class="line">mysqldump -h localhost -uroot -p123456 database &gt; dump.sql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">导出单个数据表结构和数据</span><br><span class="line">mysqldump -h localhost -uroot -p123456  database table &gt; dump.sql</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">导出整个数据库结构（不包含数据）</span><br><span class="line"></span><br><span class="line">mysqldump -h localhost -uroot -p123456  -d database &gt; dump.sql </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">导出单个数据表结构（不包含数据）</span><br><span class="line">mysqldump -h localhost -uroot -p123456  -d database table &gt; dump.sql</span><br><span class="line"></span><br><span class="line">导出多个表</span><br><span class="line"> mysqldump -t database -u username -ppassword --tables table_name1 table_name2 table_name3 &gt;D:\db_script.sql</span><br><span class="line"></span><br><span class="line">导入sql</span><br><span class="line">mysql -h localhost -P 3306 -u root -p 数据库名&lt; a.sql // sql文件可以包含创建表、存储过程等的语句</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-数据库操作&quot;&gt;&lt;a href=&quot;#1-数据库操作&quot; class=&quot;headerlink&quot; title=&quot;1 数据库操作&quot;&gt;&lt;/a&gt;1 数据库操作&lt;/h2&gt;&lt;h3 id=&quot;字符集切换&quot;&gt;&lt;a href=&quot;#字符集切换&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="100_CodingSkills" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/"/>
    
    <category term="104_MiddleWare" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/104-MiddleWare/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-103-Productivity-2023-ChatGpt/"/>
    <id>http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-103-Productivity-2023-ChatGpt/</id>
    <published>2024-08-15T09:50:31.522Z</published>
    <updated>2024-08-15T09:50:43.445Z</updated>
    
    <content type="html"><![CDATA[<h3 id="APIKEY"><a href="#APIKEY" class="headerlink" title="APIKEY"></a>APIKEY</h3><p>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</p><h3 id="1-Better-Pormpt"><a href="#1-Better-Pormpt" class="headerlink" title="1. Better Pormpt"></a>1. Better Pormpt</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">you need answer my question obey the format, format should be like this</span><br><span class="line">correct grammar is :</span><br><span class="line">&quot;insert correct grammar here&quot; </span><br><span class="line">________________________________  (keep the diver line)</span><br><span class="line">you can also ask it like this:</span><br><span class="line">&quot;insert better prompt here&quot;</span><br><span class="line">________________________________</span><br><span class="line">then tell the answer about what i ask below the divier also keep the diver line.</span><br><span class="line"></span><br><span class="line">Correct grammar is should correct my question&#x27;s grammar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果chatgpt没理解，可以继续训练</span><br><span class="line">no, you misunderstand. I mean divider style like:</span><br><span class="line"></span><br><span class="line">Corrected grammar: &quot;Who is Britney Spears?&quot;</span><br><span class="line">________________________________ </span><br><span class="line">Better prompt: &quot;Can you provide more information about Britney Spears?&quot;</span><br><span class="line">________________________________ </span><br><span class="line">Answer: Britney Spears is an American singer, dancer, and actress who gained worldwide fame in the late 1990s and early 2000s with her pop music hits such as &quot;...Baby One More Time&quot;, &quot;Oops!... I Did It Again&quot;, and &quot;Toxic&quot;. She has won numerous awards for her music and has also acted in films and television shows. Spears has been recognized as one of the best-selling female music artists of all time.</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;APIKEY&quot;&gt;&lt;a href=&quot;#APIKEY&quot; class=&quot;headerlink&quot; title=&quot;APIKEY&quot;&gt;&lt;/a&gt;APIKEY&lt;/h3&gt;&lt;p&gt;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&lt;/p</summary>
      
    
    
    
    <category term="100_CodingSkills" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/"/>
    
    <category term="103_ Productivity" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/103-Productivity/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-103-Productivity-typora-use/"/>
    <id>http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-103-Productivity-typora-use/</id>
    <published>2024-08-15T09:50:31.522Z</published>
    <updated>2024-08-15T09:50:43.445Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h4 id="相关快捷键"><a href="#相关快捷键" class="headerlink" title="相关快捷键"></a>相关快捷键</h4><h5 id="创建标题"><a href="#创建标题" class="headerlink" title="创建标题"></a>创建标题</h5><h6 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h6><p>快捷键：<code>cmd + 1</code></p><h6 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h6><p>快捷键：<code>cmd + 2</code></p><h6 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h6><p>快捷键：<code>cmd + 3</code></p><h6 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h6><p>快捷键：<code>cmd + 4</code></p><h6 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h6><p>快捷键：<code>cmd + 5</code></p><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>快捷键：<code>cmd + 6</code></p><h5 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h5><h6 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h6><p>使用<code>sup</code>包裹 腾讯TM</p><h6 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h6><p>使用<code>sub</code>包裹 h2o</p><h6 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h6><p>快捷键：<code>cmd + u</code> 用下划线修饰</p><h6 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h6><p>使用<code>~~</code>修饰：我是删除线</p><h6 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h6><p>快捷键：cmd + i <em>我是斜体</em></p><h6 id="文本居中"><a href="#文本居中" class="headerlink" title="文本居中"></a>文本居中</h6><p>使用 <code>center</code> 修饰</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;center&gt;居中显示&lt;/center&gt;</span><br></pre></td></tr></table></figure><p>居中显示</p><h6 id="文本加粗"><a href="#文本加粗" class="headerlink" title="文本加粗"></a>文本加粗</h6><p>快捷键：cmd + b <strong>我是需要文本加粗的</strong></p><h6 id="文本加粗-斜体"><a href="#文本加粗-斜体" class="headerlink" title="文本加粗 + 斜体"></a>文本加粗 + 斜体</h6><p>使用<code>***</code>符号标记起来 <em><strong>我是文本加粗并且是斜体</strong></em></p><h6 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h6><p>使用<code>&gt;</code>标记</p><blockquote><p>我是应用文字吆</p></blockquote><h6 id="选中某行"><a href="#选中某行" class="headerlink" title="选中某行"></a>选中某行</h6><p>快捷键：cmd + l</p><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><h6 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h6><p>快捷键：cmd + f</p><h6 id="查找并替换"><a href="#查找并替换" class="headerlink" title="查找并替换"></a>查找并替换</h6><p>快捷键：cmd + option + f</p><h6 id="当前目录查找"><a href="#当前目录查找" class="headerlink" title="当前目录查找"></a>当前目录查找</h6><p>快捷键：cmd + shift + f</p><h4 id="其他相关"><a href="#其他相关" class="headerlink" title="其他相关"></a>其他相关</h4><h6 id="切换模式"><a href="#切换模式" class="headerlink" title="切换模式"></a>切换模式</h6><p>集中模式 - 快捷键：F8</p><p>TypeWrite模式 - 快捷键：F9</p><blockquote><p>如果需要退出这两种模式的话，再次点击该快捷键即可</p></blockquote><h6 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h6><p>快捷键：control + -</p><h6 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h6><p>使用<code>[网址][链接地址]</code> [百度一下吧][<a href="http://www.baidu.com]">http://www.baidu.com]</a></p><h6 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h6><p>快捷键：cmd + option + c</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cons = <span class="string">&#x27;100.0&#x27;</span>, num = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h6 id="创建表格"><a href="#创建表格" class="headerlink" title="创建表格"></a>创建表格</h6><p>快捷键：cmd + option + t</p><h6 id="删除表格行"><a href="#删除表格行" class="headerlink" title="删除表格行"></a>删除表格行</h6><p>快捷键：cmd + shift + delete</p><h6 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h6><p>快捷键：cmd + ctrl + i</p><h6 id="文档目录"><a href="#文档目录" class="headerlink" title="文档目录"></a>文档目录</h6><p>使用<code>[toc]</code>命令来生成</p><h6 id="视图切换"><a href="#视图切换" class="headerlink" title="视图切换"></a>视图切换</h6><table><thead><tr><th align="left">模式</th><th align="left">快捷键</th></tr></thead><tbody><tr><td align="left">outline</td><td align="left">cmd + control + 1</td></tr><tr><td align="left">Article</td><td align="left">cmd + control + 2</td></tr><tr><td align="left">FileTree</td><td align="left">cmd + control + 3</td></tr></tbody></table><h6 id="表情符号"><a href="#表情符号" class="headerlink" title="表情符号"></a>表情符号</h6><p>以<code>:</code>开头输入相应的英文字母</p><p><a href="javascript:;">收起 <img src="https://csdnimg.cn/release/aggregate/img/arrow-down@2x.png" alt="img"></a></p><p><img src="https://csdnimg.cn/release/aggregate/img/tags.png" alt="img"> <a href="https://www.csdn.net/tags/MtzaIg0sMjEwMjEtYmxvZwO0O0OO0O0O.html">macos</a> <a href="https://www.csdn.net/tags/MtTaEg0sMjI3NDgtYmxvZwO0O0OO0O0O.html">markdown</a></p></li><li><p><a href="https://blog.csdn.net/eren1/article/details/117485046"><em>Typora</em>常用<em>快捷键</em>（自收藏用）</a><em>千次阅读</em>2021-06-02 21:45:28</p><h1 id="typora快捷键"><a href="#typora快捷键" class="headerlink" title="typora快捷键"></a>typora快捷键</h1><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><p>标题：Ctrl+数字</p><p>*<strong>加粗：Ctrl+b*</strong> *<strong>倾斜：Ctrl+i*</strong> <strong>下划线：Ctrl+u</strong></p><p>Ctrl+L 选中一整行</p><p>Ctrl+d 选中某个单词</p><p>ctrl+e 选中相同格式的文字</p><p>Alt+shift+5（或者<code>~~删除~~</code>） 删除线</p><p>Ctrl+Home 返回Typora顶部</p><p>Ctrl+End 返回Typora底部</p><p>Ctrl+t 创建表格</p><p>Ctrl+K <a href="https://www.csdn.net/tags/www.bilibili.com">创建超链接</a></p><blockquote><p>Ctrl+Shift+q(直接输入 &gt; ) 引用</p></blockquote><p>Ctrl+Shift+i（或直接拖动到指定位置） 插入图片</p><p>注：一些实体符号需要在实体符号之前加”\”才能够显示</p><p>Shift+Alt+L 显示大纲&#x2F;文件</p><p>Ctrl+p 快速打开最近文档</p><h2 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h2><p>在<strong>markdown</strong>中，段落由多个空格分隔。在<strong>Typora</strong>中，只需回车即可创建新段落。</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ul><li>有序列表：Ctrl+Shift+[<ul><li>无序列表：Ctrl+Shift+】 或 +-*(按一下这三个中的任一个然后按空格)<ul><li>任务列表：-空格[空格]空格 文字或者Shift+Alt+R<ul><li>\ -[ ] 不勾选 \ -[x] 勾选</li></ul></li></ul></li></ul></li></ul><p>增大列表缩进：Ctrl + [ 减小列表缩进：Ctrl + ]</p><p><code>- [ ]</code>不勾选</p><p><code>- [ ]</code>勾选</p><ul><li>不勾选</li><li>勾选</li></ul><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><ul><li><p>单行代码用两个&#96;</p><p>如<code>code</code></p><p>多行用下面 Typora 中代码的插入也可以分为行内和块间两种：</p></li><li><p>行内代码：用 <code>...</code> 或 <code>...</code> 括起代码，代码会以主题中设置的样式出现在行内，但不会实现代码高亮。 代码块：输入 &#96;&#96;&#96; 后并输入语言名，换行，开始写代码，Typora 就会自动帮你实现代码高亮。Typora 原生支持许多编程语言代码块的语法高亮。 除此以外，你也可以直接换行开始写，而后再选择语言。</p></li><li><p>输入&#96;&#96;&#96; + 回车</p></li><li><p>Ctrl+Shift+K</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a;</span><br></pre></td></tr></table></figure><h2 id="数学表达式-公式块"><a href="#数学表达式-公式块" class="headerlink" title="数学表达式(公式块)"></a>数学表达式(公式块)</h2><ul><li>Ctrl+Shift+M</li><li>LaTeX 行内公式（inline）：用 <code>$...$</code> 括起公式，公式会出现在行内。 块间公式（display）：用<code>$$...$$</code> 括起公式（注意 $$ 后需要换行），公式会默认显示在行中间。</li></ul><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>链接引用: 类似于我们常在论文末尾看到的「参考文献」的写法，你可以通过 []: 的语法来为你的文档加上链接引用。</p><p>这个例子的脚注为2</p><p>你可以创建一个脚注，像这样1.</p><p>脚注: 在需要插入脚注标号的位置写 number ，再在下方通过</p><p>[ number ]  在文档中插入脚注。注意不要遗漏了脚注编号 number 前后的空格。</p><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>输入<code>***</code>或<code>---</code> 再按回车即可绘制一条水平线</p><hr><h2 id="目录（TOC）"><a href="#目录（TOC）" class="headerlink" title="目录（TOC）"></a>目录（TOC）</h2><p>输入<code>[toc]</code>然后回车</p><p>typora快捷键常用快捷键换行符列表代码块数学表达式(公式块)脚注分割线目录（TOC）内部链接网址图片斜体表情符号上下标高亮文本居中换行符转义HTML换行另外</p><h2 id="内部链接"><a href="#内部链接" class="headerlink" title="内部链接"></a>内部链接</h2><p>这是一个带有标题属性的 <code>[链接](http://example.com/ &quot;标题&quot;)</code> 这是一个没有标题属性的 <code>[链接](http://example.net/)</code></p><p>效果如下</p><p>这是一个带有标题属性的<a href="http://example.com/">链接</a> 这是一个没有标题属性的<a href="http://example.net/">链接</a>.</p><h2 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h2><p>Typora允许用&lt;括号括起来&gt;, 把URL作为链接插入。</p><p><a href="https://www.csdn.net/tags/www.baidu.com">www.baidu.com</a></p><p>Typora还会自动链接标准网址。</p><p><a href="https://www.csdn.net/tags/www.baidu.com">www.baidu.com</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>显示da文字</p><h2 id="斜体-1"><a href="#斜体-1" class="headerlink" title="斜体"></a>斜体</h2><p>使用 <code>*单个星号*</code> 或者 <code>_单下划线_</code> 可以字体倾斜。快捷键 <code>Ctrl + I</code></p><p><em>狼来了</em> <em>啦啦啦</em></p><h2 id="表情符号-1"><a href="#表情符号-1" class="headerlink" title="表情符号"></a>表情符号</h2><p>输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情</p><p>:+英文:</p><p>😄</p><h2 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h2><p>可以使用 <code>&lt;sub&gt;文本&lt;/sub&gt;</code>或者<code>~2~</code>实现下标。</p><p>使用<code>^2^</code>实现上标</p><p>H2o</p><p>H2o</p><p>X2</p><h2 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h2><p><code>==高亮==</code> 高亮</p><h2 id="文本居中-1"><a href="#文本居中-1" class="headerlink" title="文本居中"></a>文本居中</h2><p>使用 <code>&lt;center&gt;这是要居中的内容&lt;/center&gt;</code>可以使文本居中</p><p>这是要居中的内容</p><h2 id="换行符-1"><a href="#换行符-1" class="headerlink" title="换行符"></a>换行符</h2><p>使用 <code>空格 + 空格 + Enter</code>可以实现换行，例如：</p><p>或者可以使用<code>&lt;br/&gt;</code>实现换行。 换行</p><h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>\ 反斜线 &#96; 反引号 * 星号 <em>_ 下划线 {} 花括号 [] 方括号 () 小括号 # 井字号 + 加号 - 减号 . 英文句点 ! 感叹号</em></p><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>目前支持的 HTML 元素有：<code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>等 ，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用 <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>Ctrl<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span>+<span class="tag">&lt;<span class="name">kbd</span>&gt;</span>Alt<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span>+<span class="tag">&lt;<span class="name">kbd</span>&gt;</span>Del<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span> 重启电脑</span><br><span class="line"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span> <span class="tag">&lt;/<span class="name">kbd</span>&gt;</span> -- 白色框框</span><br></pre></td></tr></table></figure><p>效果： 使用 Ctrl+Alt+Del 重启电脑</p><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><blockquote><p>区快；</p></blockquote><p>空格：在输入连续的空格后，Typora 会在编辑器视图里为你保留这些空格，但当你打印或导出时，这些空格会被省略成一个。你可以在源代码模式下，为每个空格前加一个 \ 转义符，或者直接使用 HTML 风格的 &amp;nbps; 来保持连续的空格。 软换行：Shift + Enter 只在编辑界面可见，当文档被导出时换行会被省略。 硬换行：空格 + 空格 + Shift + Enter 文档被导出时将被保留，没有换段的段后距。 换段：你可以通过 Enter 完成一次换段。Typora 会自动帮你完成两次 Shift + Enter 的软换行，从而完成一次换段。这也意味着在 Markdown 语法下，换段是通过在段与段之间加入空行来实现的。 Windows 风格（CR+LF）与 Unix 风格（CR）的换行符：CR 表示回车 \r ，即回到一行的开头，而 LF 表示换行 \n ，即另起一行。 所以 Windows 风格的换行符本质是「回车 + 换行」，而 Unix 风格的换行符是「换行」。这也是为什么 Unix &#x2F; Mac 系统下的文件，如果在 Windows 系统直接打开会全部在同一行内。 你可以在 文件 - 偏好设置 - 编辑器 - 默认换行符 中对此进行切换。 emoji :emoji: 打出 emoji，自动给出图形的提示。</p><h2 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h2><p>文件系统 导入：支持的文件格式：.docx, .latex, .tex, .ltx, .rst, .rest, .org, .wiki, .dokuwiki, .textile, .opml, .epub。 导出：支持导出 PDF，HTML等格式。可安装 Pandoc 插件来导出更多例如 docx，LaTeX 等格式。</p><p>[2]  1 这是上面脚注的实际内容</p><p>[1]  定义脚注</p></li></ul><h1 id="for-my-test"><a href="#for-my-test" class="headerlink" title="for my test:"></a>for my test:</h1><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p><strong>加黑一下</strong></p><p><u>加下划线</u></p><p><a href="https://www.baidu.com/">加链接</a></p><p>:smile:</p><p><a href="http://www.baidu.com/">http://www.baidu.com</a></p><p>&lt;<a href="http://www.baidu.com>">www.baidu.com&gt;</a></p><p><a href="http://www.baidu.com/">www.baidu.com</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>fsaf</p><p>$$a&#x3D;b+c$$</p><p><em><strong>afasf</strong></em></p><ul><li><p>yi</p></li><li><p>ers</p></li><li><p>fasfa</p></li><li><p>[]</p></li></ul><blockquote><p>引用</p></blockquote><p>\ -、、、、、’‘’；；；‘’；；‘’[] </p><p><a href="">fafaf</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;相关快捷键&quot;&gt;&lt;a href=&quot;#相关快捷键&quot; class=&quot;headerlink&quot; title=&quot;相关快捷键&quot;&gt;&lt;/a&gt;相关快捷键&lt;/h4&gt;&lt;h5 id=&quot;创建标题&quot;&gt;&lt;a href=&quot;#创建标题&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="100_CodingSkills" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/"/>
    
    <category term="103_ Productivity" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/103-Productivity/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-103-Productivity-2019-%E5%8A%A8%E6%80%81vps%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
    <id>http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-103-Productivity-2019-%E5%8A%A8%E6%80%81vps%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/</id>
    <published>2024-08-15T09:50:31.521Z</published>
    <updated>2024-08-15T09:50:43.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态VPS环境初始化配置"><a href="#动态VPS环境初始化配置" class="headerlink" title="动态VPS环境初始化配置"></a>动态VPS环境初始化配置</h1><hr><p><strong>最近在做一个自动化项目，用到了动态VPS, 刚刚拿到一个新的VPS难免要对系统环境进行一番配置，特此记录下主要的操作步骤，方便自己也方便同道中人。</strong></p><p><em>注：我的VPS 系统是CentOS 7.2， 采用ADSL拨号方式。</em></p><h2 id="1-登录"><a href="#1-登录" class="headerlink" title="1.登录"></a>1.登录</h2><p>由于本人使用的ubuntu系统,所以采用以下命令方式登录。当然也可以借助xshell&#x2F;putty 等ssh工具方便的进行登录。如果是windows系统我强烈推荐使用用MobaXterm, 强大好用！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p port user@host</span><br></pre></td></tr></table></figure><p>如: ssh -p 20110 <a href="mailto:&#114;&#111;&#x6f;&#116;&#x40;&#x31;&#48;&#x30;&#46;&#50;&#x30;&#48;&#46;&#51;&#x30;&#48;&#x2e;&#x34;&#48;&#x30;">&#114;&#111;&#x6f;&#116;&#x40;&#x31;&#48;&#x30;&#46;&#50;&#x30;&#48;&#46;&#51;&#x30;&#48;&#x2e;&#x34;&#48;&#x30;</a> <br>输上以上命令后，按提示输入正确的密码，登录成功。</p><h2 id="2-修改root密码-建议"><a href="#2-修改root密码-建议" class="headerlink" title="2.修改root密码(建议)"></a>2.修改root密码(建议)</h2><p>以root身份登录成功后，建议先修改root密码，一是为了安全; 二是方便自己登录, 不用每次都拷贝粘贴复杂难记的初始密码。</p><p>使用如下命令，按提示输入两次新密码即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure><h2 id="3-查看系统信息"><a href="#3-查看系统信息" class="headerlink" title="3.查看系统信息"></a>3.查看系统信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/redhat-release</span><br></pre></td></tr></table></figure><p>本人使用的环境信息是：<br>CentOS Linux release 7.2.1511 (Core)<br>注：还可以通过 df&#x2F;top等命令查看磁盘、cpu负载信息</p><h2 id="4-拨号网络配置"><a href="#4-拨号网络配置" class="headerlink" title="4.拨号网络配置"></a>4.拨号网络配置</h2><p>如果不进行网络配置是无法正常上网的，这一步很重要。<br>主要使用的命令有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pppoe-setup</span><br><span class="line">pppoe-start</span><br><span class="line">pppoe-stop</span><br><span class="line">pppoe-status</span><br></pre></td></tr></table></figure><ul><li>先通过pppoe-setup命令进行拨号网络配置，此时需要用到VPS服务商给你的ADSL账号及密码，按照提示进行即可。<br>详细操作步骤可参考<a href="https://www.92ez.com/?action=show&id=23447">如何正确的使用动态VPS（Linux）自动更换IP</a></li></ul><h2 id="5-切换国内源"><a href="#5-切换国内源" class="headerlink" title="5.切换国内源"></a>5.切换国内源</h2><p>先对原源进行备份， 然后切换国内163镜像源，提供安装下载速度，特是针对国内VPS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-163-Base.repo http://mirrors.163.com/.help/CentOS7-Base-163.repo</span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><p>以上操作完成后, 你的VPS就可以正常使用了, 接下来按照自己的需求自如的使用你的VPS吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动态VPS环境初始化配置&quot;&gt;&lt;a href=&quot;#动态VPS环境初始化配置&quot; class=&quot;headerlink&quot; title=&quot;动态VPS环境初始化配置&quot;&gt;&lt;/a&gt;动态VPS环境初始化配置&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;最近在做一个自动化项目，用到了动态</summary>
      
    
    
    
    <category term="100_CodingSkills" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/"/>
    
    <category term="103_ Productivity" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/103-Productivity/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-103-Productivity-20210401-%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8%E6%90%9C%E7%B4%A2/"/>
    <id>http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-103-Productivity-20210401-%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8%E6%90%9C%E7%B4%A2/</id>
    <published>2024-08-15T09:50:31.521Z</published>
    <updated>2024-08-15T09:50:43.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="善用搜索引擎"><a href="#善用搜索引擎" class="headerlink" title="善用搜索引擎"></a>善用搜索引擎</h2><ul><li>排除关键词用减号 -： 锤子 -锤子手机</li><li>全词匹配用双引号扣起来</li><li>指定网站内搜索： site:zhihu.com 量化</li><li>指定文件格式：filetype:pdf 平凡的世界</li><li>指定标题搜索 intitle:关键词</li><li>指定范围搜索：<ul><li>Intext正文中包含 ：手机  intext:苹果</li><li>ulr中包含：inurl</li><li>正文包含多个关键词 allintext:后面加多个关键词，空格分割</li></ul></li><li>叠加使用： site:douban.com 亲密关系 intext:罗兰 -爱情</li><li>注意：<ul><li>所有符号都是半角，即英文符号 </li><li>关键词之间加空格， 比如电脑蓝屏，换成：电脑 蓝屏 办法</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;善用搜索引擎&quot;&gt;&lt;a href=&quot;#善用搜索引擎&quot; class=&quot;headerlink&quot; title=&quot;善用搜索引擎&quot;&gt;&lt;/a&gt;善用搜索引擎&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;排除关键词用减号 -： 锤子 -锤子手机&lt;/li&gt;
&lt;li&gt;全词匹配用双引号扣起来&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="100_CodingSkills" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/"/>
    
    <category term="103_ Productivity" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/103-Productivity/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-103-Productivity-202201-GIT%E4%BF%AE%E7%82%BC/"/>
    <id>http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-103-Productivity-202201-GIT%E4%BF%AE%E7%82%BC/</id>
    <published>2024-08-15T09:50:31.521Z</published>
    <updated>2024-08-15T09:50:43.445Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git-删除分支"><a href="#git-删除分支" class="headerlink" title="git 删除分支"></a>git 删除分支</h3><ol><li>切换到要操作的项目文件夹命令行: $ cd <ProjectPath></li><li>查看项目的<strong>分支</strong>们(包括本地和远程) …</li><li><strong>删除</strong>本地<strong>分支</strong>命令行: $ <strong>git</strong> branch -d <BranchName></li><li><strong>删除</strong>远程<strong>分支</strong>命令行: $ <strong>git</strong> push origin –delete <BranchName></li></ol><h3 id="git分支重命名"><a href="#git分支重命名" class="headerlink" title="git分支重命名"></a>git分支重命名</h3><p><strong>1. 本地分支重命名(还没有推送到远程)</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m oldName newName</span><br></pre></td></tr></table></figure><p><strong>2. 远程分支重命名 (已经推送远程-假设本地分支和远程对应分支名称相同)</strong><br> a. 重命名远程分支对应的本地分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m oldName newName</span><br></pre></td></tr></table></figure><p>b. 删除远程分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --delete origin oldName</span><br></pre></td></tr></table></figure><p>c. 上传新命名的本地分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin newName</span><br></pre></td></tr></table></figure><p>d.把修改后的本地分支与远程分支关联</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to origin/newName</span><br></pre></td></tr></table></figure><h3 id="git回滚代码"><a href="#git回滚代码" class="headerlink" title="git回滚代码"></a>git回滚代码</h3><p>只commit并未push的代码回滚</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;版本号&gt;</span><br><span class="line">或</span><br><span class="line">git reset --soft HEAD~1</span><br><span class="line">撤销最近一次的commit(撤销commit，不撤销git add)</span><br><span class="line"></span><br><span class="line">git reset --mixed HEAD~1</span><br><span class="line">撤销最近一次的commit(撤销commit，撤销git add)</span><br><span class="line"></span><br><span class="line">git reset --hard HEAD~1 </span><br><span class="line">撤销最近一次的commit(撤销commit，撤销git add，工作区的代码改动将丢失。操作完成后回到上一次commit状态)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果已经push:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行完上面的rest之后再继续</span><br><span class="line">git push origin &lt;分支名&gt; --force   // 需要有force权限</span><br></pre></td></tr></table></figure><h3 id="git-放弃本地修改"><a href="#git-放弃本地修改" class="headerlink" title="git 放弃本地修改"></a>git 放弃本地修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout . &amp;&amp; git clean -xdf</span><br></pre></td></tr></table></figure><h3 id="修改最后一次commits-已经push过的"><a href="#修改最后一次commits-已经push过的" class="headerlink" title="修改最后一次commits  ,已经push过的"></a>修改最后一次commits  ,已经push过的</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><h3 id="git-撤回commit"><a href="#git-撤回commit" class="headerlink" title="git 撤回commit"></a>git 撤回commit</h3><p>写完代码后，我们一般这样</p><p>git add . &#x2F;&#x2F;添加所有文件</p><p>git commit -m “本功能全部完成”</p><p>执行完commit后，想撤回commit，怎么办？</p><p>这样凉拌：</p><p>git  reset –hard HEAD</p><p>这样就成功的撤销了你的commit</p><p>注意，仅仅是撤回commit操作，您写的代码仍然保留。</p><h4 id="说一下个人理解："><a href="#说一下个人理解：" class="headerlink" title="说一下个人理解："></a>说一下个人理解：</h4><p>HEAD^的意思是上一个版本，也可以写成HEAD~1</p><p>如果你进行了2次commit，想都撤回，可以使用HEAD~2</p><h4 id="至于这几个参数："><a href="#至于这几个参数：" class="headerlink" title="至于这几个参数："></a>至于这几个参数：</h4><ul><li>–mixed</li></ul><p>意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作</p><p>这个为默认参数,git reset –mixed HEAD^ 和 git reset HEAD^ 效果是一样的。</p><ul><li>–soft</li></ul><p>不删除工作空间改动代码，撤销commit，不撤销git add . </p><ul><li>–hard</li></ul><p>删除工作空间改动代码，撤销commit，撤销git add . </p><p>注意完成这个操作后，就恢复到了上一次的commit状态。</p><h4 id="顺便说一下，如果commit注释写错了，只是想改一下注释，只需要："><a href="#顺便说一下，如果commit注释写错了，只是想改一下注释，只需要：" class="headerlink" title="顺便说一下，如果commit注释写错了，只是想改一下注释，只需要："></a>顺便说一下，如果commit注释写错了，只是想改一下注释，只需要：</h4><p>git commit –amend</p><p>此时会进入默认vim编辑器，修改注释完毕后保存就好了。</p><h2 id="git-回退本地修改"><a href="#git-回退本地修改" class="headerlink" title="git 回退本地修改"></a>git 回退本地修改</h2><p>Git checkout . &amp;&amp; git clean -xdf </p><p>git reset -soft HEAD^</p><p>忽略本地所有，和远程分支保持一致<br>git reset –hard origin&#x2F;dev&#x2F;internal_ipv6</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;git-删除分支&quot;&gt;&lt;a href=&quot;#git-删除分支&quot; class=&quot;headerlink&quot; title=&quot;git 删除分支&quot;&gt;&lt;/a&gt;git 删除分支&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;切换到要操作的项目文件夹命令行: $ cd &lt;ProjectPath&gt;&lt;/li&gt;</summary>
      
    
    
    
    <category term="100_CodingSkills" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/"/>
    
    <category term="103_ Productivity" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/103-Productivity/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-103-Productivity-2018-Ubuntu%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%88%AB%E5%90%8D%E5%BF%AB%E9%80%9F%E8%AE%BF%E9%97%AE%E4%BA%91%E4%B8%BB%E6%9C%BA/"/>
    <id>http://amazingcoderpro.github.io/2024/08/15/100-CodingSkills-103-Productivity-2018-Ubuntu%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%88%AB%E5%90%8D%E5%BF%AB%E9%80%9F%E8%AE%BF%E9%97%AE%E4%BA%91%E4%B8%BB%E6%9C%BA/</id>
    <published>2024-08-15T09:50:31.520Z</published>
    <updated>2024-08-15T09:50:43.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu如何利用别名快速访问云主机"><a href="#Ubuntu如何利用别名快速访问云主机" class="headerlink" title="Ubuntu如何利用别名快速访问云主机"></a>Ubuntu如何利用别名快速访问云主机</h1><hr><p>问： 在Ubuntu上访问云主机，共分几步？<br>答： 分以下三步:</p><ul><li>打开记事本，找到要访问的主机的IP、用户名和密码，并拷贝</li><li>输入ssh命令,如ssh <a href="mailto:&#114;&#x6f;&#x6f;&#116;&#64;&#x31;&#50;&#x2e;&#50;&#51;&#x2e;&#x34;&#53;&#46;&#54;&#x37;">&#114;&#x6f;&#x6f;&#116;&#64;&#x31;&#50;&#x2e;&#50;&#51;&#x2e;&#x34;&#53;&#46;&#54;&#x37;</a></li><li>输入或粘贴密码，然后回车，进入云主机</li></ul><p>问：你感觉这样的操作复杂吗？<br>答：不复杂啊，只要三步呀<br>问：那如果你同时要管理十台甚到几十台云主机呢，每次访问一台都要这么做吗？你不累吗？<br>答：滚！</p><p>好了，进入正题，让我们看看如何优雅快速的访问你的云主机吧。</p><p>先说方案，其实很简单: <strong>利用别名（alias）, 事先为每一台云主机设置一个别名（见名知义的那种），并且上传ssh密钥到每一台云主机，这样以后访问该云主机时只需要输入它对应的别名就可以了!什么IP,用户名，密码统统不要了，即安全又省事！</strong><br><em>PS:关于别名这个小技巧也是我从其他同事那学到的，所谓三人行必有我师，真是学到老活到老啊。另外，别名的用途可不仅仅如此啊，可以对很多常用又复杂的命令设置别名，达到快速执行的目的哦！</em>  </p><h2 id="来（wo）看-yao-看-kai-怎-shi-么-zhuang-做-bi-吧（la）-1-配置别名-编辑-bashrc文件-输入别名和对应的云主机登录命令-按G跳到最后一行，输入别名和别名对应的云主机信息-这里假设我的云主机-ip-x3D-12-23-45-56-user-x3D-root-密码-x3D-123456-别名-x3D-zhuji1-2-生成ssh密钥直接三次回车，保存rsa格式的密钥到默认位置，-当然你也可以指定位置。这里的密钥生成一次就可以了，如果提示提示已经有密钥了，跳过此步即可。-3-上传密钥到目标云主机上按照提示，输入该云主机的root账号密码即可。-4-让别名生效"><a href="#来（wo）看-yao-看-kai-怎-shi-么-zhuang-做-bi-吧（la）-1-配置别名-编辑-bashrc文件-输入别名和对应的云主机登录命令-按G跳到最后一行，输入别名和别名对应的云主机信息-这里假设我的云主机-ip-x3D-12-23-45-56-user-x3D-root-密码-x3D-123456-别名-x3D-zhuji1-2-生成ssh密钥直接三次回车，保存rsa格式的密钥到默认位置，-当然你也可以指定位置。这里的密钥生成一次就可以了，如果提示提示已经有密钥了，跳过此步即可。-3-上传密钥到目标云主机上按照提示，输入该云主机的root账号密码即可。-4-让别名生效" class="headerlink" title="~~来（wo）看(yao)看(kai)怎(shi)么(zhuang)做(bi)吧（la）## 1.配置别名- 编辑.bashrc文件, 输入别名和对应的云主机登录命令.按G跳到最后一行，输入别名和别名对应的云主机信息,这里假设我的云主机 ip&#x3D;12.23.45.56,user&#x3D;root,密码&#x3D;123456, 别名&#x3D;zhuji1## 2.生成ssh密钥直接三次回车，保存rsa格式的密钥到默认位置， 当然你也可以指定位置。这里的密钥生成一次就可以了，如果提示提示已经有密钥了，跳过此步即可。## 3.上传密钥到目标云主机上按照提示，输入该云主机的root账号密码即可。## 4.让别名生效"></a><em><strong>~~来（wo）看(yao)看(kai)怎(shi)么(zhuang)做(bi)吧（la）</strong></em><br>## 1.配置别名<br>- 编辑.bashrc文件, 输入别名和对应的云主机登录命令.<br>按G跳到最后一行，输入别名和别名对应的云主机信息,<br><em>这里假设我的云主机 ip&#x3D;12.23.45.56,user&#x3D;root,密码&#x3D;123456, 别名&#x3D;zhuji1</em><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bashrc</span><br><span class="line">alias zhuji1=&quot;ssh root@12.23.45.56&quot;   #123456这里可以备注下密码，方便以后查看</span><br></pre></td></tr></table></figure><br>## 2.生成ssh密钥<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><br>直接三次回车，保存rsa格式的密钥到默认位置， 当然你也可以指定位置。这里的密钥生成一次就可以了，如果提示提示已经有密钥了，跳过此步即可。<br>## 3.上传密钥到目标云主机上<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id root@12.23.45.56</span><br></pre></td></tr></table></figure><br>按照提示，输入该云主机的root账号密码即可。<br>## 4.让别名生效<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></h2><p>好了，别名已经设置好了,现在试试吧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhuji1</span><br></pre></td></tr></table></figure><p>输入刚才设置好的别名， 敲下回车，已经安全进入到我们的云主机了，是不是很方便啊！</p><p>如果你有多台云主机，就继续重复1,3,4步即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ubuntu如何利用别名快速访问云主机&quot;&gt;&lt;a href=&quot;#Ubuntu如何利用别名快速访问云主机&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu如何利用别名快速访问云主机&quot;&gt;&lt;/a&gt;Ubuntu如何利用别名快速访问云主机&lt;/h1&gt;&lt;hr&gt;
</summary>
      
    
    
    
    <category term="100_CodingSkills" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/"/>
    
    <category term="103_ Productivity" scheme="http://amazingcoderpro.github.io/categories/100-CodingSkills/103-Productivity/"/>
    
    
  </entry>
  
</feed>
